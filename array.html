<!DOCTYPE html>
<html>
<head>
<title>Array - GeeksforGeeks</title>

<style type="text/css">
img.wp-smiley, img.emoji {
    display: inline !important; border: none !important; box-shadow: none !important; height: 1em !important;
    width: 1em !important; margin: 0 .07em !important; vertical-align: -0.1em !important; background: none !important; padding: 0 !important;
}
</style>
<style type="text/css" id="custom-background-css">
    body.custom-background { background-color: #ffffff; }
</style>
<style type="text/css">
.gsc-control-cse {
    font-family: Arial, sans-serif;
    border-color: #FFFFFF;
    background-color: #FFFFFF;
}
.gsc-control-cse .gsc-table-result {
    font-family: Arial, sans-serif;
}
input.gsc-input, .gsc-input-box, .gsc-input-box-hover, .gsc-input-box-focus {
    border-color: #6AA84F;
}
input.gsc-search-button, input.gsc-search-button:hover, input.gsc-search-button:focus {
    border-color: #000000;
    background-color: #6AA84F;
    background-image: none;
filter: none;
}
.gsc-tabHeader.gsc-tabhInactive {
    border-color: #E9E9E9;
    background-color: #E9E9E9;
}
.gsc-tabHeader.gsc-tabhActive {
    border-color: #FF9900;
    border-bottom-color: #FFFFFF;
    background-color: #FFFFFF;
}
.gsc-tabsArea {
    border-color: #FF9900;
}
.gsc-webResult.gsc-result,
    .gsc-results .gsc-imageResult {
        border-color: #FFFFFF;
        background-color: #FFFFFF;
    }
.gsc-webResult.gsc-result:hover,
    .gsc-imageResult:hover {
        border-color: #FFFFFF;
        background-color: #FFFFFF;
    }
.gs-webResult.gs-result a.gs-title:link,
    .gs-webResult.gs-result a.gs-title:link b,
    .gs-imageResult a.gs-title:link,
    .gs-imageResult a.gs-title:link b {
color: #006600;
    }
.gs-webResult.gs-result a.gs-title:visited,
    .gs-webResult.gs-result a.gs-title:visited b,
    .gs-imageResult a.gs-title:visited,
    .gs-imageResult a.gs-title:visited b {
color: #EC4E20;
    }
.gs-webResult.gs-result a.gs-title:hover,
    .gs-webResult.gs-result a.gs-title:hover b,
    .gs-imageResult a.gs-title:hover,
    .gs-imageResult a.gs-title:hover b {
color: #CA7700;
    }
.gs-webResult.gs-result a.gs-title:active,
    .gs-webResult.gs-result a.gs-title:active b,
    .gs-imageResult a.gs-title:active,
    .gs-imageResult a.gs-title:active b {
color: #006600;
    }
.gsc-cursor-page {
color: #006600;
}
a.gsc-trailing-more-results:link {
color: #006600;
}
.gs-webResult .gs-snippet,
    .gs-imageResult .gs-snippet,
    .gs-fileFormatType {
color: #000000;
    }
.gs-webResult div.gs-visibleUrl,
    .gs-imageResult div.gs-visibleUrl {
color: #008000;
    }
.gs-webResult div.gs-visibleUrl-short {
color: #008000;
}
.gs-webResult div.gs-visibleUrl-short {
display: none;
}
.gs-webResult div.gs-visibleUrl-long {
display: block;
}
.gs-promotion div.gs-visibleUrl-short {
display: none;
}
.gs-promotion div.gs-visibleUrl-long {
display: block;
}
.gsc-cursor-box {
    border-color: #FFFFFF;
}
.gsc-results .gsc-cursor-box .gsc-cursor-page {
    border-color: #E9E9E9;
    background-color: #FFFFFF;
color: #006600;
}
.gsc-results .gsc-cursor-box .gsc-cursor-current-page {
    border-color: #FF9900;
    background-color: #FFFFFF;
color: #EC4E20;
}
.gsc-webResult.gsc-result.gsc-promotion {
    border-color: #336699;
    background-color: #FFFFFF;
}
.gsc-completion-title {
color: #006600;
}
.gsc-completion-snippet {
color: #000000;
}
.gs-promotion a.gs-title:link,
    .gs-promotion a.gs-title:link *,
    .gs-promotion .gs-snippet a:link {
color: #006600;
    }
.gs-promotion a.gs-title:visited,
    .gs-promotion a.gs-title:visited *,
    .gs-promotion .gs-snippet a:visited {
color: #EC4E20;
    }
.gs-promotion a.gs-title:hover,
    .gs-promotion a.gs-title:hover *,
    .gs-promotion .gs-snippet a:hover {
color: #CA7700;
    }
.gs-promotion a.gs-title:active,
    .gs-promotion a.gs-title:active *,
    .gs-promotion .gs-snippet a:active {
color: #006600;
    }
.gs-promotion .gs-snippet,
    .gs-promotion .gs-title .gs-promotion-title-right,
    .gs-promotion .gs-title .gs-promotion-title-right * {
color: #000000;
    }
.gs-promotion .gs-visibleUrl,
    .gs-promotion .gs-visibleUrl-short {
color: #008000;
    }</style>
<style type="text/css">
.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}
.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}
.gsst_a:hover .gscb_a,
.gsst_a:focus .gscb_a{color:#36c}
.gsst_a{display:inline-block}
.gsst_a{cursor:pointer;padding:0 4px}
.gsst_a:hover{text-decoration:none!important}
.gsst_b{font-size:16px;padding:0 2px;position:relative;user-select:none;-moz-user-select:none;white-space:nowrap}
.gsst_e{opacity:0.55;}
.gsst_a:hover 
.gsst_e,
.gsst_a:focus 
.gsst_e{opacity:0.72;}
.gsst_a:active 
.gsst_e{opacity:1;}
.gsst_f{background:white;text-align:left}
.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-moz-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}
.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}
.gssb_c{border:0;position:absolute;z-index:989}
.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-moz-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}
.gssb_f{visibility:hidden;white-space:nowrap}
.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsq_a{padding:0}.gscsep_a{display:none}
.gssb_a{padding:0 7px}
.gssb_a,
.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}
.gssb_g{text-align:center;padding:8px 0 7px;position:relative}
.gssb_h{font-size:15px;height:28px;margin:0.2em}
.gssb_i{background:#eee}
.gss_ifl{visibility:hidden;padding-left:5px}
.gssb_i 
.gss_ifl{visibility:visible}a
.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a
.gssb_j:hover{text-decoration:underline}
.gssb_l{height:1px;background-color:#e5e5e5}
.gssb_m{color:#000;background:#fff}.gsfe_a{border:1px solid #b9b9b9;border-top-color:#a0a0a0;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);}.gsfe_b{border:1px solid #4d90fe;outline:none;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);}
.gssb_a{padding:0 9px}.gsib_a{padding-right:8px;padding-left:8px}
.gsst_a{padding-top:3px}
.gssb_e{border:0}
.gssb_l{margin:5px 0}
.gssb_c .gsc-completion-container{position:static}
.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}
.gssb_c > tbody > tr,
.gssb_c > tbody > tr > td,
.gssb_d,
.gssb_d > tbody > tr,
.gssb_d > tbody > tr > td,
.gssb_e,
.gssb_e > tbody > tr,
.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}
.gssb_a table,
.gssb_a table tr,
.gssb_a table tr td{padding:0;margin:0;border:0}</style>

<link rel="stylesheet" id="wp-pagenavi-css" href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/pagenavi-css.css" type="text/css" media="all">
<link rel="stylesheet" id="themonic-fonts-css" href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/css.css" type="text/css" media="all">
<link rel="stylesheet" id="themonic-style-css" href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/style.css" type="text/css" media="all">
<link rel="stylesheet" id="custom-style-css" href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/custom.css" type="text/css" media="all">
<link href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shCore.css" type="text/css" rel="stylesheet">
<link href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shThemeDefault.css" type="text/css" rel="stylesheet">

<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/jquery_002.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/jquery-migrate.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
</head>
<body>

<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post1"> <span class="glyphicon glyphicon-collapse-down"></span>

Equilibrium index of an array

</button> <div id="post1" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Equilibrium index of an array</h1>
</header>
<div class="entry-content">
<p>Equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes. For example, in an arrya A: <span id="more-9861"></span></p>
<p>A[0] = -7, A[1] = 1, A[2] = 5, A[3] = 2, A[4] = -4, A[5] = 3, A[6]=0</p>
<p>3 is an equilibrium index, because:<br/>
A[0] + A[1] + A[2]  =  A[4] + A[5] + A[6]</p>
<p>6 is also an equilibrium index, because sum of zero elements is zero, i.e., A[0] + A[1] + A[2] + A[3] + A[4] + A[5]=0</p>
<p>7 is not an equilibrium index, because it is not a valid index of array A.</p>
<p>Write a function <em>int equilibrium(int[] arr, int n)</em>; that given a sequence arr[] of size n, returns an equilibrium index (if any) or -1 if no equilibrium indexes exist. </p>
<p><strong>Method 1 (Simple but inefficient)</strong><br/>
Use two loops. Outer loop iterates through all the element and inner loop finds out whether the current index picked by the outer loop is equilibrium index or not.  Time complexity of this solution is O(n^2).</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include &lt;stdio.h&gt;



int equilibrium(int arr[], int n)

{

  int i, j;

  int leftsum, rightsum;



  /* Check for indexes one by one until an equilibrium

    index is found */

  for ( i = 0; i &lt; n; ++i)

  {

    leftsum = 0;  // initialize left sum for current index i

    rightsum = 0; // initialize right sum for current index i



    /* get left sum */

    for ( j = 0; j &lt; i; j++)

      leftsum  += arr[j];



    /* get right sum */

    for( j = i+1; j &lt; n; j++)

      rightsum += arr[j];



    /* if leftsum and rightsum are same, then we are done */

    if (leftsum == rightsum)

      return i;

    }



  /* return -1 if no equilibrium index is found */

  return -1;

}



int main()

{

  int arr[] = {-7, 1, 5, 2, -4, 3, 0};

  int arr_size = sizeof(arr)/sizeof(arr[0]);

  printf("%d\n", equilibrium(arr, arr_size));



  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n^2)<br/>
<br/></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post2"> <span class="glyphicon glyphicon-collapse-down"></span>

Find duplicates in O(n) time and O(1) extra space

</button> <div id="post2" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find duplicates in O(n) time and O(1) extra space</h1>
</header>
<div class="entry-content">
<p>Given an array of n elements which contains elements from 0 to n-1, with any of these numbers appearing any number of times. Find these repeating numbers in O(n) and using only constant memory space.<span id="more-9755"></span></p>
<p>For example, let n be 7 and array be {1, 2, 3, 1, 3, 6, 6}, the answer should be 1, 3 and 6.</p>
<p>This problem is an extended version of following problem.</p>
<p><a href="http://geeksforgeeks.org/?p=7953">Find the two repeating elements in a given array </a></p>
<p>Method 1 and Method 2 of the above link are not applicable as the question says O(n) time complexity and O(1) constant space. Also, Method 3 and Method 4 cannot be applied here because there can be more than 2 repeating elements in this problem. Method 5 can be extended to work for this problem. Below is the solution that is similar to the Method 5.</p>
<p><strong>Algorithm:</strong></p>
<pre>traverse the list for i= 0 to n-1 elements

{

  check for sign of A[abs(A[i])] ;

  if positive then

     make it negative by   A[abs(A[i])]=-A[abs(A[i])];

  else  // i.e., A[abs(A[i])] is negative

     this   element (ith element of list) is a repetition

}</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;



void printRepeating(int arr[], int size)

{

  int i;

  printf("The repeating elements are: \n");

  for (i = 0; i &lt; size; i++)

  {

    if (arr[abs(arr[i])] &gt;= 0)

      arr[abs(arr[i])] = -arr[abs(arr[i])];

    else

      printf(" %d ", abs(arr[i]));

  }

}



int main()

{

  int arr[] = {1, 2, 3, 1, 3, 6, 6};

  int arr_size = sizeof(arr)/sizeof(arr[0]);

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p>Output:</p>
<pre>The repeating elements are:

1  3  6</pre>
<p>Note: The above program doesn’t handle 0 case (If 0 is present in array). The program can be easily modified to handle that also. It is not handled to keep the code simple.</p>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/HuZJqRDOPo0?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find better ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post3"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the two repeating elements in a given array

</button> <div id="post3" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the two repeating elements in a given array</h1>
</header>
<div class="entry-content">
<p>You are given an array of n+2 elements. All elements of the array are in range 1 to n. And all elements occur once except two numbers which occur twice. Find the two repeating numbers. <span id="more-7953"></span></p>
<p>For example, array = {4, 2, 4, 5, 2, 3, 1} and n = 5</p>
<p>The above array has n + 2 = 7 elements with all elements occurring once except 2 and 4 which occur twice. So the output should be 4 2.</p>
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=763">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<p><strong>Method 1 (Basic)</strong><br/>
Use two loops. In the outer loop, pick elements one by one and count the number of occurrences of the picked element in the inner loop. </p>
<p>This method doesn’t use the other useful data provided in questions like range of numbers is between 1 to n and there are only two repeating elements.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;

void printRepeating(int arr[], int size)

{

  int i, j;

  printf(" Repeating elements are ");

  for(i = 0; i &lt; size; i++)

    for(j = i+1; j &lt; size; j++)

      if(arr[i] == arr[j])

        printf(" %d ", arr[i]);

}     



int main()

{

  int arr[] = {4, 2, 4, 5, 2, 3, 1};

  int arr_size = sizeof(arr)/sizeof(arr[0]);  

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n*n)<br/>
Auxiliary Space: O(1)</p>
<p><strong>Method 2 (Use Count array)</strong><br/>
Traverse the array once.  While traversing, keep track of count of all elements in the array using a temp array count[] of size n, when you see an element whose count is already set, print it as duplicate.</p>
<p>This method uses the range given in the question to restrict the size of count[], but doesn’t use the data that there are only two repeating elements.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;



void printRepeating(int arr[], int size)

{

  int *count = (int *)calloc(sizeof(int), (size - 2));

  int i;

  

  printf(" Repeating elements are ");

  for(i = 0; i &lt; size; i++)

  {  

    if(count[arr[i]] == 1)

      printf(" %d ", arr[i]);

    else

     count[arr[i]]++;

  }    

}     



int main()

{

  int arr[] = {4, 2, 4, 5, 2, 3, 1};

  int arr_size = sizeof(arr)/sizeof(arr[0]);  

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n)</p>
<p><strong>Method 3 (Make two equations)</strong><br/>
Let the numbers which are being repeated are X and Y. We make two equations for X and Y and the simple task left is to solve the two equations.<br/>
We know the sum of integers from 1 to n is n(n+1)/2 and product is n!. We calculate the sum of input array, when this sum is subtracted from n(n+1)/2, we get X + Y because X and Y are the two numbers missing from set [1..n].  Similarly calculate product of input array,  when this product is divided from n!, we get X*Y. Given sum and product of X and Y, we can find easily out X and Y.</p>
<p>Let summation of all numbers in array be S and product be P</p>
<p>X + Y = S – n(n+1)/2<br/>
XY = P/n!</p>
<p>Using above two equations, we can find out X and Y. For array = 4 2 4 5 2 3 1, we get S = 21 and P as 960.</p>
<p>X + Y = 21 – 15 = 6</p>
<p>XY = 960/5! = 8</p>
<p>X – Y = sqrt((X+Y)^2 – 4*XY) = sqrt(4) = 2</p>
<p>Using below two equations, we easily get X = (6 + 2)/2 and Y = (6-2)/2<br/>
X + Y = 6<br/>
X – Y = 2</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/adobe-interview-question-for-software-engineerdeveloper-about-arrays-3#post-2466">geek4u</a> for suggesting this method. As pointed by <a href="http://geeksforgeeks.org/forum/topic/adobe-interview-question-for-software-engineerdeveloper-about-arrays-3#post-2473">Beginer </a>, there can be addition and multiplication overflow problem with this approach.<br/>
The methods 3 and 4 use all useful information given in the question <img alt=":)" class="wp-smiley" src="http://d1gjlxt8vb0knt.cloudfront.net//wp-includes/images/smilies/simple-smile.png" style="height: 1em; max-height: 1em;"/></p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;

#include&lt;math.h&gt;



/* function to get factorial of n */

int fact(int n);



void printRepeating(int arr[], int size)

{

  int S = 0;  /* S is for sum of elements in arr[] */

  int P = 1;  /* P is for product of elements in arr[] */  

  int x,  y;   /* x and y are two repeating elements */

  int D;      /* D is for difference of x and y, i.e., x-y*/

  int n = size - 2,  i;



  /* Calculate Sum and Product of all elements in arr[] */

  for(i = 0; i &lt; size; i++)

  {

    S = S + arr[i];

    P = P*arr[i];

  }        

  

  S = S - n*(n+1)/2;  /* S is x + y now */

  P = P/fact(n);         /* P is x*y now */

  

  D = sqrt(S*S - 4*P); /* D is x - y now */

  

  x = (D + S)/2;

  y = (S - D)/2;

  

  printf("The two Repeating elements are %d &amp; %d", x, y);

}     



int fact(int n)

{

   return (n == 0)? 1 : n*fact(n-1);

}    



int main()

{

  int arr[] = {4, 2, 4, 5, 2, 3, 1};

  int arr_size = sizeof(arr)/sizeof(arr[0]);  

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p><strong>Method 4 (Use XOR)</strong><br/>
Thanks to neophyte  for suggesting this method.<br/>
The approach used here is similar to method 2 of <a href="http://geeksforgeeks.org/?p=2457">this post</a>.<br/>
Let the repeating numbers be X and Y, if we xor all the elements in the array and all integers from 1 to n, then the result is X xor Y.<br/>
The 1’s in binary representation of X xor Y is corresponding to the different bits between X and Y. Suppose that the kth bit of X xor Y is 1, we can xor all the elements in the array and all integers from 1 to n, whose kth bits are 1. The result will be one of X and Y.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

void printRepeating(int arr[], int size)

{

  int xor = arr[0]; /* Will hold xor of all elements */

  int set_bit_no;  /* Will have only single set bit of xor */

  int i;

  int n = size - 2;

  int x = 0, y = 0;

  

  /* Get the xor of all elements in arr[] and {1, 2 .. n} */

  for(i = 1; i &lt; size; i++)

    xor ^= arr[i];  

  for(i = 1; i &lt;= n; i++)

    xor ^= i;   



  /* Get the rightmost set bit in set_bit_no */

  set_bit_no = xor &amp; ~(xor-1);



  /* Now divide elements in two sets by comparing rightmost set

   bit of xor with bit at same position in each element. */

  for(i = 0; i &lt; size; i++)

  {

    if(arr[i] &amp; set_bit_no)

      x = x ^ arr[i]; /*XOR of first set in arr[] */

    else

      y = y ^ arr[i]; /*XOR of second set in arr[] */

  }

  for(i = 1; i &lt;= n; i++)

  {

    if(i &amp; set_bit_no)

      x = x ^ i; /*XOR of first set in arr[] and {1, 2, ...n }*/

    else

      y = y ^ i; /*XOR of second set in arr[] and {1, 2, ...n } */

  }

  

  printf("\n The two repeating elements are %d &amp; %d ", x, y);

}     





int main()

{

  int arr[] = {4, 2, 4, 5, 2, 3, 1};

  int arr_size = sizeof(arr)/sizeof(arr[0]);  

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p><strong>Method 5 (Use array elements as index)</strong><br/>
Thanks to Manish K. Aasawat for suggesting this method.</p>
<pre>

Traverse the array. Do following for every index i of A[].

{

check for sign of A[abs(A[i])] ;

if positive then

   make it negative by   A[abs(A[i])]=-A[abs(A[i])];

else  // i.e., A[abs(A[i])] is negative

   this   element (ith element of list) is a repetition

}

</pre>
<pre>

Example: A[] =  {1, 1, 2, 3, 2}

i=0; 

Check sign of A[abs(A[0])] which is A[1].  A[1] is positive, so make it negative. 

Array now becomes {1, -1, 2, 3, 2}



i=1; 

Check sign of A[abs(A[1])] which is A[1].  A[1] is negative, so A[1] is a repetition.



i=2; 

Check sign of A[abs(A[2])] which is A[2].  A[2] is  positive, so make it negative. '

Array now becomes {1, -1, -2, 3, 2}



i=3; 

Check sign of A[abs(A[3])] which is A[3].  A[3] is  positive, so make it negative. 

Array now becomes {1, -1, -2, -3, 2}



i=4; 

Check sign of A[abs(A[4])] which is A[2].  A[2] is negative, so A[4] is a repetition.

</pre>
<p>Note that this method modifies the original array and may not be a recommended method if we are not allowed to modify the array.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;



void printRepeating(int arr[], int size)

{

  int i;  

 

  printf("\n The repeating elements are");

  

  for(i = 0; i &lt; size; i++)

  {

    if(arr[abs(arr[i])] &gt; 0)

      arr[abs(arr[i])] = -arr[abs(arr[i])];

    else

      printf(" %d ", abs(arr[i]));

  }         

}     



int main()

{

  int arr[] = {1, 3, 2, 2, 1};

  int arr_size = sizeof(arr)/sizeof(arr[0]);

  printRepeating(arr, arr_size);

  getchar();

  return 0;

}

</pre>
<p>The problem can be solved in linear time using other method also, please see <a href="http://www.geeksforgeeks.org/archives/7953/comment-page-1#comment-1300">this </a> and <a href="http://www.geeksforgeeks.org/archives/7953/comment-page-1#comment-1298">this </a>comments</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find better ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post4"> <span class="glyphicon glyphicon-collapse-down"></span>

Segregate Even and Odd numbers

</button> <div id="post4" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Segregate Even and Odd numbers</h1>
</header>
<div class="entry-content">
<p>Given an array A[], write a function that segregates even and odd numbers. The functions should put all even numbers first, and then odd numbers.  <span id="more-7897"></span></p>
<p>Example
<pre>

Input  = {12, 34, 45, 9, 8, 90, 3}

Output = {12, 34, 8, 90, 45, 9, 3} </pre>
<p>In the output, order of numbers can be changed, i.e., in the above example 34 can come before 12 and 3 can come before 9.</p>
<p>The problem is very similar to our old post <a href="http://geeksforgeeks.org/?p=5234">Segregate 0s and 1s in an array</a>, and both of these problems are variation of famous <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Sort/Flag/">Dutch national flag problem</a>.</p>
<pre><strong>

Algorithm: segregateEvenOdd()</strong>

1) Initialize two index variables left and right:  

            left = 0,  right = size -1 

2) Keep incrementing left index until we see an odd number.

3) Keep decrementing right index until we see an even number.

4) If lef &lt; right then swap arr[left] and arr[right]

</pre>
<p><strong>Implementation:</strong><br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]; title: ; notranslate" title="">

// C program to segregate even and odd elements of array

#include&lt;stdio.h&gt;



/* Function to swap *a and *b */

void swap(int *a, int *b);



void segregateEvenOdd(int arr[], int size)

{

    /* Initialize left and right indexes */

    int left = 0, right = size-1;

    while (left &lt; right)

    {

        /* Increment left index while we see 0 at left */

        while (arr[left]%2 == 0 &amp;&amp; left &lt; right)

            left++;



        /* Decrement right index while we see 1 at right */

        while (arr[right]%2 == 1 &amp;&amp; left &lt; right)

            right--;



        if (left &lt; right)

        {

            /* Swap arr[left] and arr[right]*/

            swap(&amp;arr[left], &amp;arr[right]);

            left++;

            right--;

        }

    }

}



/* UTILITY FUNCTIONS */

void swap(int *a, int *b)

{

    int temp = *a;

    *a = *b;

    *b = temp;

}



/* driver program to test */

int main()

{

    int arr[] = {12, 34, 45, 9, 8, 90, 3};

    int arr_size = sizeof(arr)/sizeof(arr[0]);

    int i = 0;



    segregateEvenOdd(arr, arr_size);



    printf("Array after segregation ");

    for (i = 0; i &lt; arr_size; i++)

        printf("%d ", arr[i]);



    return 0;

}

</pre>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post5"> <span class="glyphicon glyphicon-collapse-down"></span>

A Product Array Puzzle

</button> <div id="post5" class="collapse">
<header class="entry-header">
<h1 class="entry-title">A Product Array Puzzle</h1>
</header>
<div class="entry-content">
<p>Given an array arr[] of n integers, construct a Product Array prod[] (of same size) such that prod[i] is equal to the product of all the elements of arr[] except arr[i]. Solve it <strong>without division operator and in O(n)</strong>.<span id="more-7527"></span></p>
<p>Example:<br/>
arr[]  = {10, 3, 5, 6, 2}<br/>
prod[]  = {180, 600, 360, 300, 900}<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=571" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
Algorithm:<br/>
1) Construct a temporary array left[] such that left[i] contains product of all elements on left of arr[i] excluding arr[i].<br/>
2) Construct another temporary array right[] such that right[i] contains product of all elements on on right of arr[i] excluding arr[i].<br/>
3) To get prod[], multiply left[] and right[].</p>
<p>Implementation:</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;



/* Function to print product array for a given array

 arr[] of size n */

void productArray(int arr[], int n)

{

  /* Allocate memory for temporary arrays left[] and right[] */

  int *left = (int *)malloc(sizeof(int)*n);

  int *right = (int *)malloc(sizeof(int)*n);



  /* Allocate memory for the product array */

  int *prod = (int *)malloc(sizeof(int)*n);



  int i, j;



  /* Left most element of left array is always 1 */

  left[0] = 1;



  /* Rightmost most element of right array is always 1 */

  right[n-1] = 1;



  /* Construct the left array */

  for(i = 1; i &lt; n; i++)

    left[i] = arr[i-1]*left[i-1];



  /* Construct the right array */

  for(j = n-2; j &gt;=0; j--)

    right[j] = arr[j+1]*right[j+1];



  /* Construct the product array using

    left[] and right[] */

  for (i=0; i&lt;n; i++)

    prod[i] = left[i] * right[i];



  /* print the constructed prod array */

  for (i=0; i&lt;n; i++)

    printf("%d ", prod[i]);



  return;

}



/* Driver program to test above functions */

int main()

{

  int arr[] = {10, 3, 5, 6, 2};

  int n = sizeof(arr)/sizeof(arr[0]);

  printf("The product array is: \n");

  productArray(arr, n);

  getchar();

}

</pre>
<p>Time Complexity: O(n)<br/>
Space Complexity: O(n)<br/>
 Auxiliary Space: O(n) </p>
<p><strong>The above method can be optimized to work in space complexity  O(1)</strong>.  Thanks to Dileep for suggesting the below solution.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

void productArray(int arr[], int n)

{

  int i, temp = 1;



  /* Allocate memory for the product array */

  int *prod = (int *)malloc(sizeof(int)*n);



  /* Initialize the product array as 1 */

  memset(prod, 1, n);



  /* In this loop, temp variable contains product of

    elements on left side excluding arr[i] */

  for(i=0; i&lt;n; i++)

  {

    prod[i] = temp;

    temp *= arr[i];

  }



  /* Initialize temp to 1 for product on right side */

  temp = 1;



  /* In this loop, temp variable contains product of

    elements on right side excluding arr[i] */

  for(i= n-1; i&gt;=0; i--)

  {

    prod[i] *= temp;

    temp *= arr[i];

  }



  /* print the constructed prod array */

  for (i=0; i&lt;n; i++)

    printf("%d ", prod[i]);



  return;

}

</pre>
<p>Time Complexity: O(n)<br/>
Space Complexity: O(n)<br/>
 Auxiliary Space: O(1) </p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post6"> <span class="glyphicon glyphicon-collapse-down"></span>

Union and Intersection of two sorted arrays

</button> <div id="post6" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Union and Intersection of two sorted arrays</h1>
</header>
<div class="entry-content">
<p>Given two sorted arrays, find their union and intersection.</p>
<p>For example, if the input arrays are: <span id="more-6873"></span><br/>
arr1[] = {1, 3, 4, 5, 7}<br/>
arr2[] = {2, 3, 5, 6}<br/>
Then your program should print Union as {1, 2, 3, 4, 5, 6, 7} and Intersection as {3, 5}. <!--more--><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=537" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Algorithm Union(arr1[], arr2[]):</strong><br/>
For union of two arrays, follow the following merge procedure.<br/>
1) Use two index variables i and j, initial values i = 0, j = 0<br/>
2) If arr1[i] is smaller than arr2[j] then print arr1[i] and increment i.<br/>
3) If arr1[i] is greater than arr2[j] then print arr2[j] and increment j.<br/>
4) If both are same then print any of them and increment both i and j.<br/>
5) Print remaining elements of the larger array.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/* Function prints union of arr1[] and arr2[]

   m is the number of elements in arr1[]

   n is the number of elements in arr2[] */

int printUnion(int arr1[], int arr2[], int m, int n)

{

  int i = 0, j = 0;

  while (i &lt; m &amp;&amp; j &lt; n)

  {

    if (arr1[i] &lt; arr2[j])

      printf(" %d ", arr1[i++]);

    else if (arr2[j] &lt; arr1[i])

      printf(" %d ", arr2[j++]);

    else

    {

      printf(" %d ", arr2[j++]);

      i++;

    }

  }



  /* Print remaining elements of the larger array */

  while(i &lt; m)

   printf(" %d ", arr1[i++]);

  while(j &lt; n)

   printf(" %d ", arr2[j++]);

}



/* Driver program to test above function */

int main()

{

  int arr1[] = {1, 2, 4, 5, 6};

  int arr2[] = {2, 3, 5, 7};

  int m = sizeof(arr1)/sizeof(arr1[0]);

  int n = sizeof(arr2)/sizeof(arr2[0]);

  printUnion(arr1, arr2, m, n);

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(m+n)</p>
<p><strong>Algorithm Intersection(arr1[], arr2[]):</strong><br/>
For Intersection of two arrays, print the element only if the element is present in both arrays.<br/>
1) Use two index variables i and j, initial values i = 0, j = 0<br/>
2) If arr1[i] is smaller than arr2[j] then increment i.<br/>
3) If arr1[i] is greater than arr2[j] then increment j.<br/>
4) If both are same then print any of them and increment both i and j.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/* Function prints Intersection of arr1[] and arr2[]

   m is the number of elements in arr1[]

   n is the number of elements in arr2[] */

int printIntersection(int arr1[], int arr2[], int m, int n)

{

  int i = 0, j = 0;

  while (i &lt; m &amp;&amp; j &lt; n)

  {

    if (arr1[i] &lt; arr2[j])

      i++;

    else if (arr2[j] &lt; arr1[i])

      j++;

    else /* if arr1[i] == arr2[j] */

    {

      printf(" %d ", arr2[j++]);

      i++;

    }

  }

}



/* Driver program to test above function */

int main()

{

  int arr1[] = {1, 2, 4, 5, 6};

  int arr2[] = {2, 3, 5, 7};

  int m = sizeof(arr1)/sizeof(arr1[0]);

  int n = sizeof(arr2)/sizeof(arr2[0]);

  printIntersection(arr1, arr2, m, n);

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(m+n)<br/>
<strong><br/>
Another approach that is useful when difference between sizes of two given arrays is significant.</strong><br/>
The idea is to iterate through the shorter array and do a binary search for every element of short array in big array (note that arrays are sorted). Time complexity of this solution is O(min(mLogn, nLogm)).  This solution works better than the above approach when ratio of larger length to smaller is more than logarithmic order.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/EQQp4B_CU5Q?feature=oembed" width="665"></iframe></p>
<p>See following post for unsorted arrays.<br/>
<a href="http://www.geeksforgeeks.org/find-union-and-intersection-of-two-unsorted-arrays/">Find Union and Intersection of two unsorted arrays</a></p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post7"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum difference between two elements such that larger element appears after the smaller number

</button> <div id="post7" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum difference between two elements such that larger element appears after the smaller number</h1>
</header>
<div class="entry-content">
<p>Given an array arr[] of integers, find out the difference between any two elements <strong>such that larger element appears after the smaller number</strong> in arr[]. <span id="more-6463"></span></p>
<p>Examples: If array is [2, 3, 10, 6, 4, 8, 1] then returned value should be 8 (Diff between 10 and 2).  If array is [ 7, 9, 5, 6, 3, 2 ] then returned value should be 2 (Diff between 7 and 9)<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=567" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Simple)</strong><br/>
Use two loops.  In the outer loop, pick elements one by one and in the inner loop calculate the difference of the picked element with every other element in the array and compare the difference with the maximum difference calculated so far. </p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/* The function assumes that there are at least two

   elements in array.

   The function returns a negative value if the array is

   sorted in decreasing order. 

   Returns 0 if elements are equal */

int maxDiff(int arr[], int arr_size)

{     

  int max_diff = arr[1] - arr[0];

  int i, j;

  for(i = 0; i &lt; arr_size; i++)

  {

    for(j = i+1; j &lt; arr_size; j++)

    {        

      if(arr[j] - arr[i] &gt; max_diff)   

         max_diff = arr[j] - arr[i];

    }    

  }          

  return max_diff;

}    



/* Driver program to test above function */

int main()

{

  int arr[] = {1, 2, 90, 10, 110};

  printf("Maximum difference is %d",  maxDiff(arr, 5));

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n^2)<br/>
Auxiliary Space: O(1)</p>
<p><strong>Method 2 (Tricky and Efficient)</strong><br/>
In this method, instead of taking difference of the picked element with every other element, we take the difference with the minimum element found so far. So we need to keep track of 2 things:<br/>
1) Maximum difference found so far (max_diff).<br/>
2) Minimum number visited so far (min_element).</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/* The function assumes that there are at least two

   elements in array.

   The function returns a negative value if the array is

   sorted in decreasing order.

   Returns 0 if elements are equal  */

int maxDiff(int arr[], int arr_size)

{

  int max_diff = arr[1] - arr[0];

  int min_element = arr[0];

  int i;

  for(i = 1; i &lt; arr_size; i++)

  {       

    if (arr[i] - min_element &gt; max_diff)                               

      max_diff = arr[i] - min_element;

    if (arr[i] &lt; min_element)

         min_element = arr[i];                     

  }

  return max_diff;

}    



/* Driver program to test above function */

int main()

{

  int arr[] = {1, 2, 6, 80, 100};

  int size = sizeof(arr)/sizeof(arr[0]);

  printf("Maximum difference is %d",  maxDiff(arr, size));

  getchar();

  return 0;

}

</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>Like min element, we can also keep track of max element from right side.  See below code suggested by Katamaran</p>
<pre class="brush: cpp; title: ; notranslate" title="">

int maxDiff(int arr[], int n)

{

    int maxDiff = -1; // Initialize Result



    int maxRight = arr[n-1]; // Initialize max element from right side



    for (int i = n-2; i &gt;= 0; i--)

    {

        if (arr[i] &gt; maxRight)

            maxRight = arr[i];

        else

        {

            int diff = maxRight - arr[i];

            if (diff &gt; maxDiff)

            {

                maxDiff = diff;

            }

        }

    }

    return maxDiff;

}

</pre>
<p><strong>Method 3 (Another Tricky Solution)</strong><br/>
First find the difference between the adjacent elements of the array and store all differences in an auxiliary array diff[] of size n-1. Now this problems turns into finding the maximum sum subarray of this difference array.<br/>
Thanks to Shubham Mittal for suggesting this solution.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



int maxDiff(int arr[], int n)

{

    // Create a diff array of size n-1. The array will hold

    //  the difference of adjacent elements

    int diff[n-1];

    for (int i=0; i &lt; n-1; i++)

        diff[i] = arr[i+1] - arr[i];



    // Now find the maximum sum subarray in diff array

    int max_diff = diff[0];

    for (int i=1; i&lt;n-1; i++)

    {

        if (diff[i-1] &gt; 0)

            diff[i] += diff[i-1];

        if (max_diff &lt; diff[i])

            max_diff = diff[i];

    }

    return max_diff;

}



/* Driver program to test above function */

int main()

{

    int arr[] = {80, 2, 6, 3, 100};

    int size = sizeof(arr)/sizeof(arr[0]);

    printf("Maximum difference is %d",  maxDiff(arr, size));

    return 0;

}

</pre>
<p>Output:
<pre>98</pre>
<p>This method is also O(n) time complexity solution, but it requires O(n) extra space</p>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n)</p>
<p>We can modify the above method to work in O(1) extra space. Instead of creating an auxiliary array, we can calculate diff and max sum in same loop. Following is the space optimized version.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

int maxDiff (int arr[], int n)

{

    // Initialize diff, current sum and max sum

    int diff = arr[1]-arr[0];

    int curr_sum = diff;

    int max_sum = curr_sum;



    for(int i=1; i&lt;n-1; i++)

    {

        // Calculate current diff

        diff = arr[i+1]-arr[i];



        // Calculate current sum

        if (curr_sum &gt; 0)

           curr_sum += diff;

        else

           curr_sum = diff;



        // Update max sum, if needed

        if (curr_sum &gt; max_sum)

           max_sum = curr_sum;

    }



    return max_sum;

}

</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/SO0bwMziLlU?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post8"> <span class="glyphicon glyphicon-collapse-down"></span>

Segregate 0s and 1s in an array

</button> <div id="post8" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Segregate 0s and 1s in an array</h1>
</header>
<div class="entry-content">
<p>Asked by <a href="http://geeksforgeeks.org/forum/topic/segregate-0-on-left-and-1-on-right-in-0n">kapil</a>.</p>
<p>You are given an array of 0s and 1s in random order.  Segregate 0s on left side and 1s on right side of the array. Traverse array only once.<span id="more-5234"></span></p>
<pre>

Input array   =  [0, 1, 0, 1, 0, 0, 1, 1, 1, 0] 

Output array =  [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] 

</pre>
<p><strong>Method 1 (Count 0s or 1s) </strong><br/>
Thanks to <a href="http://geeksforgeeks.org/forum/topic/segregate-0-on-left-and-1-on-right-in-0n">Naveen </a>for suggesting this method.<br/>
1) Count the number of 0s. Let count be C.<br/>
2) Once we have count, we can put C 0s at the beginning and 1s at the remaining n – C positions in array.</p>
<p>Time Complexity: O(n)</p>
<p>The method 1 traverses the array two times.  Method 2 does the same in a single pass.</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post9"> <span class="glyphicon glyphicon-collapse-down"></span>

Check for Majority Element in a sorted array

</button> <div id="post9" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Check for Majority Element in a sorted array</h1>
</header>
<div class="entry-content">
<p><strong>Question:</strong> Write a C function to find if a given integer x appears more than n/2 times in a sorted array of n integers. <span id="more-4722"></span></p>
<p>Basically, we need to write a function say isMajority() that takes an array (arr[] ), array’s size (n) and a number to be searched (x) as parameters and returns true if x is a <a href="http://www.geeksforgeeks.org/archives/503">majority element </a>(present more than n/2 times).</p>
<p>Examples:</p>
<pre>

Input: arr[] = {1, 2, 3, 3, 3, 3, 10}, x = 3

Output: True (x appears more than n/2 times in the given array)



Input: arr[] = {1, 1, 2, 4, 4, 4, 6, 6}, x = 4

Output: False (x doesn't appear more than n/2 times in the given array)



Input: arr[] = {1, 1, 1, 2, 2}, x = 1

Output: True (x appears more than n/2 times in the given array)

</pre>
<p><strong>METHOD 1 (Using Linear Search)</strong><br/>
Linearly search for the first occurrence of the element, once you find it (let at index i), check element at index i + n/2.  If element is present at i+n/2 then return 1 else return 0.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]; title: ; notranslate" title="">

/* C Program to check for majority element in a sorted array */

# include &lt;stdio.h&gt;

# include &lt;stdbool.h&gt;



bool isMajority(int arr[], int n, int x)

{

    int i;



    /* get last index according to n (even or odd) */

    int last_index = n%2? (n/2+1): (n/2);



    /* search for first occurrence of x in arr[]*/

    for (i = 0; i &lt; last_index; i++)

    {

        /* check if x is present and is present more than n/2

           times */

        if (arr[i] == x &amp;&amp; arr[i+n/2] == x)

            return 1;

    }

    return 0;

}



/* Driver program to check above function */

int main()

{

     int arr[] ={1, 2, 3, 4, 4, 4, 4};

     int n = sizeof(arr)/sizeof(arr[0]);

     int x = 4;

     if (isMajority(arr, n, x))

        printf("%d appears more than %d times in arr[]",

               x, n/2);

     else

        printf("%d does not appear more than %d times in arr[]",

                x, n/2);



   return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]; title: ; notranslate" title="">

/* Program to check for majority element in a sorted array */

import java.io.*;



class Majority {



    static boolean isMajority(int arr[], int n, int x)

    {

        int i, last_index = 0;



        /* get last index according to n (even or odd) */

        last_index = (n%2==0)? n/2: n/2+1;



        /* search for first occurrence of x in arr[]*/

        for (i = 0; i &lt; last_index; i++)

        {

            /* check if x is present and is present more

               than n/2 times */

            if (arr[i] == x &amp;&amp; arr[i+n/2] == x)

                return true;

        }

        return false;

    }



    /* Driver function to check for above functions*/

    public static void main (String[] args) {

        int arr[] = {1, 2, 3, 4, 4, 4, 4};

        int n = arr.length;

        int x = 4;

        if (isMajority(arr, n, x)==true)

           System.out.println(x+" appears more than "+

                              n/2+" times in arr[]");

        else

           System.out.println(x+" does not appear more than "+

                              n/2+" times in arr[]");

    }

}

/*This article is contributed by Devesh Agrawal*/

</pre>
<p></p></div></div><br/>
Output:
<pre>4 appears more than 3 times in arr[]</pre>
<p><strong>Time Complexity: </strong> O(n)</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post10"> <span class="glyphicon glyphicon-collapse-down"></span>

Leaders in an array

</button> <div id="post10" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Leaders in an array</h1>
</header>
<div class="entry-content">
<p>Write a program to print all the LEADERS in the array. An element is leader if it is greater than all the elements to its right side.  And the rightmost element is always a leader. For example int the array {16, 17, 4, 3, 5, 2}, leaders are  17, 5 and 2. <span id="more-3511"></span></p>
<p>Let the input array be arr[] and size of the array be <em>size</em>.</p>
<div id="practice"></div>
<p><strong>Method 1 (Simple)</strong><br/>
Use two loops.  The outer loop runs from 0 to size – 1 and one by one picks all elements from left to right.  The inner loop compares the picked element to all the elements to its right side.  If the picked element is greater than all the elements to its right side, then the picked element is the leader.<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate" title="">

#include&lt;iostream&gt;

using namespace std;



/*C++ Function to print leaders in an array */

void printLeaders(int arr[], int size)

{

    for (int i = 0; i &lt; size; i++)

    {

        int j;

        for (j = i+1; j &lt; size; j++)

        {

            if (arr[i] &lt;= arr[j])

                break;

        }    

        if (j == size) // the loop didn't break

            cout &lt;&lt; arr[i] &lt;&lt; " ";

  }

}



/* Driver program to test above function */

int main()

{

    int arr[] = {16, 17, 4, 3, 5, 2};

    int n = sizeof(arr)/sizeof(arr[0]);

    printLeaders(arr, n);

    return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post11"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum sum such that no two elements are adjacent

</button> <div id="post11" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum sum such that no two elements are adjacent</h1>
</header>
<div class="entry-content">
<p><strong>Question:</strong> Given an array of positive numbers, find the maximum sum of a subsequence with the constraint that no 2 numbers in the sequence should be adjacent in the array. So 3 2 7 10 should return 13 (sum of 3 and 10) or 3 2 5 10 7 should return 15 (sum of 3, 5 and 7).Answer the question in most efficient way. <span id="more-3133"></span><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=531" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Algorithm:</strong><br/>
Loop for all elements in arr[] and maintain two sums incl and excl where incl = Max sum including the previous element and excl = Max sum excluding the previous element.</p>
<p>Max sum excluding the current element will be max(incl, excl) and max sum including the current element will be excl + current element (Note that only excl is considered because elements cannot be adjacent). </p>
<p>At the end of the loop return max of incl and excl.</p>
<p><strong>Example:</strong></p>
<pre>

  arr[] = {5,  5, 10, 40, 50, 35}



  inc = 5 

  exc = 0



  For i = 1 (current element is 5)

  incl =  (excl + arr[i])  = 5

  excl =  max(5, 0) = 5



  For i = 2 (current element is 10)

  incl =  (excl + arr[i]) = 15

  excl =  max(5, 5) = 5



  For i = 3 (current element is 40)

  incl = (excl + arr[i]) = 45

  excl = max(5, 15) = 15



  For i = 4 (current element is 50)

  incl = (excl + arr[i]) = 65

  excl =  max(45, 15) = 45



  For i = 5 (current element is 35)

  incl =  (excl + arr[i]) = 80

  excl = max(5, 15) = 65



And 35 is the last element. So, answer is max(incl, excl) =  80

</pre>
<p>Thanks to <a href="http://groups.google.co.in/group/algogeeks/browse_thread/thread/eb90efd8f8d4a040/6700a1c909841637?lnk=gst&amp;q=Given+an+array+all+of+whose+elements+are+positive+numbers%2C+find+the+maximum+sum+of+a+subsequence+with+the+constraint+that+no+2+numbers+in+the+sequence+should+be+adjacent+in+the+array#6700a1c909841637">Debanjan</a> for providing code.</p>
<p><strong>Implementation:</strong><br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/*Function to return max sum such that no two elements

 are adjacent */

int FindMaxSum(int arr[], int n)

{

  int incl = arr[0];

  int excl = 0;

  int excl_new;

  int i;



  for (i = 1; i &lt; n; i++)

  {

     /* current max excluding i */

     excl_new = (incl &gt; excl)? incl: excl;



     /* current max including i */

     incl = excl + arr[i];

     excl = excl_new;

  }



   /* return max of incl and excl */

   return ((incl &gt; excl)? incl : excl);

}



/* Driver program to test above function */

int main()

{

  int arr[] = {5, 5, 10, 100, 10, 5};

  printf("%d \n", FindMaxSum(arr, 6));

  getchar();

  return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post12"> <span class="glyphicon glyphicon-collapse-down"></span>

Block swap algorithm for array rotation

</button> <div id="post12" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Block swap algorithm for array rotation</h1>
</header>
<div class="entry-content">
<p>Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.<br/>
<span id="more-2878"></span><br/>
<img alt="Array" class="aligncenter size-full wp-image-2798" height="58" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array </p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" title="ArrayRotation1" width="395"/></p>
<p><strong>Algorithm:</strong></p>
<pre>

Initialize A = arr[0..d-1] and B = arr[d..n-1]

1) Do following until size of A is equal to size of B



  a)  If A is shorter, divide B into Bl and Br such that Br is of same 

       length as A. Swap A and Br to change ABlBr into BrBlA. Now A

       is at its final place, so recur on pieces of B.  



   b)  If A is longer, divide A into Al and Ar such that Al is of same 

       length as B Swap Al and B to change AlArB into BArAl. Now B

       is at its final place, so recur on pieces of A.



2)  Finally when A and B are of equal size, block swap them.

</pre>
<p><strong>Recursive Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



/*Prototype for utility functions */

void printArray(int arr[], int size);

void swap(int arr[], int fi, int si, int d);



void leftRotate(int arr[], int d, int n)

{ 

  /* Return If number of elements to be rotated is 

    zero or equal to array size */  

  if(d == 0 || d == n)

    return;

    

  /*If number of elements to be rotated is exactly 

    half of array size */  

  if(n-d == d)

  {

    swap(arr, 0, n-d, d);   

    return;

  }  

    

 /* If A is shorter*/              

  if(d &lt; n-d)

  {  

    swap(arr, 0, n-d, d);

    leftRotate(arr, d, n-d);    

  }    

  else /* If B is shorter*/              

  {

    swap(arr, 0, d, n-d);

    leftRotate(arr+n-d, 2*d-n, d); /*This is tricky*/

  }

}



/*UTILITY FUNCTIONS*/

/* function to print an array */

void printArray(int arr[], int size)

{

  int i;

  for(i = 0; i &lt; size; i++)

    printf("%d ", arr[i]);

  printf("%\n ");

} 



/*This function swaps d elements starting at index fi

  with d elements starting at index si */

void swap(int arr[], int fi, int si, int d)

{

   int i, temp;

   for(i = 0; i&lt;d; i++)   

   {

     temp = arr[fi + i];

     arr[fi + i] = arr[si + i];

     arr[si + i] = temp;

   }     

}     



/* Driver program to test above functions */

int main()

{

   int arr[] = {1, 2, 3, 4, 5, 6, 7};

   leftRotate(arr, 2, 7);

   printArray(arr, 7);

   getchar();

   return 0;

}    

</pre>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post13"> <span class="glyphicon glyphicon-collapse-down"></span>

Reversal algorithm for array rotation

</button> <div id="post13" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Reversal algorithm for array rotation</h1>
</header>
<div class="entry-content">
<p>Write a function rotate(arr[], d, n) that rotates arr[] of size n by d elements. <span id="more-2838"></span></p>
<p>Example:
<pre>

Input:  arr[] = [1, 2, 3, 4, 5, 6, 7]

            d = 2

Output: arr[] = [3, 4, 5, 6, 7, 1, 2] 

</pre>
<p><img alt="Array" class="aligncenter size-full wp-image-2798" height="58" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array</p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" title="ArrayRotation1" width="395"/></p>
<p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post14"> <span class="glyphicon glyphicon-collapse-down"></span>

Program for array rotation

</button> <div id="post14" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Program for array rotation</h1>
</header>
<div class="entry-content">
<p>Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.<br/>
<span id="more-2398"></span><br/>
<img alt="Array" class="aligncenter size-full wp-image-2798" height="58" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array</p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" title="ArrayRotation1" width="395"/><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=360" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>METHOD 1 (Use temp array)</strong></p>
<pre>Input arr[] = [1, 2, 3, 4, 5, 6, 7], d = 2, n =7

1) Store d elements in a temp array

   temp[] = [1, 2]

2) Shift rest of the arr[]

   arr[] = [3, 4, 5, 6, 7, 6, 7]

3) Store back the d elements

   arr[] = [3, 4, 5, 6, 7, 1, 2]</pre>
<p><strong>Time complexity</strong> O(n)<br/>
<strong>Auxiliary Space: </strong>O(d)</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post15"> <span class="glyphicon glyphicon-collapse-down"></span>

Write a program to reverse an array or string

</button> <div id="post15" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Write a program to reverse an array or string</h1>
</header>
<div class="entry-content">
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=78" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Iterative way:</strong><br/>
1) Initialize start and end indexes. <span id="more-2567"></span><br/>
    start = 0, end = n-1<br/>
2) In a loop, swap arr[start] with arr[end] and change start and end as follows.<br/>
 start = start +1; end = end – 1</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate" title="">

// Iterative C program to reverse an array

#include&lt;stdio.h&gt;



/* Function to reverse arr[] from start to end*/

void rvereseArray(int arr[], int start, int end)

{

    int temp;

    while (start &lt; end)

    {

        temp = arr[start];   

        arr[start] = arr[end];

        arr[end] = temp;

        start++;

        end--;

    }   

}     



/* Utility that prints out an array on a line */

void printArray(int arr[], int size)

{

  int i;

  for (i=0; i &lt; size; i++)

    printf("%d ", arr[i]);



  printf("\n");

} 



/* Driver function to test above functions */

int main() 

{

    int arr[] = {1, 2, 3, 4, 5, 6};

    printArray(arr, 6);

    rvereseArray(arr, 0, 5);

    printf("Reversed array is \n");

    printArray(arr, 6);    

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate" title="">

// Java program to reverse an array

import java.io.*;



class ReverseArray {



    /* Function to reverse arr[] from start to end*/

    static void rvereseArray(int arr[], int start, int end)

    {

        int temp;

        if (start &gt;= end)

            return;

        temp = arr[start];

        arr[start] = arr[end];

        arr[end] = temp;

        rvereseArray(arr, start+1, end-1);

    }



    /* Utility that prints out an array on a line */

    static void printArray(int arr[], int size)

    {

        int i;

        for (i=0; i &lt; size; i++)

            System.out.print(arr[i] + " ");

        System.out.println("");

    }



    /*Driver function to check for above functions*/

    public static void main (String[] args) {

        int arr[] = {1, 2, 3, 4, 5, 6};

        printArray(arr, 6);

        rvereseArray(arr, 0, 5);

        System.out.println("Reversed array is ");

        printArray(arr, 6);

    }

}

/*This code is contributed by Devesh Agrawal*/

</pre>
<p></p></div></div><br/>
Output:
<pre>

1 2 3 4 5 6 

Reversed array is 

6 5 4 3 2 1 </pre>
<p>Time Complexity: O(n)</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post16"> <span class="glyphicon glyphicon-collapse-down"></span>

Merge an array of size n into another array of size m+n

</button> <div id="post16" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Merge an array of size n into another array of size m+n</h1>
</header>
<div class="entry-content">
<p>Asked by Binod<br/>
<strong>Question:</strong><br/>
There are two sorted arrays. First one is of size m+n containing only m elements. Another one is of size n and contains n elements. Merge these two arrays into the first array of size m+n such that the output is sorted.<br/>
<span id="more-1355"></span><br/>
Input: array with m+n elements (mPlusN[]).<br/>
<img alt="MergemPlusN" class="aligncenter size-full wp-image-1390" height="66" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergemPlusN2.gif" title="MergemPlusN" width="300"/>NA =&gt; Value is not filled/available in array mPlusN[]. There should be n such array blocks.</p>
<p>Input: array with n elements (N[]).<br/>
<img alt="MergeN" class="aligncenter size-full wp-image-1396" height="60" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergeN3.gif" title="MergeN" width="180"/></p>
<p>Output: N[] merged into mPlusN[] (Modified mPlusN[])<br/>
<img alt="MergemPlusN_Res" class="aligncenter size-full wp-image-1397" height="66" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergemPlusN_Res2.gif" title="MergemPlusN_Res" width="300"/></p>
<p><strong>Algorithm:</strong></p>
<pre>Let first array be mPlusN[] and other array be N[]

1) Move m elements of mPlusN[] to end.

2) Start from nth element of mPlusN[] and 0th element of N[] and merge them 

    into mPlusN[].

</pre>
<p><strong>Implementation:</strong><br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;



/* Assuming -1 is filled for the places where element

   is not available */

#define NA -1



/* Function to move m elements at the end of array mPlusN[] */

void moveToEnd(int mPlusN[], int size)

{

  int i = 0, j = size - 1;

  for (i = size-1; i &gt;= 0; i--)

    if (mPlusN[i] != NA)

    {

      mPlusN[j] = mPlusN[i];

      j--;

    }

}



/* Merges array N[] of size n into array mPlusN[]

   of size m+n*/

int merge(int mPlusN[], int N[], int m, int n)

{

  int i = n;  /* Current index of i/p part of mPlusN[]*/

  int j = 0; /* Current index of N[]*/

  int k = 0; /* Current index of of output mPlusN[]*/

  while (k &lt; (m+n))

  {

    /* Take an element from mPlusN[] if

       a) value of the picked element is smaller and we have

          not reached end of it

       b) We have reached end of N[] */

    if ((i &lt; (m+n) &amp;&amp; mPlusN[i] &lt;= N[j]) || (j == n))

    {

      mPlusN[k] = mPlusN[i];

      k++;

      i++;

    }

    else  // Otherwise take element from N[]

    {

      mPlusN[k] = N[j];

      k++;

      j++;

    }

  }

}



/* Utility that prints out an array on a line */

void printArray(int arr[], int size)

{

  int i;

  for (i=0; i &lt; size; i++)

    printf("%d ", arr[i]);



  printf("\n");

}



/* Driver function to test above functions */

int main()

{

  /* Initialize arrays */

  int mPlusN[] = {2, 8, NA, NA, NA, 13, NA, 15, 20};

  int N[] = {5, 7, 9, 25};

  int n = sizeof(N)/sizeof(N[0]);

  int m = sizeof(mPlusN)/sizeof(mPlusN[0]) - n;



  /*Move the m elements at the end of mPlusN*/

  moveToEnd(mPlusN, m+n);



  /*Merge N[] into mPlusN[] */

  merge(mPlusN, N, m, n);



  /* Print the resultant mPlusN */

  printArray(mPlusN, m+n);



  return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post17"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the Number Occurring Odd Number of Times

</button> <div id="post17" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the Number Occurring Odd Number of Times</h1>
</header>
<div class="entry-content">
<p>Given an array of positive integers. All numbers occur even number of times except one number which occurs odd number of times. Find the number in O(n) time &amp; constant space.<span id="more-570"></span></p>
<p><strong>Example:</strong><br/>
I/P   = [1, 2, 3, 2, 3, 1, 3]<br/>
O/P  = 3</p>
<div id="practice"></div>
<p>A <strong>Simple Solution</strong> is to run two nested loops. The outer loop picks all elements one by one and inner loop counts number of occurrences of the element picked by outer loop. Time complexity of this solution is O(n<sup>2</sup>).</p>
<p>A <strong>Better Solutio</strong>n is to use Hashing. Use array elements as key and their counts as value. Create an empty hash table. One by one traverse the given array elements and store counts.  Time complexity of this solution is O(n). But it requires extra space for hashing.</p>
<p>The <strong>Best Solution</strong> is to do bitwise XOR of all the elements. XOR of all elements gives us odd occurring element.  Please note that XOR of two elements is 0 if both elements are same  and XOR of a number x with 0 is x.</p>
<p>Below are implementations of this best approach.</p>
<p><strong>Program:</strong><br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12]; title: ; notranslate" title="">    

//C program to find the element occurring odd number of times



#include &lt;stdio.h&gt;

int getOddOccurrence(int ar[], int ar_size)

{

     int i;

     int res = 0; 

     for (i=0; i &lt; ar_size; i++)     

        res = res ^ ar[i];

     

     return res;

}



/* Diver function to test above function */

int main()

{

     int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};

     int n = sizeof(ar)/sizeof(ar[0]);

     printf("%d", getOddOccurrence(ar, n));

     return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post18"> <span class="glyphicon glyphicon-collapse-down"></span>

Majority Element

</button> <div id="post18" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Majority Element</h1>
</header>
<div class="entry-content">
<p><strong>Majority Element:</strong> A majority element in an array A[] of size n is an element that appears more than n/2 times (and hence there is at most one such element).</p>
<p>Write a function which takes an array and emits the majority element (if it exists), otherwise prints NONE as follows:</p>
<pre>       I/P : 3 3 4 2 4 4 2 4 4

       O/P : 4 



       I/P : 3 3 4 2 4 4 2 4

       O/P : NONE

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=305" target="_blank"> </a></p>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p> <br/>
<strong>METHOD 1 (Basic)</strong><br/>
The basic solution is to have two loops and keep track of maximum count for all different elements. If maximum count becomes greater than n/2 then break the loops and return the element having maximum count. If maximum count doesn’t become more than n/2 then majority element doesn’t exist.</p>
<p><strong>Time Complexity:</strong> O(n*n).<br/>
<strong>Auxiliary Space :</strong> O(1).<br/>
<strong>METHOD 2 (Using Binary Search Tree)</strong><br/>
Thanks to Sachin Midha for suggesting this solution.</p>
<p>Node of the Binary Search Tree (used in this approach) will be as follows.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

struct tree

{

  int element;

  int count;

}BST;

</pre>
<p>Insert elements in BST one by one and if an element is already present then increment the count of the node. At any stage, if count of a node becomes more than n/2 then return.<br/>
The method works well for the cases where n/2+1 occurrences of the majority element is present in the starting of the array, for example {1, 1, 1, 1, 1, 2, 3, 4}.<br/>
<strong><br/>
Time Complexity:</strong> If a binary search tree is used then time complexity will be O(n^2). If a <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">self-balancing-binary-search</a> tree is used then O(nlogn)<br/>
<strong>Auxiliary Space: </strong> O(n)<br/>
<strong>METHOD 3 (Using Moore’s Voting Algorithm)</strong></p>
<p>This is a two step process.<br/>
1. Get an element occurring most of the time in the array. This phase will make sure that if there is a majority element then it will return that only.<br/>
2. Check if the element obtained from above step is majority element.</p>
<p><em>1. Finding a Candidate:</em><br/>
The algorithm for first phase that works in O(n) is known as Moore’s Voting Algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element.</p>
<pre>findCandidate(a[], size)

1.  Initialize index and count of majority element

     maj_index = 0, count = 1

2.  Loop for i = 1 to size – 1

    (a)If a[maj_index] == a[i]

        count++

    (b)Else

        count--;

    (c)If count == 0

        maj_index = i;

        count = 1

3.  Return a[maj_index]

</pre>
<p>Above algorithm loops through each element and maintains a count of a[maj_index], If next element is same then increments the count, if next element is not same then decrements the count, and if the count reaches 0 then changes the maj_index to the current element and sets count to 1.<br/>
First Phase algorithm gives us a candidate element. In second phase we need to check if the candidate is really a majority element. Second phase is simple and can be easily done in O(n). We just need to check if count of the candidate element is greater than n/2.</p>
<p>Example:<br/>
A[] = 2, 2, 3, 5, 2, 2, 6<br/>
Initialize:<br/>
maj_index = 0, count = 1 –&gt; candidate ‘2?<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Same as a[maj_index] =&gt; count = 2<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 1<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 0<br/>
Since count = 0, change candidate for majority element to 5 =&gt; maj_index = 3, count = 1<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 0<br/>
Since count = 0, change candidate for majority element to 2 =&gt; maj_index = 4<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Same as a[maj_index] =&gt; count = 2<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 1</p>
<p>Finally candidate for majority element is 2.</p>
<p>First step uses Moore’s Voting Algorithm to get a candidate for majority element.</p>
<p>2.<em> Check if the element obtained in step 1 is majority</em></p>
<pre>printMajority (a[], size)

1.  Find the candidate for majority

2.  If candidate is majority. i.e., appears more than n/2 times.

       Print the candidate

3.  Else

       Print "NONE"

</pre>
<p><strong>Implementation of method 3:</strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]; title: ; notranslate" title="">

/* Program for finding out majority element in an array */

# include&lt;stdio.h&gt;

# define bool int



int findCandidate(int *, int);

bool isMajority(int *, int, int);



/* Function to print Majority Element */

void printMajority(int a[], int size)

{

  /* Find the candidate for Majority*/

  int cand = findCandidate(a, size);



  /* Print the candidate if it is Majority*/

  if(isMajority(a, size, cand))

    printf(" %d ", cand);

  else

    printf("No Majority Element");

}



/* Function to find the candidate for Majority */

int findCandidate(int a[], int size)

{

    int maj_index = 0, count = 1;

    int i;

    for(i = 1; i &lt; size; i++)

    {

        if(a[maj_index] == a[i])

            count++;

        else

            count--;

        if(count == 0)

        {

            maj_index = i;

            count = 1;

        }

    }

    return a[maj_index];

}



/* Function to check if the candidate occurs more than n/2 times */

bool isMajority(int a[], int size, int cand)

{

    int i, count = 0;

    for (i = 0; i &lt; size; i++)

      if(a[i] == cand)

         count++;

    if (count &gt; size/2)

       return 1;

    else

       return 0;

}



/* Driver function to test above functions */

int main()

{

    int a[] = {1, 3, 3, 1, 2};

    int size = (sizeof(a))/sizeof(a[0]);

    printMajority(a, size);

    getchar();

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate" title="">

/* Program for finding out majority element in an array */



class MajorityElement 

{

    /* Function to print Majority Element */

    void printMajority(int a[], int size) 

    {

        /* Find the candidate for Majority*/

        int cand = findCandidate(a, size);



        /* Print the candidate if it is Majority*/

        if (isMajority(a, size, cand))

            System.out.println(" " + cand + " ");

        else 

            System.out.println("No Majority Element");

    }



    /* Function to find the candidate for Majority */

    int findCandidate(int a[], int size) 

    {

        int maj_index = 0, count = 1;

        int i;

        for (i = 1; i &lt; size; i++) 

        {

            if (a[maj_index] == a[i])

                count++;

            else

                count--;

            if (count == 0)

            {

                maj_index = i;

                count = 1;

            }

        }

        return a[maj_index];

    }



    /* Function to check if the candidate occurs more than n/2 times */

    boolean isMajority(int a[], int size, int cand) 

    {

        int i, count = 0;

        for (i = 0; i &lt; size; i++) 

        {

            if (a[i] == cand)

                count++;

        }

        if (count &gt; size / 2) 

            return true;

        else

            return false;

    }



    /* Driver program to test the above functions */

    public static void main(String[] args) 

    {

        MajorityElement majorelement = new MajorityElement();

        int a[] = new int[]{1, 3, 3, 1, 2};

        int size = a.length;

        majorelement.printMajority(a, size);

    }

}



// This code has been contributed by Mayank Jaiswal

</pre>
<p></p></div></div><br/>
Output:</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post19"> <span class="glyphicon glyphicon-collapse-down"></span>

Given an array A[] and a number x, check for pair in A[] with sum as x

</button> <div id="post19" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Given an array A[] and a number x, check for pair in A[] with sum as x</h1>
</header>
<div class="entry-content">
<p>Write a C program that, given an array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x. <span id="more-484"></span><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=552" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>METHOD 1 (Use Sorting)</strong></p>
<p>Algorithm:
<pre>

hasArrayTwoCandidates (A[], ar_size, sum)

1) Sort the array in non-decreasing order.

2) Initialize two index variables to find the candidate 

   elements in the sorted array.

       (a) Initialize first to the leftmost index: l = 0

       (b) Initialize second  the rightmost index:  r = ar_size-1

3) Loop while l &lt; r.

       (a) If (A[l] + A[r] == sum)  then return 1

       (b) Else if( A[l] + A[r] &lt;  sum )  then l++

       (c) Else r--    

4) No candidates in whole array - return 0

</pre>
<p>Time Complexity: Depends on what sorting algorithm we use.  If we use Merge Sort or Heap Sort then (-)(nlogn) in worst case.  If we use Quick Sort then O(n^2) in worst case.<br/>
Auxiliary Space : Again, depends on sorting algorithm. For example auxiliary space is O(n) for merge sort and O(1) for Heap Sort.</p>
<p>Example:<br/>
Let Array be  {1, 4, 45, 6, 10, -8} and sum to find be 16</p>
<p>Sort the array<br/>
A = {-8, 1, 4, 6, 10, 45}</p>
<p>Initialize l = 0,  r = 5<br/>
A[l] + A[r] ( -8 + 45)  &gt;  16    =&gt; decrement r.  Now r = 10<br/>
A[l] + A[r] ( -8 + 10)  &lt;  2      =&gt;  increment l.  Now l = 1<br/>
A[l] + A[r] ( 1 + 10)   &lt;  16    =&gt;  increment l.  Now l = 2<br/>
A[l] + A[r] ( 4 + 10)   &lt;  14    =&gt;  increment l.  Now l = 3<br/>
A[l] + A[r] ( 6 + 10)  == 16    =&gt;  Found candidates (return 1)</p>
<p>Note: If there are more than one pair having the given sum then this algorithm reports only one. Can be easily extended for this though.</p>
<p>Implementation:<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; title: ; notranslate" title="">

# include &lt;stdio.h&gt;

# define bool int



void quickSort(int *, int, int);



bool hasArrayTwoCandidates(int A[], int arr_size, int sum)

{

    int l, r;



    /* Sort the elements */

    quickSort(A, 0, arr_size-1);



    /* Now look for the two candidates in the sorted 

       array*/

    l = 0;

    r = arr_size-1; 

    while (l &lt; r)

    {

         if(A[l] + A[r] == sum)

              return 1; 

         else if(A[l] + A[r] &lt; sum)

              l++;

         else // A[i] + A[j] &gt; sum

              r--;

    }    

    return 0;

}



/* Driver program to test above function */

int main()

{

    int A[] = {1, 4, 45, 6, 10, -8};

    int n = 16;

    int arr_size = 6;

   

    if( hasArrayTwoCandidates(A, arr_size, n))

        printf("Array has two elements with sum 16");

    else

        printf("Array doesn't have two elements with sum 16 ");



    getchar();

    return 0;

}



/* FOLLOWING FUNCTIONS ARE ONLY FOR SORTING 

    PURPOSE */

void exchange(int *a, int *b)

{

    int temp;

    temp = *a;

    *a   = *b;

    *b   = temp;

}



int partition(int A[], int si, int ei)

{

    int x = A[ei];

    int i = (si - 1);

    int j;



    for (j = si; j &lt;= ei - 1; j++)

    {

        if(A[j] &lt;= x)

        {

            i++;

            exchange(&amp;A[i], &amp;A[j]);

        }

    }

    exchange (&amp;A[i + 1], &amp;A[ei]);

    return (i + 1);

}



/* Implementation of Quick Sort

A[] --&gt; Array to be sorted

si  --&gt; Starting index

ei  --&gt; Ending index

*/

void quickSort(int A[], int si, int ei)

{

    int pi;    /* Partitioning index */

    if(si &lt; ei)

    {

        pi = partition(A, si, ei);

        quickSort(A, si, pi - 1);

        quickSort(A, pi + 1, ei);

    }

}

</pre>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post20"> <span class="glyphicon glyphicon-collapse-down"></span>

Count the number of possible triangles

</button> <div id="post20" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count the number of possible triangles</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array of positive integers. Find the number of triangles that can be formed with three different array elements as three sides of triangles. For a triangle to be possible from 3 values, the sum of any two values (or sides) must be greater than the third value (or third side).<span id="more-24842"></span><br/>
For example, if the input array is {4, 6, 3, 7}, the output should be 3.  There are three triangles possible {3, 4, 6}, {4, 6, 7} and {3, 6, 7}.  Note that {3, 4, 7} is not a possible triangle.<br/>
As another example, consider the array {10, 21, 22, 100, 101, 200, 300}.  There can be 6 possible triangles: {10, 21, 22}, {21, 100, 101}, {22, 100, 101}, {10, 100, 101}, {100, 101, 200} and {101, 200, 300}<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=358" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Brute force)</strong><br/>
The brute force method is to run three loops and keep track of the number of triangles possible so far.  The three loops select three different values from array, the innermost loop checks for the triangle property ( the sum of any two sides must be greater than the value of third side).</p>
<p>Time Complexity: O(N^3) where N is the size of input array.</p>
<p><strong>Method 2 (Tricky and Efficient)</strong><br/>
Let a, b and c be three sides. The below condition must hold for a triangle (Sum of two sides is greater than the third side)<br/>
i)   a + b &gt; c<br/>
ii)  b + c &gt; a<br/>
iii) a + c &gt; b</p>
<p>Following are steps to count triangle.</p>
<p><strong>1.</strong> Sort the array in non-decreasing order. </p>
<p><strong>2.</strong> Initialize two pointers ‘i’ and ‘j’ to first and second elements respectively, and initialize count of triangles as 0.</p>
<p><strong>3.</strong> Fix ‘i’ and ‘j’ and find the rightmost index ‘k’ (or largest ‘arr[k]’) such that ‘arr[i] + arr[j] &gt; arr[k]’. The number of triangles that can be formed with ‘arr[i]’ and ‘arr[j]’ as two sides is ‘k – j’.  Add ‘k – j’ to count of triangles. </p>
<p>Let us consider ‘arr[i]’ as ‘a’, ‘arr[j]’ as b and all elements between ‘arr[j+1]’ and ‘arr[k]’ as ‘c’.  The above mentioned conditions (ii) and (iii) are satisfied because ‘arr[i] &lt; arr[j] &lt; arr[k]'.  And we check for condition (i) when we pick 'k'

<strong>4.</strong> Increment ‘j’ to fix the second element again. </p>
<p>Note that in step 3, we can use the previous value of ‘k’. The reason is simple, if we know that the value of ‘arr[i] + arr[j-1]’ is greater than ‘arr[k]’, then we can say ‘arr[i] + arr[j]’ will also be greater than ‘arr[k]’, because the array is sorted in increasing order.</p>
<p><strong>5.</strong> If ‘j’ has reached end, then increment ‘i’. Initialize ‘j’ as ‘i + 1′, ‘k’ as ‘i+2′ and repeat the steps 3 and 4.</p>
<p>Following is implementation of the above approach.<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]; title: ; notranslate" title="">

// C/C++ program to count number of triangles that can be 

// formed from given array

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;



/* Following function is needed for library function

   qsort(). Refer

  http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */

int comp(const void* a, const void* b)

{  return *(int*)a &gt; *(int*)b ; }



// Function to count all possible triangles with arr[] 

// elements

int findNumberOfTriangles(int arr[], int n)

{

    // Sort the array elements in non-decreasing order

    qsort(arr, n, sizeof( arr[0] ), comp);



    // Initialize count of triangles

    int count = 0;



    // Fix the first element.  We need to run till n-3

    // as the other two elements are selected from 

    // arr[i+1...n-1]

    for (int i = 0; i &lt; n-2; ++i)

    {

        // Initialize index of the rightmost third 

        // element

        int k = i+2;



        // Fix the second element

        for (int j = i+1; j &lt; n; ++j)

        {

            // Find the rightmost element which is

            // smaller than the sum of two fixed elements

            // The important thing to note here is, we 

            // use the previous  value of k. If value of 

            // arr[i] + arr[j-1] was greater than arr[k],

            // then arr[i] + arr[j] must be greater than k, 

            // because the array is sorted.

            while (k &lt; n &amp;&amp; arr[i] + arr[j] &gt; arr[k])

               ++k;



            // Total number of possible triangles that can 

            // be formed with the two fixed elements is

            //  k - j - 1.  The two fixed elements are arr[i]

            // and arr[j].  All elements between arr[j+1]/ to 

            // arr[k-1] can form a triangle with arr[i] and arr[j].

            // One is subtracted from k because k is incremented 

            // one extra in above while loop.

            // k will always be greater than j. If j becomes equal

            // to k, then above loop will increment k, because arr[k]

            //  + arr[i] is always greater than arr[k]

            count += k - j - 1;

        }

    }



    return count;

}



// Driver program to test above functionarr[j+1]

int main()

{

    int arr[] =   {10, 21, 22, 100, 101, 200, 300};

    int size = sizeof( arr ) / sizeof( arr[0] );



    printf("Total number of triangles possible is %d ",

           findNumberOfTriangles( arr, size ) );



    return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post21"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum circular subarray sum

</button> <div id="post21" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum circular subarray sum</h1>
</header>
<div class="entry-content">
<p>Given n numbers (both +ve and -ve), arranged in a circle, fnd the maximum sum of consecutive number. <span id="more-24106"></span></p>
<p>Examples:
<pre>

Input: a[] = {8, -8, 9, -9, 10, -11, 12}

Output: 22 (12 + 8 - 8 + 9 - 9 + 10)



Input: a[] = {10, -3, -4, 7, 6, 5, -4, -1} 

Output:  23 (7 + 6 + 5 - 4 -1 + 10) 



Input: a[] = {-1, 40, -14, 7, 6, 5, -4, -1}

Output: 52 (7 + 6 + 5 - 4 - 1 - 1 + 40)</pre>
<p>There can be two cases for the maximum sum:</p>
<p><strong>Case 1:</strong> The elements that contribute to the maximum sum are arranged such that no wrapping is there.  Examples: {-10, 2, -1, 5}, {-2, 4, -1, 4, -1}. In this case, <a href="http://www.geeksforgeeks.org/archives/576">Kadane’s algorithm</a> will produce the result.</p>
<p><strong>Case 2:</strong> The elements which contribute to the maximum sum are arranged such that wrapping is there. Examples: {10, -12, 11}, {12, -5, 4, -8, 11}. In this case, we change wrapping to non-wrapping. Let us see how. Wrapping of contributing elements implies non wrapping of non contributing elements, so find out the sum of non contributing elements and subtract this sum from the total sum. To find out the sum of non contributing, invert sign of each element and then run Kadane’s algorithm.<br/>
Our array is like a ring and we have to eliminate the maximum continuous negative that implies maximum continuous positive in the inverted arrays. </p>
<p>Finally we compare the sum obtained by both cases, and return the maximum of the two sums.</p>
<p>Thanks to <a href="http://www.geeksforgeeks.org/forum/profile/ashishdey0 ">ashishdey0</a> for suggesting this solution.  Following are C/C++, Java and Python implementations of the above method.<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

// C/C++ program for maximum contiguous circular sum problem

#include&lt;stdio.h&gt;



// Standard Kadane's algorithm to find maximum subarray

// sum

int kadane(int a[], int n);



// The function returns maximum circular contiguous sum

// in a[]

int maxCircularSum(int a[], int n)

{

   // Case 1: get the maximum sum using standard kadane'

   // s algorithm

   int max_kadane = kadane(a, n);



   // Case 2: Now find the maximum sum that includes

   // corner elements.

   int max_wrap = 0, i;

   for (i=0; i&lt;n; i++)

   {

        max_wrap += a[i]; // Calculate array-sum

        a[i] = -a[i];  // invert the array (change sign)

   }



   // max sum with corner elements will be:

   // array-sum - (-max subarray sum of inverted array)

   max_wrap = max_wrap + kadane(a, n);



   // The maximum circular sum will be maximum of two sums

   return (max_wrap &gt; max_kadane)? max_wrap: max_kadane;

}



// Standard Kadane's algorithm to find maximum subarray sum

// See http://www.geeksforgeeks.org/archives/576 for details

int kadane(int a[], int n)

{

    int max_so_far = 0, max_ending_here = 0;

    int i;

    for (i = 0; i &lt; n; i++)

    {

        max_ending_here = max_ending_here + a[i];

        if (max_ending_here &lt; 0)

            max_ending_here = 0;

        if (max_so_far &lt; max_ending_here)

            max_so_far = max_ending_here;

    }

    return max_so_far;

}



/* Driver program to test maxCircularSum() */

int main()

{

    int a[] =  {11, 10, -20, 5, -3, -5, 8, -13, 10};

    int n = sizeof(a)/sizeof(a[0]);

    printf("Maximum circular sum is %d\n",

                              maxCircularSum(a, n));

    return 0;

}

</pre>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post22"> <span class="glyphicon glyphicon-collapse-down"></span>

Find four elements that sum to a given value | Set 2 ( O(n^2Logn) Solution)

</button> <div id="post22" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find four elements that sum to a given value | Set 2 ( O(n^2Logn) Solution)</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, find all combination of four elements in the array whose sum is equal to a given value X.<span id="more-23338"></span><br/>
For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23, then your function should print “3 5 7 8″ (3 + 5 + 7 + 8 = 23).</p>
<p><strong>Sources:</strong> <a href="http://geeksforgeeks.org/forum/topic/find-specific-sum?replies=17#post-39346">Find Specific Sum</a> and <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-29">Amazon Interview Question</a></p>
<p>We have discussed a O(n^3) algorithm in <a href="http://www.geeksforgeeks.org/archives/23327">the previous post</a> on this topic.  The problem can be solved in O(n^2Logn) time with the help of auxiliary space.  </p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-29#post-39459">itsnimish </a>for suggesting this method. Following is the detailed process.</p>
<p>Let the input array be A[].</p>
<p><strong>1) </strong>Create an auxiliary array aux[] and store sum of all possible pairs in aux[].  The size of aux[] will be n*(n-1)/2 where n is the size of A[].</p>
<p><strong>2) </strong>Sort the auxiliary array aux[].</p>
<p><strong>3) </strong>Now the problem reduces to find two elements in aux[] with sum equal to X. We can use  method 1 of<a href="http://www.geeksforgeeks.org/archives/484"> this post </a>to find the two elements efficiently.  There is following important point to note though. An element of aux[] represents a pair from A[]. While picking two elements from aux[], we must check whether the two elements have an element of A[] in common.  For example, if first element sum of A[1] and A[2], and second element is sum of A[2] and A[4], then these two elements of aux[] don’t represent four distinct elements of input array A[].</p>
<p>Following is C implementation of this method.</p>
<pre class="brush: cpp; highlight: [28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;



// The following structure is needed to store pair sums in aux[]

struct pairSum

{

    int first; // index (int A[]) of first element in pair

    int sec; // index of second element in pair

    int sum;  // sum of the pair

};



// Following function is needed for library function qsort()

int compare (const void *a, const void * b)

{

    return ( (*(pairSum *)a).sum - (*(pairSum*)b).sum );

}



// Function to check if two given pairs have any common element or not

bool noCommon(struct pairSum a, struct pairSum b)

{

    if (a.first == b.first || a.first == b.sec ||

            a.sec == b.first || a.sec == b.sec)

        return false;

    return true;

}





// The function finds four elements with given sum X

void findFourElements (int arr[], int n, int X)

{

    int i, j;



    // Create an auxiliary array to store all pair sums

    int size = (n*(n-1))/2;

    struct pairSum aux[size];



    /* Generate all possible pairs from A[] and store sums

       of all possible pairs in aux[] */

    int k = 0;

    for (i = 0; i &lt; n-1; i++)

    {

        for (j = i+1; j &lt; n; j++)

        {

            aux[k].sum = arr[i] + arr[j];

            aux[k].first = i;

            aux[k].sec = j;

            k++;

        }

    }



    // Sort the aux[] array using library function for sorting

    qsort (aux, size, sizeof(aux[0]), compare);



    // Now start two index variables from two corners of array

    // and move them toward each other.

    i = 0;

    j = size-1;

    while (i &lt; size &amp;&amp; j &gt;=0 )

    {

        if ((aux[i].sum + aux[j].sum == X) &amp;&amp; noCommon(aux[i], aux[j]))

        {

            printf ("%d, %d, %d, %d\n", arr[aux[i].first], arr[aux[i].sec],

                                     arr[aux[j].first], arr[aux[j].sec]);

            return;

        }

        else if (aux[i].sum + aux[j].sum &lt; X)

            i++;

        else

            j--;

    }

}



// Driver program to test above function

int main()

{

    int arr[] = {10, 20, 30, 40, 1, 2};

    int n = sizeof(arr) / sizeof(arr[0]);

    int X = 91;

    findFourElements (arr, n, X);

    return 0;

}

</pre>
<p>Output:
<pre>20, 1, 30, 40</pre>
<p>Please note that the above code prints only one quadruple.  If we remove the return statement and add statements “i++; j–;”, then it prints same quadruple five times.  The code can modified to print all quadruples only once. It has been kept this way to keep it simple. </p>
<p><em>Time complexity: </em>The step 1 takes O(n^2) time.  The second step is sorting an array of size O(n^2). Sorting can be done in O(n^2Logn) time using merge sort or heap sort or any other O(nLogn) algorithm.  The third step takes O(n^2) time. So overall complexity is O(n^2Logn).</p>
<p><em>Auxiliary Space:</em> O(n^2). The big size of auxiliary array can be a concern in this method.</p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post23"> <span class="glyphicon glyphicon-collapse-down"></span>

Find four elements that sum to a given value | Set 1 (n^3 solution)

</button> <div id="post23" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find four elements that sum to a given value | Set 1 (n^3 solution)</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, find all combination of four elements in the array whose sum is equal to a given value X.<span id="more-23327"></span><br/>
For example, if the given array is {10, 2, 3, 4, 5, 9, 7, 8} and X = 23, then your function should print “3 5 7 8″ (3 + 5 + 7 + 8 = 23).</p>
<p><strong>Sources:</strong> <a href="http://geeksforgeeks.org/forum/topic/find-specific-sum?replies=17#post-39346">Find Specific Sum</a> and <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-29">Amazon Interview Question</a></p>
<p>A <strong>Naive Solution </strong> is to generate all possible quadruples and compare the sum of every quadruple with X. The following code implements this simple method using four nested loops</p>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;



/* A naive solution to print all combination of 4 elements in A[]

  with sum equal to X */

void findFourElements(int A[], int n, int X)

{

  // Fix the first element and find other three

  for (int i = 0; i &lt; n-3; i++)

  {

    // Fix the second element and find other two

    for (int j = i+1; j &lt; n-2; j++)

    {

      // Fix the third element and find the fourth

      for (int k = j+1; k &lt; n-1; k++)

      {

        // find the fourth

        for (int l = k+1; l &lt; n; l++)

           if (A[i] + A[j] + A[k] + A[l] == X)

              printf("%d, %d, %d, %d", A[i], A[j], A[k], A[l]);

      }

    }

  }

}



// Driver program to test above funtion

int main()

{

    int A[] = {10, 20, 30, 40, 1, 2};

    int n = sizeof(A) / sizeof(A[0]);

    int X = 91;

    findFourElements (A, n, X);

    return 0;

}

</pre>
<p>Output:
<pre>20, 30, 40, 1</pre>
<p>Time Complexity: O(n^4)</p>
<p><em>The time complexity can be improved to O(n^3) with the <strong>use of sorting</strong> as a preprocessing step, and then using method 1 of <a href="http://www.geeksforgeeks.org/archives/484">this </a> post to reduce a loop.</em></p>
<p>Following are the detailed steps.<br/>
1) Sort the input array.<br/>
2) Fix the first element as A[i] where i is from 0 to n–3. After fixing the first element of quadruple, fix the second element as A[j] where j varies from i+1 to n-2.  Find remaining two elements in O(n) time, using the method 1 of <a href="http://www.geeksforgeeks.org/archives/484">this </a> post </p>
<p>Following is C implementation of O(n^3) solution.</p>
<pre class="brush: cpp; highlight: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate" title="">

# include &lt;stdio.h&gt;

# include &lt;stdlib.h&gt;



/* Following function is needed for library function qsort(). Refer

   http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */

int compare (const void *a, const void * b)

{  return ( *(int *)a - *(int *)b ); }



/* A sorting based solution to print all combination of 4 elements in A[]

   with sum equal to X */

void find4Numbers(int A[], int n, int X)

{

    int l, r;



    // Sort the array in increasing order, using library

    // function for quick sort

    qsort (A, n, sizeof(A[0]), compare);



    /* Now fix the first 2 elements one by one and find

       the other two elements */

    for (int i = 0; i &lt; n - 3; i++)

    {

        for (int j = i+1; j &lt; n - 2; j++)

        {

            // Initialize two variables as indexes of the first and last 

            // elements in the remaining elements

            l = j + 1;

            r = n-1;



            // To find the remaining two elements, move the index 

            // variables (l &amp; r) toward each other.

            while (l &lt; r)

            {

                if( A[i] + A[j] + A[l] + A[r] == X)

                {

                   printf("%d, %d, %d, %d", A[i], A[j],

                                           A[l], A[r]);

                   l++; r--;

                }

                else if (A[i] + A[j] + A[l] + A[r] &lt; X)

                    l++;

                else // A[i] + A[j] + A[l] + A[r] &gt; X

                    r--;

            } // end of while

        } // end of inner for loop

    } // end of outer for loop

}



/* Driver program to test above function */

int main()

{

    int A[] = {1, 4, 45, 6, 10, 12};

    int X = 21;

    int n = sizeof(A)/sizeof(A[0]);

    find4Numbers(A, n, X);

    return 0;

}

</pre>
<p>Output:
<pre>1, 4, 6, 10</pre>
<p>Time Complexity: O(n^3)</p>
<p>This problem can also be solved in O(n^2Logn) complexity.  We will soon be publishing the O(n^2Logn) solution as a separate post. </p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post24"> <span class="glyphicon glyphicon-collapse-down"></span>

Replace every element with the greatest element on right side

</button> <div id="post24" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Replace every element with the greatest element on right side</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, replace every element with the next greatest element (greatest element on the right side) in the array. <span id="more-23200"></span> Since there is no element next to the last element, replace it with -1. For example, if the array is {16, 17, 4, 3, 5, 2}, then it should be modified to {17, 5, 5, 5, 2, -1}.<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=522" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
The question is very similar to <a href="http://www.geeksforgeeks.org/archives/3511">this post</a> and solutions are also similar.  </p>
<p>A <strong>naive method</strong> is to run two loops.  The outer loop will one by one pick array elements from left to right.  The inner loop will find the greatest element present after the picked element. Finally the outer loop will replace the picked element with the greatest element found by inner loop.  The time complexity of this method will be O(n*n).<br/>
A <strong>tricky method</strong> is to replace all elements using one traversal of the array. The idea is to start from the rightmost element, move to the left side one by one, and keep track of the maximum element.  Replace every element with the maximum element.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]; title: ; notranslate" title="">

// C Program to replace every element with the greatest

// element on right side

#include &lt;stdio.h&gt;



/* Function to replace every element with the

   next greatest element */

void nextGreatest(int arr[], int size)

{

  // Initialize the next greatest element 

  int max_from_right =  arr[size-1];



  // The next greatest element for the rightmost element

  // is always -1

  arr[size-1] = -1;



  // Replace all other elements with the next greatest

  for(int i = size-2; i &gt;= 0; i--)

  {

    // Store the current element (needed later for updating

    // the next greatest element)

    int temp = arr[i];



    // Replace current element with the next greatest

    arr[i] = max_from_right;



    // Update the greatest element, if needed

    if(max_from_right &lt; temp)

       max_from_right = temp;

  }

}



/* A utility Function that prints an array */

void printArray(int arr[], int size)

{

  int i;

  for (i=0; i &lt; size; i++)

    printf("%d ", arr[i]);

  printf("\n");

}



/* Driver program to test above function */

int main()

{

  int arr[] = {16, 17, 4, 3, 5, 2};

  int size = sizeof(arr)/sizeof(arr[0]);

  nextGreatest (arr, size);

  printf ("The modified array is: \n");

  printArray (arr, size);

  return (0);

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]; title: ; notranslate" title="">

// Java Program to replace every element with the 

// greatest element on right side

import java.io.*;



class NextGreatest 

{

    /* Function to replace every element with the

       next greatest element */

    static void nextGreatest(int arr[])

    {

        int size = arr.length;



        // Initialize the next greatest element

        int max_from_right =  arr[size-1];



        // The next greatest element for the rightmost

        // element is always -1

        arr[size-1] = -1;



        // Replace all other elements with the next greatest

        for (int i = size-2; i &gt;= 0; i--)

        {

            // Store the current element (needed later for

            // updating the next greatest element)

            int temp = arr[i];



            // Replace current element with the next greatest

            arr[i] = max_from_right;



            // Update the greatest element, if needed

            if(max_from_right &lt; temp)

            max_from_right = temp;

        }

    }



    /* A utility Function that prints an array */

    static void printArray(int arr[])

    {

        for (int i=0; i &lt; arr.length; i++)

        System.out.print(arr[i]+" ");

    }



	public static void main (String[] args)

	{

		int arr[] = {16, 17, 4, 3, 5, 2};

        nextGreatest (arr);

        System.out.println("The modified array:");

        printArray (arr);

	}

}

/*This code is contributed by Devesh Agrawal*/

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]; title: ; notranslate" title="">

# Python Program to replace every element with the 

# greatest element on right side



# Function to replace every element with the next greatest

# element

def nextGreatest(arr):



    size = len(arr)



    # Initialize the next greatest element

    max_from_right = arr[size-1]



    # The next greatest element for the rightmost element

    # is always -1

    arr[size-1] = -1



    # Replace all other elements with the next greatest

    for i in range(size-2,-1,-1):



        # Store the current element (needed later for updating

        # the next greatest element)

        temp = arr[i]



        # Replace current element with the next greatest

        arr[i]=max_from_right



        # Update the greatest element, if needed

        if max_from_right&lt; temp:

            max_from_right=temp



# Utility function to print an array

def printArray(arr):

    for i in range(0,len(arr)):

        print arr[i],



# Driver function to test above function

arr = [16, 17, 4, 3, 5, 2]

nextGreatest(arr)

print "Modified array is"

printArray(arr)

# This code is contributed by Devesh Agrawal

</pre>
<p></p></div></div><br/>
Output:
<pre>The modified array is:

17 5 5 5 2 -1</pre>
<p>Time Complexity: O(n) where n is the number of elements in array.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/bLb8e83OK7o?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post25"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum Product Subarray

</button> <div id="post25" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum Product Subarray</h1>
</header>
<div class="entry-content">
<p>Given an array that contains both positive and negative integers, find the product of the maximum product subarray. Expected Time complexity is O(n) and only O(1) extra space can be used.<span id="more-22216"></span></p>
<p><strong>Examples:</strong>
<pre>

Input: arr[] = {6, -3, -10, 0, 2}

Output:   180  // The subarray is {6, -3, -10}



Input: arr[] = {-1, -3, -10, 0, 60}

Output:   60  // The subarray is {60}



Input: arr[] = {-2, -3, 0, -2, -40}

Output:   80  // The subarray is {-2, -40}

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=433" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
The following solution assumes that the given input array always has a positive ouput.  The solution works for all cases mentioned above.  It doesn’t work for arrays like {0, 0, -20, 0}, {0, 0, 0}.. etc.  The solution can be easily modified to handle this case.<br/>
It is similar to <a href="http://www.geeksforgeeks.org/archives/576">Largest Sum Contiguous Subarray</a> problem.  The only thing to note here is, maximum product can also be obtained by minimum (negative) product ending with the previous element multiplied by this element.  For example, in array {12, 2, -3, -5, -6, -2}, when we are at element -2, the maximum product is multiplication of, minimum product ending with -6 and -2.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]; title: ; notranslate" title="">

// C program to find Maximum Product Subarray

#include &lt;stdio.h&gt;



// Utility functions to get minimum of two integers

int min (int x, int y) {return x &lt; y? x : y; }



// Utility functions to get maximum of two integers

int max (int x, int y) {return x &gt; y? x : y; }



/* Returns the product of max product subarray. 

   Assumes that the given array always has a subarray

   with product more than 1 */

int maxSubarrayProduct(int arr[], int n)

{

    // max positive product ending at the current position

    int max_ending_here = 1;



    // min negative product ending at the current position

    int min_ending_here = 1;



    // Initialize overall max product

    int max_so_far = 1;



    /* Traverse through the array. Following values are

       maintained after the i'th iteration:

       max_ending_here is always 1 or some positive product

                       ending with arr[i]

       min_ending_here is always 1 or some negative product 

                       ending with arr[i] */

    for (int i = 0; i &lt; n; i++)

    {

        /* If this element is positive, update max_ending_here. 

           Update min_ending_here only if min_ending_here is 

           negative */

        if (arr[i] &gt; 0)

        {

            max_ending_here = max_ending_here*arr[i];

            min_ending_here = min (min_ending_here * arr[i], 1);

        }



        /* If this element is 0, then the maximum product 

           cannot end here, make both max_ending_here and 

           min_ending_here 0

           Assumption: Output is alway greater than or equal 

                       to 1. */

        else if (arr[i] == 0)

        {

            max_ending_here = 1;

            min_ending_here = 1;

        }



        /* If element is negative. This is tricky

           max_ending_here can either be 1 or positive. 

           min_ending_here can either be 1 or negative.

           next min_ending_here will always be prev. 

           max_ending_here * arr[i] next max_ending_here

           will be 1 if prev min_ending_here is 1, otherwise 

           next max_ending_here will be prev min_ending_here *

           arr[i] */

        else

        {

            int temp = max_ending_here;

            max_ending_here = max (min_ending_here * arr[i], 1);

            min_ending_here = temp * arr[i];

        }



        // update max_so_far, if needed

        if (max_so_far &lt;  max_ending_here)

          max_so_far  =  max_ending_here;

    }



    return max_so_far;

}



// Driver Program to test above function

int main()

{

    int arr[] = {1, -2, -3, 0, 7, -8, -2};

    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Maximum Sub array product is %d", 

            maxSubarrayProduct(arr, n));

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76]; title: ; notranslate" title="">

// Java program to find maximum product subarray

import java.io.*;



class ProductSubarray {



    // Utility functions to get minimum of two integers

    static int min (int x, int y) {return x &lt; y? x : y; }



    // Utility functions to get maximum of two integers

    static int max (int x, int y) {return x &gt; y? x : y; }



    /* Returns the product of max product subarray.

       Assumes that the given array always has a subarray

       with product more than 1 */

    static int maxSubarrayProduct(int arr[])

    {

        int n = arr.length;

        // max positive product ending at the current position

        int max_ending_here = 1;



        // min negative product ending at the current position

        int min_ending_here = 1;



        // Initialize overall max product

        int max_so_far = 1;



        /* Traverse through the array. Following

           values are maintained after the ith iteration:

           max_ending_here is always 1 or some positive product

                           ending with arr[i]

           min_ending_here is always 1 or some negative product

                           ending with arr[i] */

        for (int i = 0; i &lt; n; i++)

        {

            /* If this element is positive, update max_ending_here.

                Update min_ending_here only if min_ending_here is

                negative */

            if (arr[i] &gt; 0)

            {

                max_ending_here = max_ending_here*arr[i];

                min_ending_here = min (min_ending_here * arr[i], 1);

            }



            /* If this element is 0, then the maximum product cannot

               end here, make both max_ending_here and min_ending

              _here 0

               Assumption: Output is alway greater than or equal to 1. */

            else if (arr[i] == 0)

            {

                max_ending_here = 1;

                min_ending_here = 1;

            }



            /* If element is negative. This is tricky

               max_ending_here can either be 1 or positive.

               min_ending_here can either be 1 or negative.

               next min_ending_here will always be prev.

               max_ending_here * arr[i]

               next max_ending_here will be 1 if prev

               min_ending_here is 1, otherwise

               next max_ending_here will be 

                           prev min_ending_here * arr[i] */

            else

            {

                int temp = max_ending_here;

                max_ending_here = max (min_ending_here * arr[i], 1);

                min_ending_here = temp * arr[i];

            }



            // update max_so_far, if needed

            if (max_so_far &lt;  max_ending_here)

                max_so_far  =  max_ending_here;

        }



        return max_so_far;

    }



	public static void main (String[] args) {



		int arr[] = {1, -2, -3, 0, 7, -8, -2};

        System.out.println("Maximum Sub array product is "+

                            maxSubarrayProduct(arr));

	}

}/*This code is contributed by Devesh Agrawal*/

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate" title="">

# Python program to find maximum product subarray



# Returns the product of max product subarray.

# Assumes that the given array always has a subarray

# with product more than 1

def maxsubarrayproduct(arr):



    n = len(arr)



    # max positive product ending at the current position

    max_ending_here = 1



    # min positive product ending at the current position

    min_ending_here = 1



    # Initialize maximum so far

    max_so_far = 1



    # Traverse throughout the array. Following values

    # are maintained after the ith iteration:

    # max_ending_here is always 1 or some positive product

    # ending with arr[i]

    # min_ending_here is always 1 or some negative product

    # ending with arr[i]

    for i in range(0,n):



        # If this element is positive, update max_ending_here.

        # Update min_ending_here only if min_ending_here is

        # negative

        if arr[i] &gt; 0:

            max_ending_here = max_ending_here*arr[i]

            min_ending_here = min (min_ending_here * arr[i], 1)



        # If this element is 0, then the maximum product cannot

        # end here, make both max_ending_here and min_ending_here 0

        # Assumption: Output is alway greater than or equal to 1.

        elif arr[i] == 0:

            max_ending_here = 1

            min_ending_here = 1



        # If element is negative. This is tricky

        # max_ending_here can either be 1 or positive.

        # min_ending_here can either be 1 or negative.

        # next min_ending_here will always be prev.

        # max_ending_here * arr[i]

        # next max_ending_here will be 1 if prev

        # min_ending_here is 1, otherwise

        # next max_ending_here will be prev min_ending_here * arr[i]

        else:

            temp = max_ending_here

            max_ending_here = max (min_ending_here * arr[i], 1)

            min_ending_here = temp * arr[i]

        if (max_so_far &lt;  max_ending_here):

            max_so_far  =  max_ending_here

    return max_so_far



# Driver function to test above function

arr = [1, -2, -3, 0, 7, -8, -2]

print "Maximum product subarray is",maxsubarrayproduct(arr)



# This code is contributed by Devesh Agrawal

</pre>
</div></div>
<p>Output:
<pre>Maximum Sub array product is 112</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>This article is compiled by <strong>Dheeraj Jain </strong>and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post26"> <span class="glyphicon glyphicon-collapse-down"></span>

Largest subarray with equal number of 0s and 1s

</button> <div id="post26" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Largest subarray with equal number of 0s and 1s</h1>
</header>
<div class="entry-content">
<p>Given an array containing only 0s and 1s, find the largest subarray which contain equal no of 0s and 1s. Expected time complexity is O(n). <span id="more-20586"></span></p>
<p>Examples:</p>
<pre>

Input: arr[] = {1, 0, 1, 1, 1, 0, 0}

Output: 1 to 6 (Starting and Ending indexes of output subarray)



Input: arr[] = {1, 1, 1, 1}

Output: No such subarray



Input: arr[] = {0, 0, 1, 1, 0}

Output: 0 to 3 Or 1 to 4

</pre>
<p>Source:<a href="http://geeksforgeeks.org/forum/topic/array-13#post-38000"> Largest subarray with equal number of 0s and 1s</a></p>
<p><strong>Method 1 (Simple)</strong><br/>
A simple method is to use two nested loops. The outer loop picks a starting point i. The inner loop considers all subarrays starting from i. If size of a subarray is greater than maximum size so far, then update the maximum size.<br/>
In the below code, 0s are considered as -1 and sum of all values from i to j is calculated. If sum becomes 0, then size of this subarray is compared with largest size so far. </p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]; title: ; notranslate" title="">

// A simple program to find the largest subarray with equal number of 0s and 1s

#include &lt;stdio.h&gt;



// This function Prints the starting and ending indexes of the largest subarray 

// with equal number of 0s and 1s. Also returns the size of such subarray.

int findSubArray(int arr[], int n)

{

    int sum = 0;

    int maxsize = -1, startindex;



    // Pick a starting point as i

    for (int i = 0; i &lt; n-1; i++)

    {

        sum = (arr[i] == 0)? -1 : 1;



        // Consider all subarrays starting from i

        for (int j = i+1; j &lt; n; j++)

        {

            (arr[j] == 0)? sum += -1: sum += 1;



            // If this is a 0 sum subarray, then compare it with

            // maximum size subarray calculated so far

            if(sum == 0 &amp;&amp; maxsize &lt; j-i+1)

            {

                maxsize = j - i + 1;

                startindex = i;

            }

        }

    }

    if ( maxsize == -1 )

        printf("No such subarray");

    else

        printf("%d to %d", startindex, startindex+maxsize-1);



    return maxsize;

}



/* Driver program to test above functions*/

int main()

{

    int arr[] =  {1, 0, 0, 1, 0, 1, 1};

    int size = sizeof(arr)/sizeof(arr[0]);



    findSubArray(arr, size);

    return 0;

}

</pre>
<p>Output:
<pre> 0 to 5

</pre>
<p>Time Complexity: O(n^2)<br/>
Auxiliary Space: O(1)</p>
<p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post27"> <span class="glyphicon glyphicon-collapse-down"></span>

Find a sorted subsequence of size 3 in linear time

</button> <div id="post27" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find a sorted subsequence of size 3 in linear time</h1>
</header>
<div class="entry-content">
<p>Given an array of n integers, find the 3 elements such that a[i] &lt; a[j] &lt; a[k] and i &lt; j &lt; k in 0(n) time.  If there are multiple such triplets, then print any one of them.<span id="more-19879"></span></p>
<p>Examples:</p>
<pre>

Input:  arr[] = {12, 11, 10, 5, 6, 2, 30}

Output: 5, 6, 30



Input:  arr[] = {1, 2, 3, 4}

Output: 1, 2, 3 OR 1, 2, 4 OR 2, 3, 4



Input:  arr[] = {4, 3, 2, 1}

Output: No such triplet

</pre>
<p>Source:<a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-0-2-years-about-algorithms-20"> Amazon Interview Question</a></p>
<p>Hint: Use Auxiliary Space</p>
<p><strong>Solution:</strong><br/>
1) Create an auxiliary array smaller[0..n-1]. smaller[i] should store the index of a number which is smaller than arr[i] and is on left side of arr[i]. smaller[i] should contain -1 if there is no such element.<br/>
2) Create another auxiliary array greater[0..n-1]. greater[i] should store the index of a number which is greater than arr[i] and is on right side of arr[i]. greater[i] should contain -1 if there is no such element.<br/>
3) Finally traverse both smaller[] and greater[] and find the index i for which both smaller[i] and greater[i] are not -1.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]; title: ; notranslate" title="">

// C/C++ program to find a sorted subsequence of size 3

#include&lt;stdio.h&gt;



// A function to fund a sorted subsequence of size 3

void find3Numbers(int arr[], int n)

{

   int max = n-1; //Index of maximum element from right side

   int min = 0; //Index of minimum element from left side

   int i;



   // Create an array that will store index of a smaller

   // element on left side. If there is no smaller element

   // on left side, then smaller[i] will be -1.

   int *smaller = new int[n];

   smaller[0] = -1;  // first entry will always be -1

   for (i = 1; i &lt; n; i++)

   {

       if (arr[i] &lt;= arr[min])

       {

          min = i;

          smaller[i] = -1;

       }

       else

          smaller[i] = min;

   }



   // Create another array that will store index of a

   // greater element on right side. If there is no greater

   // element on right side, then greater[i] will be -1.

   int *greater = new int[n];

   greater[n-1] = -1;  // last entry will always be -1

   for (i = n-2; i &gt;= 0; i--)

   {

       if (arr[i] &gt;= arr[max])

       {

          max = i;

          greater[i] = -1;

       }

       else

          greater[i] = max;

   }



   // Now find a number which has both a greater number on

   // right side and smaller number on left side

   for (i = 0; i &lt; n; i++)

   {

       if (smaller[i] != -1 &amp;&amp; greater[i] != -1)

       {

          printf("%d %d %d", arr[smaller[i]],

                 arr[i], arr[greater[i]]);

          return;

       }

   }



   // If we reach number, then there are no such 3 numbers

   printf("No such triplet found");



   // Free the dynamically alloced memory to avoid memory leak

   delete [] smaller;

   delete [] greater;



   return;

}



// Driver program to test above function

int main()

{

    int arr[] = {12, 11, 10, 5, 6, 2, 30};

    int n = sizeof(arr)/sizeof(arr[0]);

    find3Numbers(arr, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate" title="">

// Java program to find a sorted subsequence of size 3

import java.io.*;



class SortedSubsequence

{

    // A function to find a sorted subsequence of size 3

    static void find3Numbers(int arr[])

    {

        int n = arr.length;

        int max = n-1; //Index of maximum element from right side

        int min = 0; //Index of minimum element from left side

        int i;



        // Create an array that will store index of a smaller

        // element on left side. If there is no smaller element

        // on left side, then smaller[i] will be -1.

        int[] smaller = new int[n];

        smaller[0] = -1;  // first entry will always be -1

        for (i = 1; i &lt; n; i++)

        {

            if (arr[i] &lt;= arr[min])

            {

                min = i;

                smaller[i] = -1;

            }

            else

                smaller[i] = min;

        }



        // Create another array that will store index of a

        // greater element on right side. If there is no greater

        // element on right side, then greater[i] will be -1.

        int[] greater = new int[n];

        greater[n-1] = -1;  // last entry will always be -1

        for (i = n-2; i &gt;= 0; i--)

        {

            if (arr[i] &gt;= arr[max])

            {

                max = i;

                greater[i] = -1;

            }

            else

                greater[i] = max;

        }



        // Now find a number which has both a greater number

        // on right side and smaller number on left side

        for (i = 0; i &lt; n; i++)

        {

            if (smaller[i] != -1 &amp;&amp; greater[i] != -1)

            {

                System.out.print(arr[smaller[i]]+" "+

                                 arr[i]+" "+ arr[greater[i]]);

                return;

            }

        }



        // If we reach number, then there are no such 3 numbers

        System.out.println("No such triplet found");

        return;

    }



    public static void main (String[] args)

    {

        int arr[] = {12, 11, 10, 5, 6, 2, 30};

        find3Numbers(arr);

    }

}

/* This code is contributed by Devesh Agrawal*/

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate" title="">

# Pythion program to fund a sorted subsequence of size 3



def find3numbers(arr):

    n = len(arr)

    max = n-1 # Index of maximum element from right side

    min = 0 # Index of minimum element from left side



    # Create an array that will store index of a smaller

    # element on left side. If there is no smaller element

    # on left side, then smaller[i] will be -1.

    smaller = [0]*10000

    smaller[0] = -1

    for i in range(1,n):

        if (arr[i] &lt;= arr[min]):

            min = i

            smaller[i] = -1

        else:

            smaller[i] = min



    # Create another array that will store index of a

    # greater element on right side. If there is no greater

    # element on right side, then greater[i] will be -1.

    greater = [0]*10000

    greater[n-1] = -1



    for i in range(n-2,-1,-1):

        if (arr[i] &gt;= arr[max]):

            max = i

            greater[i] = -1



        else:

            greater[i] = max



    # Now find a number which has both a greater number on

    # right side and smaller number on left side

    for i in range(0,n):

        if smaller[i] != -1 and greater[i] != -1:

            print arr[smaller[i]], arr[i], arr[greater[i]]

            return



    # If we reach here, then there are no such 3 numbers

    print "No triplet found"

    return





# Driver function to test above function

arr = [12, 11, 10, 5, 6, 2, 30]

find3numbers(arr)



# This code is contributed by Devesh Agrawal

</pre>
</div></div>
<p>Output:
<pre>

5 6 30 </pre>
<p>Time Complexity: O(n)<br/>
Auxliary Space: O(n)</p>
<p>Source: <a href="http://stackoverflow.com/questions/10008118/how-to-find-3-numbers-in-increasing-order-and-increasing-indices-in-an-array-in">How to find 3 numbers in increasing order and increasing indices in an array in linear time</a></p>
<p><strong>Exercise:</strong><br/>
<strong>1.</strong> Find a subsequence of size 3 such that arr[i] &lt; arr[j] &gt; arr[k].<br/>
<strong>2. </strong> Find a sorted subsequence of size 4 in linear time </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post28"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the two numbers with odd occurrences in an unsorted array

</button> <div id="post28" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the two numbers with odd occurrences in an unsorted array</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array that contains even number of occurrences for all numbers except two numbers. Find the two numbers which have odd occurrences in O(n) time complexity and O(1) extra space.<span id="more-19378"></span></p>
<p>Examples:</p>
<pre>

Input: {12, 23, 34, 12, 12, 23, 12, 45}

Output: 34 and 45



Input: {4, 4, 100, 5000, 4, 4, 4, 4, 100, 100}

Output: 100 and 5000



Input: {10, 20}

Output: 10 and 20

</pre>
<p>A <strong>naive method </strong>to solve this problem is to run two nested loops. The outer loop picks an element and the inner loop counts the number of occurrences of the picked element. If the count of occurrences is odd then print the number. The time complexity of this method is O(n^2).</p>
<p>We can <strong>use sorting</strong> to get the odd occurring numbers in O(nLogn) time. First sort the numbers using an O(nLogn) sorting algorithm like Merge Sort, Heap Sort.. etc. Once the array is sorted, all we need to do is a linear scan of the array and print the odd occurring number. </p>
<p>We can also <strong>use hashing</strong>. Create an empty hash table which will have elements and their counts. Pick all elements of input array one by one. Look for the picked element in hash table. If the element is found in hash table, increment its count in table. If the element is not found, then enter it in hash table with count as 1. After all elements are entered in hash table, scan the hash table and print elements with odd count. This approach may take O(n) time on average, but it requires O(n) extra space.</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post29"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the smallest positive number missing from an unsorted array

</button> <div id="post29" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the smallest positive number missing from an unsorted array</h1>
</header>
<div class="entry-content">
<p>You are given an unsorted array with both positive and negative elements. You have to find the smallest positive number missing from the array in O(n) time using constant extra space. You can modify the original array. <span id="more-19419"></span></p>
<p>Examples</p>
<pre>

 Input:  {2, 3, 7, 6, 8, -1, -10, 15}

 Output: 1



 Input:  { 2, 3, -7, 6, 8, 1, -10, 15 }

 Output: 4



 Input: {1, 1, 0, -1, -2}

 Output: 2 

</pre>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/to-find-the-smalest-positive-no-missing-from-an-unsorted-array">To find the smallest positive no missing from an unsorted array</a></p>
<p>A <strong>naive method</strong> to solve this problem is to search all positive integers, starting from 1 in the given array. We may have to search at most n+1 numbers in the given array. So this solution takes O(n^2) in worst case.</p>
<p>We can <strong>use sorting</strong> to solve it in lesser time complexity. We can sort the array in O(nLogn) time. Once the array is sorted, then all we need to do is a linear scan of the array. So this approach takes O(nLogn + n) time which is O(nLogn).</p>
<p>We can also <strong>use hashing</strong>. We can build a hash table of all positive elements in the given array. Once the hash table is built. We can look in the hash table for all positive integers, starting from 1. As soon as we find a number which is not there in hash table, we return it. This approach may take O(n) time on average, but it requires O(n) extra space.</p>
<p><strong>A O(n) time and O(1) extra space solution:</strong><br/>
The idea is similar to <a href="http://www.geeksforgeeks.org/archives/9755">this </a> post.  We use array elements as index. <u>To mark presence of an element x, we change the value at the index x to negative</u>. But this approach doesn’t work if there are non-positive (-ve and 0) numbers. So we segregate positive from negative numbers as first step and then apply the approach.</p>
<p>Following is the two step algorithm.<br/>
1) Segregate positive numbers from others i.e., move all non-positive numbers to left side. In the following code, segregate() function does this part.<br/>
2) Now we can ignore non-positive elements and consider only the part of array which contains all positive elements. We traverse the array containing all positive numbers and to mark presence of an element x, we change the sign of value at index x to negative. We traverse the array again and <u>print the first index which has positive value</u>.  In the following code, findMissingPositive() function does this part. Note that in findMissingPositive, we have subtracted 1 from the values as indexes start from 0 in C.</p>
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]; title: ; notranslate" title="">

/* Program to find the smallest positive missing number */

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;



/* Utility to swap to integers */

void swap(int *a, int *b)

{

    int temp;

    temp = *a;

    *a   = *b;

    *b   = temp;

}



/* Utility function that puts all non-positive (0 and negative) numbers on left 

  side of arr[] and return count of such numbers */

int segregate (int arr[], int size)

{

    int j = 0, i;

    for(i = 0; i &lt; size; i++)

    {

       if (arr[i] &lt;= 0)  

       {

           swap(&amp;arr[i], &amp;arr[j]);

           j++;  // increment count of non-positive integers

       }

    }



    return j;

}



/* Find the smallest positive missing number in an array that contains

  all positive integers */

int findMissingPositive(int arr[], int size)

{

  int i;



  // Mark arr[i] as visited by making arr[arr[i] - 1] negative. Note that 

  // 1 is subtracted because index start from 0 and positive numbers start from 1

  for(i = 0; i &lt; size; i++)

  {

    if(abs(arr[i]) - 1 &lt; size &amp;&amp; arr[abs(arr[i]) - 1] &gt; 0)

      arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1];

  }



  // Return the first index value at which is positive

  for(i = 0; i &lt; size; i++)

    if (arr[i] &gt; 0)

      return i+1;  // 1 is added becuase indexes start from 0



  return size+1;

}



/* Find the smallest positive missing number in an array that contains

  both positive and negative integers */

int findMissing(int arr[], int size)

{

   // First separate positive and negative numbers

   int shift = segregate (arr, size);



   // Shift the array and call findMissingPositive for

   // positive part

   return findMissingPositive(arr+shift, size-shift);

}



int main()

{

  int arr[] = {0, 10, 2, -10, -20};

  int arr_size = sizeof(arr)/sizeof(arr[0]);

  int missing = findMissing(arr, arr_size);

  printf("The smallest positive missing number is %d ", missing);

  getchar();

  return 0;

}

</pre>
<p>Output:
<pre>

The smallest positive missing number is 1 </pre>
<p>Note that this method modifies the original array. We can change the sign of elements in the segregated array to get the same set of elements back. But we still loose the order of elements. If we want to keep the original array as it was, then we can create a copy of the array and run this approach on the temp array.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post30"> <span class="glyphicon glyphicon-collapse-down"></span>

Find a triplet that sum to a given value

</button> <div id="post30" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find a triplet that sum to a given value</h1>
</header>
<div class="entry-content">
<p>Given an array and a value, find if there is a triplet in array whose sum is equal to the given value. If there is such a triplet present in array, then print the triplet and return true.<span id="more-19364"></span> Else return false.  For example, if the given array is {12, 3, 4, 1, 6, 9} and given sum is 24, then there is a triplet (12, 3 and 9) present in array whose sum is 24. </p>
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=732">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<p><strong>Method 1 (Naive) </strong><br/>
A simple method is to generate all possible triplets and compare the sum of every triplet with the given value. The following code implements this simple method using three nested loops.</p>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]; title: ; notranslate" title="">

# include &lt;stdio.h&gt;



// returns true if there is triplet with sum equal

// to 'sum' present in A[]. Also, prints the triplet

bool find3Numbers(int A[], int arr_size, int sum)

{

    int l, r;



    // Fix the first element as A[i]

    for (int i = 0; i &lt; arr_size-2; i++)

    {

       // Fix the second element as A[j]

       for (int j = i+1; j &lt; arr_size-1; j++)

       {

           // Now look for the third number

           for (int k = j+1; k &lt; arr_size; k++)

           {

               if (A[i] + A[j] + A[k] == sum)

               {

                 printf("Triplet is %d, %d, %d", A[i], A[j], A[k]);

                 return true;

               }

           }

       }

    }



    // If we reach here, then no triplet was found

    return false;

}



/* Driver program to test above function */

int main()

{

    int A[] = {1, 4, 45, 6, 10, 8};

    int sum = 22;

    int arr_size = sizeof(A)/sizeof(A[0]);



    find3Numbers(A, arr_size, sum);



    getchar();

    return 0;

}

</pre>
<p>Output:
<pre>

Triplet is 4, 10, 8

</pre>
<p>Time Complexity: O(n^3)</p>
<p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post31"> <span class="glyphicon glyphicon-collapse-down"></span>

Longest Increasing Subsequence Size (N log N)

</button> <div id="post31" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Longest Increasing Subsequence Size (N log N)</h1>
</header>
<div class="entry-content">
<p>After few months of gap posting an algo. The current post is pending from long time, and many readers (e.g. <a href="http://geeksforgeeks.org/forum/topic/microsoft-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-4" target="_blank">here</a>, <a href="http://geeksforgeeks.org/forum/topic/finding-the-longest-increasing-sub-sequence-in-an-array" target="_blank">here</a>, <a href="http://geeksforgeeks.org/forum/topic/longest-increasing-subsequence-onlogn" target="_blank">here</a> may be few more, I am not keeping track of all) are posting requests for explanation of the below problem.<span id="more-9591"></span></p>
<p><strong>Given an array of random numbers. Find <em>longest increasing <a href="http://en.wikipedia.org/wiki/Substring" target="_blank">subsequence</a></em> (LIS) in the array. I know many of you might have read <a href="http://www.geeksforgeeks.org/archives/12832" target="_blank">recursive and dynamic programming</a> (DP) solutions. There are few requests for <a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms" target="_blank">O(N log N)</a> algo in the forum posts.</strong></p>
<p>For the time being, forget about recursive and DP solutions. Let us take small samples and extend the solution to large instances. Even though it may look complex at first time, once if we understood the logic, coding is simple.</p>
<p>Consider an input array A = {2, 5, 3}. I will extend the array during explanation.</p>
<p>By observation we know that the LIS is either {2, 3} or {2, 5}. <em><strong>Note that I am considering only strictly increasing sequences</strong></em>.</p>
<p>Let us add two more elements, say 7, 11 to the array. These elements will extend the existing sequences. Now the increasing sequences are {2, 3, 7, 11} and {2, 5, 7, 11} for the input array {2, 5, 3, 7, 11}.</p>
<p>Further, we add one more element, say 8 to the array i.e. input array becomes {2, 5, 3, 7, 11, 8}. Note that the latest element 8 is greater than smallest element of any active sequence (<em>will discuss shortly about active sequences</em>). How can we extend the existing sequences with 8? First of all, can 8 be part of LIS? If yes, how? If we want to add 8, it should come after 7 (by replacing 11).</p>
<p>Since the approach is <em>offline (what we mean by <a href="http://www.geeksforgeeks.org/archives/14873" target="_blank">offline</a>?)</em>, we are not sure whether adding 8 will extend the series or not. Assume there is 9 in the input array, say {2, 5, 3, 7, 11, 8, 7, 9 …}. We can replace 11 with 8, as there is potentially <em>best</em> candidate (9) that can extend the new series {2, 3, 7, 8} or {2, 5, 7, 8}.</p>
<p>Our observation is, assume that the end element of largest sequence is E. We can add (replace) current element A[i] to the existing sequence if there is an element A[j] (j &gt; i) such that E &lt; A[i] &lt; A[j] or (E &gt; A[i] &lt; A[j] – for replace). In the above example, E = 11, A[i] = 8 and A[j] = 9.</p>
<p>In case of our original array {2, 5, 3}, note that we face same situation when we are adding 3 to increasing sequence {2, 5}. I just created two increasing sequences to make explanation simple. Instead of two sequences, 3 can replace 5 in the sequence {2, 5}.</p>
<p>I know it will be confusing, I will clear it shortly!</p>
<p><em>The question is, when will it be safe to add or replace an element in the existing sequence?</em></p>
<p>Let us consider another sample A = {2, 5, 3}. Say, the next element is 1. How can it extend the current sequences {2,3} or {2, 5}. Obviously, it can’t extend either. Yet, there is a potential that the new smallest element can be start of an LIS. To make it clear, consider the array is {2, 5, 3, 1, 2, 3, 4, 5, 6}. Making 1 as new sequence will create new sequence which is largest.</p>
<p><em>The observation is, when we encounter new smallest element in the array, it can be a potential candidate to start new sequence.</em></p>
<p>From the observations, we need to maintain lists of increasing sequences.</p>
<p>In general, we have set of <strong>active lists</strong> of varying length. We are adding an element A[i] to these lists. We scan the lists (for end elements) in decreasing order of their length. We will verify the end elements of all the lists to find a list whose end element is smaller than A[i] (<em>floor</em> value).</p>
<p>Our strategy determined by the following conditions,</p>
<p><strong>1. If A[i] is smallest among all <em>end</em> candidates of active lists, we will <em>start</em> new active list of length 1.</strong></p>
<p><strong>2. If A[i] is largest among all <em>end</em> candidates of active lists, we will clone the <em>largest</em> active list, and extend it by A[i].</strong></p>
<p><strong>3. If A[i] is in between, we will find a list with <em>largest end element that is smaller than</em> A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list.</strong></p>
<p>Note that at any instance during our construction of active lists, the following condition is maintained.</p>
<p><em>“end element of smaller list is smaller than end elements of larger lists”</em>.</p>
<p>It will be clear with an example, let us take example from <a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence" target="_blank">wiki</a> {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}.</p>
<pre>A[0] = 0. Case 1. There are no active lists, create one.

0.

-----------------------------------------------------------------------------

A[1] = 8. Case 2. Clone and extend.

0.

0, 8.

-----------------------------------------------------------------------------

A[2] = 4. Case 3. Clone, extend and discard.

0.

0, 4.

<span style="text-decoration: line-through">0, 8</span>. Discarded

-----------------------------------------------------------------------------

A[3] = 12. Case 2. Clone and extend.

0.

0, 4.

0, 4, 12.

-----------------------------------------------------------------------------

A[4] = 2. Case 3. Clone, extend and discard.

0.

0, 2.

<span style="text-decoration: line-through">0, 4</span>. Discarded.

0, 4, 12.

-----------------------------------------------------------------------------

A[5] = 10. Case 3. Clone, extend and discard.

0.

0, 2.

0, 2, 10.

<span style="text-decoration: line-through">0, 4, 12</span>. Discarded.

-----------------------------------------------------------------------------

A[6] = 6. Case 3. Clone, extend and discard.

0.

0, 2.

0, 2, 6.

<span style="text-decoration: line-through">0, 2, 10</span>. Discarded.

-----------------------------------------------------------------------------

A[7] = 14. Case 2. Clone and extend.

0.

0, 2.

0, 2, 6.

0, 2, 6, 14.

-----------------------------------------------------------------------------

A[8] = 1. Case 3. Clone, extend and discard.

0.

0, 1.

<span style="text-decoration: line-through">0, 2</span>. Discarded.

0, 2, 6.

0, 2, 6, 14.

-----------------------------------------------------------------------------

A[9] = 9. Case 3. Clone, extend and discard.

0.

0, 1.

0, 2, 6.

0, 2, 6, 9.

<span style="text-decoration: line-through">0, 2, 6, 14</span>. Discarded.

-----------------------------------------------------------------------------

A[10] = 5. Case 3. Clone, extend and discard.

0.

0, 1.

0, 1, 5.

<span style="text-decoration: line-through">0, 2, 6</span>. Discarded.

0, 2, 6, 9.

-----------------------------------------------------------------------------

A[11] = 13. Case 2. Clone and extend.

0.

0, 1.

0, 1, 5.

0, 2, 6, 9.

0, 2, 6, 9, 13.

-----------------------------------------------------------------------------

A[12] = 3. Case 3. Clone, extend and discard.

0.

0, 1.

0, 1, 3.

<span style="text-decoration: line-through">0, 1, 5</span>. Discarded.

0, 2, 6, 9.

0, 2, 6, 9, 13.

-----------------------------------------------------------------------------

A[13] = 11. Case 3. Clone, extend and discard.

0.

0, 1.

0, 1, 3.

0, 2, 6, 9.

0, 2, 6, 9, 11.

<span style="text-decoration: line-through">0, 2, 6, 9, 13</span>. Discarded.

-----------------------------------------------------------------------------

A[14] = 7. Case 3. Clone, extend and discard.

0.

0, 1.

0, 1, 3.

0, 1, 3, 7.

<span style="text-decoration: line-through">0, 2, 6, 9</span>. Discarded.

0, 2, 6, 9, 11.

----------------------------------------------------------------------------

A[15] = 15. Case 2. Clone and extend.

0.

0, 1.

0, 1, 3.

0, 1, 3, 7.

0, 2, 6, 9, 11.

<strong>0, 2, 6, 9, 11, 15. &lt;-- LIS List</strong>

----------------------------------------------------------------------------</pre>
<p>It is required to understand above strategy to devise an algorithm. Also, ensure we have maintained the condition, “<em>end element of smaller list is smaller than end elements of larger lists</em>“. Try with few other examples, before reading further. It is important to understand what happening to end elements.</p>
<p><strong>Algorithm:</strong></p>
<p>Querying length of longest is fairly easy. Note that we are dealing with end elements only. We need not to maintain all the lists. We can store the end elements in an array. Discarding operation can be simulated with replacement, and extending a list is analogous to adding more elements to array.</p>
<p>We will use an auxiliary array to keep end elements. The maximum length of this array is that of input. In the worst case the array divided into N lists of size one (<em>note that it does’t lead to worst case complexity</em>). To discard an element, we will trace ceil value of A[i] in auxiliary array (again observe the end elements in your rough work), and replace ceil value with A[i]. We extend a list by adding element to auxiliary array. We also maintain a counter to keep track of auxiliary array length.</p>
<p><strong>Bonus:</strong> You have learnt <a href="http://en.wikipedia.org/wiki/Patience_sorting" target="_blank">Patience Sorting</a> technique partially :).</p>
<p>Here is a proverb, “<em>Tell me and I will forget. Show me and I will remember. Involve me and I will understand</em>.” So, pick a suit from deck of cards. Find the longest increasing sub-sequence of cards from the shuffled suit. You will never forget the approach. <img alt=":)" class="wp-smiley" src="http://d1gjlxt8vb0knt.cloudfront.net//wp-includes/images/smilies/simple-smile.png" style="height: 1em; max-height: 1em;"/></p>
<p>Given below is code to find length of LIS,<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate" title="">

// C++ program to find length of longest increasing subsequence

// in O(n Log n) time

#include &lt;iostream&gt;

#include &lt;string.h&gt;

#include &lt;stdio.h&gt;

using namespace std;



#define ARRAY_SIZE(A) sizeof(A)/sizeof(A[0])



// Binary search (note boundaries in the caller)

// A[] is ceilIndex in the caller

int CeilIndex(int A[], int l, int r, int key)

{

    while (r - l &gt; 1)

    {

        int m = l + (r - l)/2;

        if (A[m]&gt;=key)

            r = m;

        else

            l = m;

    }

    return r;

}



int LongestIncreasingSubsequenceLength(int A[], int size)

{

    // Add boundary case, when array size is one



    int *tailTable   = new int[size];

    int len; // always points empty slot



    memset(tailTable, 0, sizeof(tailTable[0])*size);



    tailTable[0] = A[0];

    len = 1;

    for (int i = 1; i &lt; size; i++)

    {

        if (A[i] &lt; tailTable[0])

            // new smallest value

            tailTable[0] = A[i];



        else if (A[i] &gt; tailTable[len-1])

            // A[i] wants to extend largest subsequence

            tailTable[len++] = A[i];



        else

            // A[i] wants to be current end candidate of an existing

            // subsequence. It will replace ceil value in tailTable

            tailTable[CeilIndex(tailTable, -1, len-1, A[i])] = A[i];

    }



    delete[] tailTable;

    return len;

}



int main()

{

    int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 };

    int n = ARRAY_SIZE(A);

    printf("Length of Longest Increasing Subsequence is %d\n",

           LongestIncreasingSubsequenceLength(A, n));



    return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post32"> <span class="glyphicon glyphicon-collapse-down"></span>

Find subarray with given sum | Set 1 (Nonnegative Numbers)

</button> <div id="post32" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find subarray with given sum | Set 1 (Nonnegative Numbers)</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array of nonnegative integers, find a continous subarray which adds to a given number. <span id="more-19267"></span></p>
<p>Examples:</p>
<pre>

Input: arr[] = {1, 4, 20, 3, 10, 5}, sum = 33

Ouptut: Sum found between indexes 2 and 4



Input: arr[] = {1, 4, 0, 0, 3, 10, 5}, sum = 7

Ouptut: Sum found between indexes 1 and 4



Input: arr[] = {1, 4}, sum = 0

Output: No subarray found

</pre>
<p>There may be more than one subarrays with sum as the given sum. The following solutions print first such subarray. </p>
<p>Source: Google Interview Question</p>
<div id="practice"></div>
<p><strong>Method 1 (Simple) </strong><br/>
A simple solution is to consider all subarrays one by one and check the sum of every subarray.  Following program implements the simple solution. We run two loops: the outer loop picks a starting point i and the inner loop tries all subarrays starting from i.</p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

/* A simple program to print subarray with sum as given sum */

#include&lt;stdio.h&gt;



/* Returns true if the there is a subarray of arr[] with sum equal to 'sum'

   otherwise returns false.  Also, prints the result */

int subArraySum(int arr[], int n, int sum)

{

    int curr_sum, i, j;



    // Pick a starting point

    for (i = 0; i &lt; n; i++)

    {

        curr_sum = arr[i];



        // try all subarrays starting with 'i'

        for (j = i+1; j &lt;= n; j++)

        {

            if (curr_sum == sum)

            {

                printf ("Sum found between indexes %d and %d", i, j-1);

                return 1;

            }

            if (curr_sum &gt; sum || j == n)

                break;

           curr_sum = curr_sum + arr[j];

        }

    }



    printf("No subarray found");

    return 0;

}



// Driver program to test above function

int main()

{

    int arr[] = {15, 2, 4, 8, 9, 5, 10, 23};

    int n = sizeof(arr)/sizeof(arr[0]);

    int sum = 23;

    subArraySum(arr, n, sum);

    return 0;

}

</pre>
<p>Output:
<pre>

Sum found between indexes 1 and 4

</pre>
<p>Time Complexity: O(n^2) in worst case.</p>
<p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post33"> <span class="glyphicon glyphicon-collapse-down"></span>

Count smaller elements on right side

</button> <div id="post33" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count smaller elements on right side</h1>
</header>
<div class="entry-content">
<p>Write a function to count number of smaller elements on right of each element in an array. <span id="more-17235"></span>Given an unsorted array arr[] of distinct integers, construct another array countSmaller[] such that countSmaller[i] contains count of smaller elements on right side of each element arr[i] in array.</p>
<p>Examples:</p>
<pre>

Input:   arr[] =  {12, 1, 2, 3, 0, 11, 4}

Output:  countSmaller[]  =  {6, 1, 1, 1, 0, 1, 0} 



(Corner Cases)

Input:   arr[] =  {5, 4, 3, 2, 1}

Output:  countSmaller[]  =  {4, 3, 2, 1, 0} 



Input:   arr[] =  {1, 2, 3, 4, 5}

Output:  countSmaller[]  =  {0, 0, 0, 0, 0}

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=585" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Simple)</strong><br/>
Use two loops. The outer loop picks all elements from left to right. The inner loop iterates through all the elements on right side of the picked element and updates countSmaller[].</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate" title="">

void constructLowerArray (int *arr[], int *countSmaller, int n)

{

  int i, j;



  // initialize all the counts in countSmaller array as 0

  for  (i = 0; i &lt; n; i++)

     countSmaller[i] = 0;



  for (i = 0; i &lt; n; i++)

  {

    for (j = i+1; j &lt; n; j++)

    {

       if (arr[j] &lt; arr[i])

         countSmaller[i]++;

    }

  }

}



/* Utility function that prints out an array on a line */

void printArray(int arr[], int size)

{

  int i;

  for (i=0; i &lt; size; i++)

    printf("%d ", arr[i]);



  printf("\n");

}



// Driver program to test above functions

int main()

{

  int arr[] = {12, 10, 5, 4, 2, 20, 6, 1, 0, 2};

  int n = sizeof(arr)/sizeof(arr[0]);

  int *low = (int *)malloc(sizeof(int)*n);

  constructLowerArray(arr, low, n);

  printArray(low, n);

  return 0;

}

</pre>
<p>Time Complexity:  O(n^2)<br/>
Auxiliary Space: O(1)</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post34"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum Length Bitonic Subarray

</button> <div id="post34" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum Length Bitonic Subarray</h1>
</header>
<div class="entry-content">
<p>Given an array A[0 … n-1] containing n positive integers, a subarray A[i … j] is bitonic if there is a k with i &lt;= k &lt;= j such that A[i] &lt;= A[i + 1] ... &lt;= A[k] &gt;= A[k + 1] &gt;= .. A[j – 1] &gt; = A[j]. <span id="more-12292"></span> Write a function that takes an array as argument and returns the length of the maximum length bitonic subarray.<br/>
Expected time complexity of the solution is O(n)</p>
<p><em>Simple Examples</em><br/>
<strong>1)</strong> A[] = {12, 4, 78, 90, 45, 23}, the maximum length bitonic subarray is {4, 78, 90, 45, 23} which is of length 5.</p>
<p><strong>2)</strong> A[] = {20, 4, 1, 2, 3, 4, 2, 10}, the maximum length bitonic subarray is {1, 2, 3, 4, 2} which is of length 5.</p>
<p><em>Extreme Examples</em><br/>
<strong>1)</strong> A[] = {10}, the single element is bitnoic, so output is 1.</p>
<p><strong>2)</strong> A[] = {10, 20, 30, 40}, the complete array itself is bitonic, so output is 4.</p>
<p><strong>3)</strong> A[] = {40, 30, 20, 10}, the complete array itself is bitonic, so output is 4.</p>
<p><strong>Solution</strong><br/>
Let us consider the array {12, 4, 78, 90, 45, 23} to understand the soultion.<br/>
1) Construct an auxiliary array inc[] from left to right such that inc[i] contains length of the nondecreaing subarray ending at arr[i].<br/>
For for A[] = {12, 4, 78, 90, 45, 23}, inc[] is {1, 1, 2, 3, 1, 1} </p>
<p>2) Construct another array dec[] from right to left such that dec[i] contains length of nonincreasing subarray starting at arr[i].<br/>
For A[] = {12, 4, 78, 90, 45, 23}, dec[] is {2, 1, 1, 3, 2, 1}.</p>
<p>3) Once we have the inc[] and dec[] arrays, all we need to do is find the maximum value of (inc[i] + dec[i] – 1).<br/>
For {12, 4, 78, 90, 45, 23}, the max value of (inc[i] + dec[i] – 1) is 5 for i = 3.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate" title="">

// C program to find length of the longest bitonic subarray

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;



int bitonic(int arr[], int n)

{

    int inc[n]; // Length of increasing subarray ending at all indexes

    int dec[n]; // Length of decreasing subarray starting at all indexes

    int i, max;



    // length of increasing sequence ending at first index is 1

    inc[0] = 1;



    // length of increasing sequence starting at first index is 1

    dec[n-1] = 1;



    // Step 1) Construct increasing sequence array

    for (i = 1; i &lt; n; i++)

       inc[i] = (arr[i] &gt; arr[i-1])? inc[i-1] + 1: 1;



    // Step 2) Construct decreasing sequence array

    for (i = n-2; i &gt;= 0; i--)

       dec[i] = (arr[i] &gt; arr[i+1])? dec[i+1] + 1: 1;



    // Step 3) Find the length of maximum length bitonic sequence

    max = inc[0] + dec[0] - 1;

    for (i = 1; i &lt; n; i++)

        if (inc[i] + dec[i] - 1 &gt; max)

            max = inc[i] + dec[i] - 1;



    return max;

}



/* Driver program to test above function */

int main()

{

    int arr[] = {12, 4, 78, 90, 45, 23};

    int n = sizeof(arr)/sizeof(arr[0]);

    printf("\nLength of max length Bitnoic Subarray is %d",

            bitonic(arr, n));

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]; title: ; notranslate" title="">

// Java program to find length of the longest bitonic subarray

import java.io.*;

import java.util.*;



class Bitonic

{

    static int bitonic(int arr[], int n)

    {

        int[] inc = new int[n]; // Length of increasing subarray ending 

                                // at all indexes

        int[] dec = new int[n]; // Length of decreasing subarray starting

                                // at all indexes

        int max;



        // Length of increasing sequence ending at first index is 1

        inc[0] = 1;



        // Length of increasing sequence starting at first index is 1

        dec[n-1] = 1;



        // Step 1) Construct increasing sequence array

        for (int i = 1; i &lt; n; i++)

           inc[i] = (arr[i] &gt; arr[i-1])? inc[i-1] + 1: 1;



        // Step 2) Construct decreasing sequence array

        for (int i = n-2; i &gt;= 0; i--)

            dec[i] = (arr[i] &gt; arr[i+1])? dec[i+1] + 1: 1;



        // Step 3) Find the length of maximum length bitonic sequence

        max = inc[0] + dec[0] - 1;

        for (int i = 1; i &lt; n; i++)

            if (inc[i] + dec[i] - 1 &gt; max)

                max = inc[i] + dec[i] - 1;



        return max;

    }



    /*Driver function to check for above function*/

    public static void main (String[] args)

    {

        int arr[] = {12, 4, 78, 90, 45, 23};

        int n = arr.length;

        System.out.println("Length of max length Bitnoic Subarray is "

                            + bitonic(arr, n));

    }

}

/* This code is contributed by Devesh Agrawal */

</pre>
<p></p></div></div><br/>
Output:
<pre>Length of max length Bitnoic Subarray is 5</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/k4vMVTp6AuI?feature=oembed" width="665"></iframe></p>
<p>As an exercise, extend the above implementation to print the longest bitonic subarray also.  The above implementation only returns the length of such subarray. </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post35"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the minimum distance between two numbers

</button> <div id="post35" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the minimum distance between two numbers</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array arr[] and two numbers x and y, find the minimum distance between x and y in arr[]. <span id="more-13128"></span>The array might also contain duplicates. You may assume that both x and y are different and present in arr[].</p>
<p>Examples:<br/>
Input: arr[] = {1, 2}, x = 1, y = 2<br/>
Output: Minimum distance between 1 and 2 is 1.</p>
<p>Input: arr[] = {3, 4, 5}, x = 3, y = 5<br/>
Output: Minimum distance between 3 and 5 is 2.</p>
<p>Input: arr[] = {3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3},  x = 3, y = 6<br/>
Output: Minimum distance between 3 and 6 is 4.</p>
<p>Input: arr[] = {2, 5, 3, 5, 4, 4, 2, 3},  x = 3, y = 2<br/>
Output: Minimum distance between 3 and 2 is 1.</p>
<p><strong>Method 1 (Simple)</strong><br/>
Use two loops: The outer loop picks all the elements of arr[] one by one. The inner loop picks all the elements after the element picked by outer loop. If the elements picked by outer and inner loops have same values as x or y then if needed update the minimum distance calculated so far.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt; // for abs()

#include &lt;limits.h&gt; // for INT_MAX



int minDist(int arr[], int n, int x, int y)

{

   int i, j;

   int min_dist = INT_MAX;

   for (i = 0; i &lt; n; i++)

   {

     for (j = i+1; j &lt; n; j++)

     {

         if( (x == arr[i] &amp;&amp; y == arr[j] ||

              y == arr[i] &amp;&amp; x == arr[j]) &amp;&amp; min_dist &gt; abs(i-j))

         {

              min_dist = abs(i-j);

         }

     }

   }

   return min_dist;

}



/* Driver program to test above fnction */

int main() 

{

    int arr[] = {3, 5, 4, 2, 6, 5, 6, 6, 5, 4, 8, 3};

    int n = sizeof(arr)/sizeof(arr[0]);

    int x = 3;

    int y = 6;



    printf("Minimum distance between %d and %d is %d\n", x, y, 

              minDist(arr, n, x, y));

    return 0;

}

</pre>
<p>Output:  <em>Minimum distance between 3 and 6 is 4</em></p>
<p>Time Complexity: O(n^2)</p>
<p><strong>Method 2 (Tricky)</strong><br/>
1) Traverse array from left side and stop if either <em>x</em> or <em>y</em> is found. Store index of this first occurrence in a variable say <em>prev</em><br/>
2) Now traverse <em>arr[]</em> after the index <em>prev</em>.  If the element at current index <em>i</em> matches with either x or y then check if it is different from <em> arr[prev]</em>.  If it is different then update the minimum distance if needed.  If it is same then update <em>prev</em> i.e., make <em>prev = i</em>.</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-26#post-25179">wgpshashank </a>for suggesting this approach.</p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

#include &lt;limits.h&gt;  // For INT_MAX



int minDist(int arr[], int n, int x, int y)

{

   int i = 0;

   int min_dist = INT_MAX;

   int prev;



   // Find the first occurence of any of the two numbers (x or y)

   // and store the index of this occurence in prev

   for (i = 0; i &lt; n; i++)

   {

     if (arr[i] == x || arr[i] == y)

     {

       prev = i;

       break;

     }

   }



   // Traverse after the first occurence

   for ( ; i &lt; n; i++)

   {

      if (arr[i] == x || arr[i] == y)

      {

          // If the current element matches with any of the two then

          // check if current element and prev element are different

          // Also check if this value is smaller than minimm distance so far

          if ( arr[prev] != arr[i] &amp;&amp; (i - prev) &lt; min_dist )

          {

             min_dist = i - prev;

             prev = i;

          }

          else

             prev = i;

      }

   }



   return min_dist;

}



/* Driver program to test above fnction */

int main()

{

    int arr[] ={3, 5, 4, 2, 6, 3, 0, 0, 5, 4, 8, 3};

    int n = sizeof(arr)/sizeof(arr[0]);

    int x = 3;

    int y = 6;



    printf("Minimum distance between %d and %d is %d\n", x, y,

              minDist(arr, n, x, y));

    return 0;

}



</pre>
<p>Output:  <em>Minimum distance between 3 and 6 is 1</em></p>
<p>Time Complexity: O(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/hoceGcqQczM?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post36"> <span class="glyphicon glyphicon-collapse-down"></span>

Given an array arr[], find the maximum j – i such that arr[j] > arr[i]

</button> <div id="post36" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Given an array arr[], find the maximum j – i such that arr[j] &gt; arr[i]</h1>
</header>
<div class="entry-content">
<p>Given an array arr[], find the maximum j – i such that arr[j] &gt; arr[i].<span id="more-12450"></span></p>
<p>Examples:</p>
<pre>  Input: {34, 8, 10, 3, 2, 80, 30, 33, 1}

  Output: 6  (j = 7, i = 1)



  Input: {9, 2, 3, 4, 5, 6, 7, 8, 18, 0}

  Output: 8 ( j = 8, i = 0)



  Input:  {1, 2, 3, 4, 5, 6}

  Output: 5  (j = 5, i = 0)



  Input:  {6, 5, 4, 3, 2, 1}

  Output: -1 </pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=129" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Simple but Inefficient)</strong><br/>
Run two loops.  In the outer loop, pick elements one by one from left. In the inner loop, compare the picked element with the elements starting from right side. Stop the inner loop when you see an element greater than the picked element and keep updating the maximum j-i so far.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include &lt;stdio.h&gt;

/* For a given array arr[], returns the maximum j – i such that

    arr[j] &gt; arr[i] */

int maxIndexDiff(int arr[], int n)

{

    int maxDiff = -1;

    int i, j;



    for (i = 0; i &lt; n; ++i)

    {

        for (j = n-1; j &gt; i; --j)

        {

            if(arr[j] &gt; arr[i] &amp;&amp; maxDiff &lt; (j - i))

                maxDiff = j - i;

        }

    }



    return maxDiff;

}



int main()

{

    int arr[] = {9, 2, 3, 4, 5, 6, 7, 8, 18, 0};

    int n = sizeof(arr)/sizeof(arr[0]);

    int maxDiff = maxIndexDiff(arr, n);

    printf("\n %d", maxDiff);

    getchar();

    return 0;

}

</pre>
<p>Time Complexity: O(n^2)</p>
<p><strong>Method 2 (Efficient)</strong><br/>
To solve this problem, we need to get two optimum indexes of arr[]: left index i and right index j.  For an element arr[i], we do not need to  consider arr[i] for left index if there is an element smaller than arr[i] on left side of arr[i].  Similarly, if there is a greater element on right side of arr[j] then we do not need to consider this j for right index. So we construct two auxiliary arrays LMin[] and RMax[] such that LMin[i] holds the smallest element on left side of arr[i] including arr[i], and RMax[j] holds the greatest element on right side of arr[j] including arr[j].   After constructing these two auxiliary arrays, we traverse both of these arrays from left to right. While traversing LMin[] and RMa[] if we see that LMin[i] is greater than RMax[j], then we must move ahead in LMin[] (or do i++) because all elements on left of LMin[i] are greater than or equal to LMin[i].  Otherwise we must move ahead in RMax[j] to look for a greater j – i value.</p>
<p>Thanks to celicom for suggesting the algorithm for this method.</p>
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate" title="">

#include &lt;stdio.h&gt;



/* Utility Functions to get max and minimum of two integers */

int max(int x, int y)

{

    return x &gt; y? x : y;

}



int min(int x, int y)

{

    return x &lt; y? x : y;

}



/* For a given array arr[], returns the maximum j – i such that

    arr[j] &gt; arr[i] */

int maxIndexDiff(int arr[], int n)

{

    int maxDiff;

    int i, j;



    int *LMin = (int *)malloc(sizeof(int)*n);

    int *RMax = (int *)malloc(sizeof(int)*n);



   /* Construct LMin[] such that LMin[i] stores the minimum value

       from (arr[0], arr[1], ... arr[i]) */

    LMin[0] = arr[0];

    for (i = 1; i &lt; n; ++i)

        LMin[i] = min(arr[i], LMin[i-1]);



    /* Construct RMax[] such that RMax[j] stores the maximum value

       from (arr[j], arr[j+1], ..arr[n-1]) */

    RMax[n-1] = arr[n-1];

    for (j = n-2; j &gt;= 0; --j)

        RMax[j] = max(arr[j], RMax[j+1]);



    /* Traverse both arrays from left to right to find optimum j - i

        This process is similar to merge() of MergeSort */

    i = 0, j = 0, maxDiff = -1;

    while (j &lt; n &amp;&amp; i &lt; n)

    {

        if (LMin[i] &lt; RMax[j])

        {

            maxDiff = max(maxDiff, j-i);

            j = j + 1;

        }

        else

            i = i+1;

    }



    return maxDiff;

}



/* Driver program to test above functions */

int main()

{

    int arr[] = {9, 2, 3, 4, 5, 6, 7, 8, 18, 0};

    int n = sizeof(arr)/sizeof(arr[0]);

    int maxDiff = maxIndexDiff(arr, n);

    printf("\n %d", maxDiff);

    getchar();

    return 0;

}

</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n)</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post37"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the smallest missing number

</button> <div id="post37" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the smallest missing number</h1>
</header>
<div class="entry-content">
<p>Given a <strong>sorted </strong>array of n integers where each integer is in the range from 0 to m-1 and m &gt; n. <span id="more-12012"></span> Find the smallest number that is missing from the array.  </p>
<p>Examples<br/>
Input: {0, 1, 2, 6, 9},  n = 5, m = 10<br/>
Output:  3</p>
<p>Input: {4, 5, 10, 11},  n = 4, m = 12<br/>
Output:  0</p>
<p>Input: {0, 1, 2, 3},  n = 4, m = 5<br/>
Output:  4</p>
<p>Input: {0, 1, 2, 3, 4, 5, 6, 7, 10},  n = 9, m = 11<br/>
Output:  8</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/commvault-interview-question-for-software-engineerdeveloper-2-5-years-about-algorithms#post-21316">Ravichandra </a>for suggesting following two methods.</p>
<p><strong>Method 1 (Use Binary Search)</strong><br/>
For i = 0 to m-1, do binary search for i in the array.  If i is not present in the array then return i.</p>
<p>Time Complexity: O(m log n) </p>
<p><strong>Method 2 (Linear Search) </strong><br/>
If arr[0] is not 0, return 0. Otherwise traverse the input array starting from index 0, and for each pair of elements a[i] and a[i+1], find the difference between them. if the difference is greater than 1 then a[i]+1 is the missing number. </p>
<p>Time Complexity:  O(n)</p>
<p><strong>Method 3 (Use Modified Binary Search)</strong><br/>
Thanks to <a href="http://geeksforgeeks.org/forum/topic/commvault-interview-question-for-software-engineerdeveloper-2-5-years-about-algorithms#post-21377">yasein</a> and <a href="http://www.geeksforgeeks.org/archives/12012/comment-page-1#comment-3866">Jams</a> for suggesting this method.<br/>
In the standard Binary Search process, the element to be searched is compared with the middle element and on the basis of comparison result, we decide whether to search is over or to go to left half or right half.<br/>
In this method, we modify the standard Binary Search algorithm to compare the middle element with its index and make decision on the basis of this comparison.</p>
<p>…1) If the first element is not same as its index then return first index<br/>
…2) Else get the middle index say mid<br/>
…………a) If arr[mid] greater than mid then the required element lies in left half.<br/>
…………b) Else the required element lies in right half.</p>
<pre class="brush: cpp; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



int findFirstMissing(int array[], int start, int end) {



    if(start  &gt; end)

      return end + 1;



    if (start != array[start])

      return start;



    int mid = (start + end) / 2;



    if (array[mid] &gt; mid)

      return findFirstMissing(array, start, mid);

    else

      return findFirstMissing(array, mid + 1, end);

}



// driver program to test above function

int main()

{

  int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 10};

  int n = sizeof(arr)/sizeof(arr[0]);

  printf(" First missing element is %d",

           findFirstMissing(arr, 0, n-1));

  getchar();

  return 0;

}

</pre>
<p><strong>Note: </strong> This method doesn’t work if there are duplicate elements in the array.</p>
<p>Time Complexity:  O(Logn)</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post38"> <span class="glyphicon glyphicon-collapse-down"></span>

Check if array elements are consecutive | Added Method 3

</button> <div id="post38" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Check if array elements are consecutive | Added Method 3</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array of numbers, write a function that returns true if array consists of consecutive numbers. <span id="more-11516"></span></p>
<p>Examples:<br/>
<strong>a)</strong> If array is {5, 2, 3, 1, 4},  then the function should return true because the array has consecutive numbers from 1 to 5.</p>
<p><strong>b)</strong> If array is {83, 78, 80, 81, 79, 82}, then the function should return true because the array has consecutive numbers from 78 to 83.</p>
<p><strong>c) </strong>If the array is {34, 23, 52, 12, 3 }, then the function should return false because the elements are not consecutive.</p>
<p><strong>d) </strong>If the array is {7, 6, 5, 5, 3, 4}, then the function should return false because 5 and 5 are not consecutive.</p>
<p><strong>Method 1 (Use Sorting)</strong><br/>
1) Sort all the elements.<br/>
2) Do a linear scan of the sorted array. If the difference between current element and next element is anything other than 1, then return false. If all differences are 1, then return true.</p>
<p>Time Complexity: O(nLogn)</p>
<p><strong>Method 2 (Use visited array)</strong><br/>
The idea is to check for following two conditions. If following two conditions are true, then return true.<br/>
1) <em>max – min + 1 = n </em> where max is the maximum element in array, min is minimum element in array and n is the number of elements in array.<br/>
2) All elements are distinct.</p>
<p>To check if all elements are distinct, we can create a visited[] array of size n.  We can map the ith element of input array arr[] to visited array by using arr[i] – min as index in visited[]. </p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate" title="">#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;



/* Helper functions to get minimum and maximum in an array */

int getMin(int arr[], int n);

int getMax(int arr[], int n);



/* The function checks if the array elements are consecutive

  If elements are consecutive, then returns true, else returns

  false */

bool areConsecutive(int arr[], int n)

{

  if ( n &lt;  1 )

    return false;



  /* 1) Get the minimum element in array */

  int min = getMin(arr, n);



  /* 2) Get the maximum element in array */

  int max = getMax(arr, n);



  /* 3) max - min + 1 is equal to n,  then only check all elements */

  if (max - min  + 1 == n)

  {

      /* Create a temp array to hold visited flag of all elements.

         Note that, calloc is used here so that all values are initialized 

         as false */ 

      bool *visited = (bool *) calloc (n, sizeof(bool));

      int i;

      for (i = 0; i &lt; n; i++)

      {

         /* If we see an element again, then return false */

         if ( visited[arr[i] - min] != false )

           return false;



         /* If visited first time, then mark the element as visited */

         visited[arr[i] - min] = true;

      }



      /* If all elements occur once, then return true */

      return true;

  }



  return false; // if (max - min  + 1 != n)

}



/* UTILITY FUNCTIONS */

int getMin(int arr[], int n)

{

  int min = arr[0];

  for (int i = 1; i &lt; n; i++)

   if (arr[i] &lt; min)

     min = arr[i];

  return min;

}



int getMax(int arr[], int n)

{

  int max = arr[0];

  for (int i = 1; i &lt; n; i++)

   if (arr[i] &gt; max)

     max = arr[i];

  return max;

}



/* Driver program to test above functions */

int main()

{

    int arr[]= {5, 4, 2, 3, 1, 6};

    int n = sizeof(arr)/sizeof(arr[0]);

    if(areConsecutive(arr, n) == true)

        printf(" Array elements are consecutive ");

    else

        printf(" Array elements are not consecutive ");

    getchar();

    return 0;

}

</pre>
<p>Time Complexity: O(n)<br/>
Extra Space: O(n) </p>
<p><strong>Method 3 (Mark visited array elements as negative)</strong><br/>
This method is O(n) time complexity and O(1) extra space, but it changes the original array and it works only if all numbers are positive.  We can get the original array by adding an extra step though. It is an extension of method 2 and it has the same two steps.<br/>
1) <em>max – min + 1 = n </em> where max is the maximum element in array, min is minimum element in array and n is the number of elements in array.<br/>
2) All elements are distinct.</p>
<p>In this method, the implementation of step 2 differs from method 2.  Instead of creating a new array, we modify the input array arr[] to keep track of visited elements. The idea is to traverse the array and for each index i (where 0 &lt;= i &lt; n), make arr[arr[i] - min]] as a negative value.  If we see a negative value again then there is repetition.

<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]; title: ; notranslate" title="">

#include&lt;stdio.h&gt;

#include&lt;stdlib.h&gt;



/* Helper functions to get minimum and maximum in an array */

int getMin(int arr[], int n);

int getMax(int arr[], int n);



/* The function checks if the array elements are consecutive

  If elements are consecutive, then returns true, else returns

  false */

bool areConsecutive(int arr[], int n)

{



    if ( n &lt;  1 )

        return false;



    /* 1) Get the minimum element in array */

    int min = getMin(arr, n);



    /* 2) Get the maximum element in array */

    int max = getMax(arr, n);



    /* 3) max – min + 1 is equal to n then only check all elements */

    if (max – min  + 1 == n)

    {

        int i;

        for(i = 0; i &lt; n; i++)

        {

            int j;



            if (arr[i] &lt; 0)

                j = -arr[i] – min;

            else

                j = arr[i] – min;



            // if the value at index j is negative then

            // there is repitition

            if (arr[j] &gt; 0)

                arr[j] = -arr[j];

            else

                return false;

        }



        /* If we do not see a negative value then all elements

           are distinct */

        return true;

    }



    return false; // if (max – min  + 1 != n)

}



/* UTILITY FUNCTIONS */

int getMin(int arr[], int n)

{

    int min = arr[0];

    for (int i = 1; i &lt; n; i++)

        if (arr[i] &lt; min)

            min = arr[i];

    return min;

}



int getMax(int arr[], int n)

{

    int max = arr[0];

    for (int i = 1; i &lt; n; i++)

        if (arr[i] &gt; max)

            max = arr[i];

    return max;

}



/* Driver program to test above functions */

int main()

{

    int arr[]= {1, 4, 5, 3, 2, 6};

    int n = sizeof(arr)/sizeof(arr[0]);

    if(areConsecutive(arr, n) == true)

        printf(" Array elements are consecutive ");

    else

        printf(" Array elements are not consecutive ");

    getchar();

    return 0;

}

</pre>
<p>Note that this method might not work for negative numbers.  For example, it returns false for {2, 1, 0, -3, -1, -2}.</p>
<p>Time Complexity: O(n)<br/>
Extra Space: O(1) </p>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-fresher-9">http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-fresher-9</a></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post39"> <span class="glyphicon glyphicon-collapse-down"></span>

Linked List vs Array

</button> <div id="post39" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Linked List vs Array</h1>
</header>
<div class="entry-content">
<p><strong>Difficulty Level:</strong> Rookie</p>
<p>Both Arrays and <a href="http://en.wikipedia.org/wiki/Linked_list">Linked List</a> can be used to store linear data of similar types, but they both have some advantages and disadvantages over each other. <span id="more-10245"></span></p>
<p>Following are the points in favour of Linked Lists.</p>
<p>(1)	The size of the arrays is fixed:  So we must know the upper limit on the number of elements in advance.  Also, generally, the allocated memory is equal to the upper limit irrespective of the usage, and in practical uses, upper limit is rarely reached.</p>
<p>(2)	Inserting a new element in an array of elements is expensive, because room has to be created for the new elements and to create room existing elements have to shifted. </p>
<p>For example, suppose we maintain a sorted list of IDs in an array id[].  </p>
<p>id[] = [1000,  1010,  1050,  2000,  2040, …..]. </p>
<p>And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).  </p>
<p>Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.</p>
<p>So Linked list provides following two advantages over arrays<br/>
1)	Dynamic size<br/>
2)	Ease of insertion/deletion</p>
<p>Linked lists have following drawbacks:<br/>
1)	Random access is not allowed.  We have to access elements sequentially starting from the first node.  So we cannot do binary search with linked lists.<br/>
2)	Extra memory space for a pointer is required with each element of the list.<br/>
3)    Arrays have better cache locality that can make a pretty big difference in performance.  </p>
<p>Please also see <a href="http://geeksforgeeks.org/forum/topic/tcs-interview-question-for-software-engineerdeveloper-fresher-about-linked-lists#post-18153">this </a> thread.</p>
<p>References:<br/>
<a href="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf">http://cslibrary.stanford.edu/103/LinkedListBasics.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post40"> <span class="glyphicon glyphicon-collapse-down"></span>

Given a binary string, count number of substrings that start and end with 1.

</button> <div id="post40" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Given a binary string, count number of substrings that start and end with 1.</h1>
</header>
<div class="entry-content">
<p>Given a binary string, count number of substrings that start and end with 1.  For example, if the input string is “00100101”, then there are three substrings “1001”, “100101” and “101”.<span id="more-133413"></span></p>
<p>Source: <a href="http://www.geeksforgeeks.org/amazon-interview-experience-set-162/">Amazon Interview Experience | Set 162</a></p>
<p><strong>Difficulty Level:</strong> Rookie</p>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=285" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p>A <strong>Simple Solution</strong> is to run two loops. Outer loops picks every 1 as starting point and inner loop searches for ending 1 and increments count whenever it finds 1.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]; title: ; notranslate" title="">

// A simple C++ program to count number of substrings starting and ending

// with 1

#include&lt;iostream&gt;

using namespace std;



int countSubStr(char str[])

{

   int res = 0;  // Initialize result



   // Pick a starting point

   for (int i=0; str[i] !='\0'; i++)

   {

        if (str[i] == '1')

        {

            // Search for all possible ending point

            for (int j=i+1; str[j] !='\0'; j++)

               if (str[j] == '1')

                  res++;

        }

   }

   return res;

}



// Driver program to test above function

int main()

{

  char str[] = "00100101";

  cout &lt;&lt; countSubStr(str);

  return 0;

}

</pre>
<p>Output:
<pre>3</pre>
<p>Time Complexity of the above solution is O(n<sup>2</sup>). We can find count <strong>in O(n) using a single traversal</strong> of input string.   Following are steps.<br/>
a) Count the number of 1’s.  Let the count of 1’s be m.<br/>
b) Return m(m-1)/2<br/>
The idea is to count total number of possible pairs of 1’s.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate" title="">

// A O(n) C++ program to count number of substrings starting and ending

// with 1

#include&lt;iostream&gt;

using namespace std;



int countSubStr(char str[])

{

   int m = 0; // Count of 1's in input string



   // Travers input string and count of 1's in it

   for (int i=0; str[i] !='\0'; i++)

   {

        if (str[i] == '1')

           m++;

   }



   // Return count of possible pairs among m 1's

   return m*(m-1)/2;

}



// Driver program to test above function

int main()

{

  char str[] = "00100101";

  cout &lt;&lt; countSubStr(str);

  return 0;

}</pre>
<p>Output:
<pre>3</pre>
<p>This article is contributed by <strong>Shivam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post41"> <span class="glyphicon glyphicon-collapse-down"></span>

Nuts & Bolts Problem (Lock & Key problem)

</button> <div id="post41" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Nuts &amp; Bolts Problem (Lock &amp; Key problem)</h1>
</header>
<div class="entry-content">
<p>Given a set of n nuts of different sizes and n bolts of different sizes. There is a one-one mapping between nuts and bolts. Match nuts and bolts efficiently.<span id="more-133297"></span><br/>
<strong>Constraint:</strong> Comparison of a nut to another nut or a bolt to another bolt is not allowed. It means nut can only be compared with bolt and bolt can only be compared with nut to see which one is bigger/smaller.</p>
<p>Other way of asking this problem is, given a box with locks and keys where one lock can be opened by one key in the box. We need to match the pair.</p>
<p><strong>Brute force Way:</strong> Start with the first bolt and compare it with each nut until we find a match. In the worst case we require n comparisons. Doing this for all bolts gives us O(n^2) complexity.</p>
<p><strong>Quick Sort Way:</strong> We can use quick sort technique to solve this. We represent nuts and bolts in character array for understanding the logic.</p>
<p>Nuts represented as array of character<br/>
char nuts[] = {‘@’, ‘#’, ‘$’, ‘%’, ‘^’, ‘&amp;’}</p>
<p>Bolts represented as array of character<br/>
char bolts[] = {‘$’, ‘%’, ‘&amp;’, ‘^’, ‘@’, ‘#’}</p>
<p>This algorithm first performs a partition by picking last element of bolts array as pivot, rearrange the array of nuts and returns the partition index ‘i’ such that all  nuts smaller than nuts[i] are on the left side and all nuts greater than nuts[i] are on the right side. Next using the nuts[i] we can partition the array of bolts. Partitioning operations can easily be implemented in O(n). This operation also makes nuts and bolts array nicely partitioned. Now we apply this partitioning recursively on the left and right sub-array of nuts and bolts.</p>
<p>As we apply partitioning on nuts and bolts both so the total time complexity will be Θ(2*nlogn) = Θ(nlogn) on average. </p>
<p>Here for the sake of simplicity we have chosen last element always as pivot. We can do randomized quick sort too. </p>
<p>A Java based implementation of idea is below:</p>
<pre class="brush: java; highlight: [27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate" title="">

// Java program to solve nut and bolt problem using Quick Sort

public class NutsAndBoltsMatch

{

    //Driver method

    public static void main(String[] args)

    {

        // Nuts and bolts are represented as array of characters

        char nuts[] = {'@', '#', '$', '%', '^', '&amp;'};

        char bolts[] = {'$', '%', '&amp;', '^', '@', '#'};



        // Method based on quick sort which matches nuts and bolts

        matchPairs(nuts, bolts, 0, 5);



        System.out.println("Matched nuts and bolts are : ");

        printArray(nuts);

        printArray(bolts);

    }



    // Method to print the array

    private static void printArray(char[] arr) {

        for (char ch : arr){

            System.out.print(ch + " ");

        }

        System.out.print("\n");

    }



    // Method which works just like quick sort

    private static void matchPairs(char[] nuts, char[] bolts, int low,

                                                              int high)

    {

        if (low &lt; high)

        {

            // Choose last character of bolts array for nuts partition.

            int pivot = partition(nuts, low, high, bolts[high]);



            // Now using the partition of nuts choose that for bolts

            // partition.

            partition(bolts, low, high, nuts[pivot]);



            // Recur for [low...pivot-1] &amp; [pivot+1...high] for nuts and

            // bolts array.

            matchPairs(nuts, bolts, low, pivot-1);

            matchPairs(nuts, bolts, pivot+1, high);

        }

    }



    // Similar to standard partition method. Here we pass the pivot element

    // too instead of choosing it inside the method.

    private static int partition(char[] arr, int low, int high, char pivot)

    {

        int i = low;

        char temp1, temp2;

        for (int j = low; j &lt; high; j++)

        {

            if (arr[j] &lt; pivot){

                temp1 = arr[i];

                arr[i] = arr[j];

                arr[j] = temp1;

                i++;

            } else if(arr[j] == pivot){

                temp1 = arr[j];

                arr[j] = arr[high];

                arr[high] = temp1;

                j--;

            }

        }

        temp2 = arr[i];

        arr[i] = arr[high];

        arr[high] = temp2;



        // Return the partition index of an array based on the pivot 

        // element of other array.

        return i;

    }

}

</pre>
<p>Output:
<pre>

Matched nuts and bolts are :

# $ % &amp; @ ^

# $ % &amp; @ ^ </pre>
<p>This article is contributed by <strong>Kumar Gautam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post42"> <span class="glyphicon glyphicon-collapse-down"></span>

Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array

</button> <div id="post42" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array</h1>
</header>
<div class="entry-content">
<p>Given an array of 0s and 1s, find the position of 0 to be replaced with 1 to get longest continuous sequence of 1s. <span id="more-132842"></span> Expected time complexity is O(n) and auxiliary space is O(1).<br/>
Example:</p>
<pre>Input: 

   arr[] =  {1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1}

Output:

  Index 9

Assuming array index starts from 0, replacing 0 with 1 at index 9 causes

the maximum continuous sequence of 1s.



Input: 

   arr[] =  {1, 1, 1, 1, 0}

Output:

  Index 4</pre>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>A <strong>Simple Solution</strong> is to traverse the array, for every 0, count the number of 1s on both sides of it. Keep track of maximum count for any 0. Finally return index of the 0 with maximum number of 1s around it. The time complexity of this solution is O(n<sup>2</sup>).</p>
<p>Using an <strong>Efficient Solution</strong>, the problem can solved in O(n) time. The idea is to keep track of three indexes, current index (<em>curr</em>), previous zero index (<em>prev_zero</em>) and previous to previous zero index (<em>prev_prev_zero</em>). Traverse the array, if current element is 0, calculate the difference between <em>curr </em>and <em>prev_prev_zero</em> (This difference minus one is the number of 1s around the prev_zero). If the difference between <em>curr </em>and <em>prev_prev_zero</em> is more than maximum so far, then update the maximum. Finally return index of the prev_zero with maximum difference.</p>
<p>Following are C++ and Java implementations of the above algorithm.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate" title="">

// C++ program to find Index of 0 to be replaced with 1 to get

// longest continuous sequence of 1s in a binary array

#include&lt;iostream&gt;

using namespace std;



// Returns index of 0 to be replaced with 1 to get longest

// continuous sequence of 1s.  If there is no 0 in array, then

// it returns -1.

int maxOnesIndex(bool arr[], int n)

{

    int max_count = 0;  // for maximum number of 1 around a zero

    int max_index;  // for storing result

    int prev_zero = -1;  // index of previous zero

    int prev_prev_zero = -1; // index of previous to previous zero



    // Traverse the input array

    for (int curr=0; curr&lt;n; ++curr)

    {

        // If current element is 0, then calculate the difference

        // between curr and prev_prev_zero

        if (arr[curr] == 0)

        {

            // Update result if count of 1s around prev_zero is more

            if (curr - prev_prev_zero &gt; max_count)

            {

                max_count = curr - prev_prev_zero;

                max_index = prev_zero;

            }



            // Update for next iteration

            prev_prev_zero = prev_zero;

            prev_zero = curr;

        }

    }



    // Check for the last encountered zero

    if (n-prev_prev_zero &gt; max_count)

       max_index = prev_zero;



    return max_index;

}



// Driver program

int main()

{

    bool arr[] = {1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Index of 0 to be replaced is "

         &lt;&lt; maxOnesIndex(arr, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate" title="">

// Java program to find Index of 0 to be replaced with 1 to get

// longest continuous sequence of 1s in a binary array



import java.io.*;



class Binary 

{    

    // Returns index of 0 to be replaced with 1 to get longest

    // continuous sequence of 1s.  If there is no 0 in array, then

    // it returns -1.

    static int maxOnesIndex(int arr[], int n)

    {

        int max_count = 0;  // for maximum number of 1 around a zero

        int max_index=0;  // for storing result

        int prev_zero = -1;  // index of previous zero

        int prev_prev_zero = -1; // index of previous to previous zero

 

        // Traverse the input array

        for (int curr=0; curr&lt;n; ++curr)

        {

            // If current element is 0, then calculate the difference

            // between curr and prev_prev_zero

            if (arr[curr] == 0)

            {

                // Update result if count of 1s around prev_zero is more

                if (curr - prev_prev_zero &gt; max_count)

                {

                    max_count = curr - prev_prev_zero;

                    max_index = prev_zero;

                }

 

                // Update for next iteration

                prev_prev_zero = prev_zero;

                prev_zero = curr;

            }

        }

 

        // Check for the last encountered zero

        if (n-prev_prev_zero &gt; max_count)

            max_index = prev_zero;

 

        return max_index;

    }

    

    

    // Driver program to test above function

    public static void main(String[] args)

    {

        int arr[] = {1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1};

        int n = arr.length;

        System.out.println("Index of 0 to be replaced is "+ 

                           maxOnesIndex(arr, n));        

    }

}

/* This code is contributed by Devesh Agrawal */

</pre>
<p></p></div></div><br/>
Output:</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post43"> <span class="glyphicon glyphicon-collapse-down"></span>

Length of the largest subarray with contiguous elements | Set 1

</button> <div id="post43" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Length of the largest subarray with contiguous elements | Set 1</h1>
</header>
<div class="entry-content">
<p>Given an array of distinct integers, find length of the longest subarray which contains numbers that can be arranged in a continuous sequence. <span id="more-131819"></span></p>
<p>Examples:
<pre>

Input:  arr[] = {10, 12, 11};

Output: Length of the longest contiguous subarray is 3



Input:  arr[] = {14, 12, 11, 20};

Output: Length of the longest contiguous subarray is 2



Input:  arr[] = {1, 56, 58, 57, 90, 92, 94, 93, 91, 45};

Output: Length of the longest contiguous subarray is 5

</pre>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>The important thing to note in question is, it is given that all elements are distinct.  If all elements are distinct, then a subarray has contiguous elements if and only if the difference between maximum and minimum elements in subarray is equal to the difference between last and first indexes of subarray.  So the idea is to keep track of minimum and maximum element in every subarray.  </p>
<p>The following is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

#include&lt;iostream&gt;

using namespace std;



// Utility functions to find minimum and maximum of

// two elements

int min(int x, int y) { return (x &lt; y)? x : y; }

int max(int x, int y) { return (x &gt; y)? x : y; }



// Returns length of the longest contiguous subarray

int findLength(int arr[], int n)

{

    int max_len = 1;  // Initialize result

    for (int i=0; i&lt;n-1; i++)

    {

        // Initialize min and max for all subarrays starting with i

        int mn = arr[i], mx = arr[i];



        // Consider all subarrays starting with i and ending with j

        for (int j=i+1; j&lt;n; j++)

        {

            // Update min and max in this subarray if needed

            mn = min(mn, arr[j]);

            mx = max(mx, arr[j]);



            // If current subarray has all contiguous elements

            if ((mx - mn) == j-i)

                max_len = max(max_len, mx-mn+1);

        }

    }

    return max_len;  // Return result

}



// Driver program to test above function

int main()

{

    int arr[] = {1, 56, 58, 57, 90, 92, 94, 93, 91, 45};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Length of the longest contiguous subarray is "

         &lt;&lt; findLength(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>Length of the longest contiguous subarray is 5</pre>
<p>Time Complexity of the above solution is O(n<sup>2</sup>).</p>
<p>We will soon be covering solution for the problem where duplicate elements are allowed in subarray.</p>
<p><a href="http://www.geeksforgeeks.org/length-largest-subarray-contiguous-elements-set-2/">Length of the largest subarray with contiguous elements | Set 2</a></p>
<p>This article is contributed by <strong>Arjun</strong>.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post44"> <span class="glyphicon glyphicon-collapse-down"></span>

Find common elements in three sorted arrays

</button> <div id="post44" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find common elements in three sorted arrays</h1>
</header>
<div class="entry-content">
<p>Given three arrays sorted in non-decreasing order, print all common elements in these arrays.<span id="more-131351"></span></p>
<p>Examples:
<pre>

ar1[] = {1, 5, 10, 20, 40, 80}

ar2[] = {6, 7, 20, 80, 100}

ar3[] = {3, 4, 15, 20, 30, 70, 80, 120}

Output: 20, 80



ar1[] = {1, 5, 5}

ar2[] = {3, 4, 5, 5, 10}

ar3[] = {5, 5, 10, 20}

Output: 5, 5

</pre>
<p>A simple solution is to first find <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/" target="_blank">intersection of two arrays </a>and store the intersection in a temporary array, then find the intersection of third array and temporary array.  Time complexity of this solution is O(n1 + n2 + n3) where n1, n2 and n3 are sizes of ar1[], ar2[] and ar3[] respectively.</p>
<p>The above solution requires extra space and two loops, we can find the common elements using a single loop and without extra space.  The idea is similar to <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/" target="_blank">intersection of two arrays</a>.  Like two arrays loop, we run a loop and traverse three arrays.<br/>
Let the current element traversed in ar1[] be x, in ar2[] be y and in ar3[] be z.   We can have following cases inside the loop.<br/>
1) If x, y and z are same, we can simply print any of them as common element and move ahead in all three arrays.<br/>
2) Else If x &lt; y, we can move ahead in ar1[] as x cannot be a common element
3) Else If y &lt; z, we can move ahead in ar2[] as y cannot be a common element
4) Else (We reach here when x &gt; y and y &gt; z), we can simply move ahead in ar3[] as z cannot be a common element.</p>
<p>Following are implementations of the above idea.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

// C++ program to print common elements in three arrays

#include &lt;iostream&gt;

using namespace std;



// This function prints common elements in ar1

void findCommon(int ar1[], int ar2[], int ar3[], int n1, int n2, int n3)

{

    // Initialize starting indexes for ar1[], ar2[] and ar3[]

    int i = 0, j = 0, k = 0;



    // Iterate through three arrays while all arrays have elements

    while (i &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; k &lt; n3)

    {

         // If x = y and y = z, print any of them and move ahead 

         // in all arrays

         if (ar1[i] == ar2[j] &amp;&amp; ar2[j] == ar3[k])

         {   cout &lt;&lt; ar1[i] &lt;&lt; " ";   i++; j++; k++; }



         // x &lt; y

         else if (ar1[i] &lt; ar2[j])

             i++;



         // y &lt; z

         else if (ar2[j] &lt; ar3[k])

             j++;



         // We reach here when x &gt; y and z &lt; y, i.e., z is smallest

         else

             k++;

    }

}



// Driver program to test above function

int main()

{

    int ar1[] = {1, 5, 10, 20, 40, 80};

    int ar2[] = {6, 7, 20, 80, 100};

    int ar3[] = {3, 4, 15, 20, 30, 70, 80, 120};

    int n1 = sizeof(ar1)/sizeof(ar1[0]);

    int n2 = sizeof(ar2)/sizeof(ar2[0]);

    int n3 = sizeof(ar3)/sizeof(ar3[0]);



    cout &lt;&lt; "Common Elements are ";

    findCommon(ar1, ar2, ar3, n1, n2, n3);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate" title="">

# Python function to print common elements in three sorted arrays

def findCommon(ar1, ar2, ar3, n1, n2, n3):

    

    # Initialize starting indexes for ar1[], ar2[] and ar3[]

    i, j, k = 0, 0, 0

    

    # Iterate through three arrays while all arrays have elements    

    while (i &lt; n1 and j &lt; n2 and k&lt; n3):

        

        # If x = y and y = z, print any of them and move ahead 

        # in all arrays

        if (ar1[i] == ar2[j] and ar2[j] == ar3[k]):

            print ar1[i],

            i += 1

            j += 1

            k += 1

        

        # x &lt; y    

        elif ar1[i] &lt; ar2[j]:

            i += 1

            

        # y &lt; z    

        elif ar2[j] &lt; ar3[k]:

            j += 1

        

        # We reach here when x &gt; y and z &lt; y, i.e., z is smallest    

        else:

            k += 1



# Driver program to check above function

ar1 = [1, 5, 10, 20, 40, 80]

ar2 = [6, 7, 20, 80, 100]

ar3 = [3, 4, 15, 20, 30, 70, 80, 120]

n1 = len(ar1)

n2 = len(ar2)

n3 = len(ar3)

print "Common elements are",

findCommon(ar1, ar2, ar3, n1, n2, n3)



# This code is contributed by __Devesh Agrawal__

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]; title: ; notranslate" title="">

// Java program to find common elements in three arrays

class FindCommon

{

    // This function prints common elements in ar1

    void findCommon(int ar1[], int ar2[], int ar3[])

    {

        // Initialize starting indexes for ar1[], ar2[] and ar3[]

        int i = 0, j = 0, k = 0;



        // Iterate through three arrays while all arrays have elements

        while (i &lt; ar1.length &amp;&amp; j &lt; ar2.length &amp;&amp; k &lt; ar3.length)

        {

             // If x = y and y = z, print any of them and move ahead

             // in all arrays

             if (ar1[i] == ar2[j] &amp;&amp; ar2[j] == ar3[k])

             {   System.out.print(ar1[i]+" ");   i++; j++; k++; }



             // x &lt; y

             else if (ar1[i] &lt; ar2[j])

                 i++;



             // y &lt; z

             else if (ar2[j] &lt; ar3[k])

                 j++;



             // We reach here when x &gt; y and z &lt; y, i.e., z is smallest

             else

                 k++;

        }

    }



    // Driver code to test above

    public static void main(String args[])

    {

        FindCommon ob = new FindCommon();



        int ar1[] = {1, 5, 10, 20, 40, 80};

        int ar2[] = {6, 7, 20, 80, 100};

        int ar3[] = {3, 4, 15, 20, 30, 70, 80, 120};



        System.out.print("Common elements are ");

        ob.findCommon(ar1, ar2, ar3);

    }

}

/*This code is contributed by Rajat Mishra */

</pre>
<p></p></div></div><br/>
Output:
<pre>Common Elements are 20 80</pre>
<p>Time complexity of the above solution is O(n1 + n2 + n3).  In worst case, the largest sized array may have all small elements and middle sized array has all middle elements.</p>
<p>This article is compiled by <strong>Rahul Gupta</strong> Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post45"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the smallest positive integer value that cannot be represented as sum of any subset of a given array

</button> <div id="post45" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the smallest positive integer value that cannot be represented as sum of any subset of a given array</h1>
</header>
<div class="entry-content">
<p>Given a sorted array (sorted in non-decreasing order) of positive numbers, find the smallest positive integer value that cannot be represented as sum of elements of any subset of given set. <span id="more-131169"></span><br/>
Expected time complexity is O(n).</p>
<p>Examples: </p>
<pre>

Input:  arr[] = {1, 3, 6, 10, 11, 15};

Output: 2



Input:  arr[] = {1, 1, 1, 1};

Output: 5



Input:  arr[] = {1, 1, 3, 4};

Output: 10



Input:  arr[] = {1, 2, 5, 10, 20, 40};

Output: 4



Input:  arr[] = {1, 2, 3, 4, 5, 6};

Output: 22

</pre>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>A <strong>Simple Solution</strong> is to start from value 1 and check all values one by one if they can sum to values in the given array. This solution is very inefficient as it reduces to <a href="http://www.geeksforgeeks.org/dynamic-programming-subset-sum-problem/" target="_blank">subset sum problem</a> which is a well known <a href="http://www.geeksforgeeks.org/np-completeness-set-1/" target="_blank">NP Complete Problem</a>.</p>
<p>We can solve this problem <strong>in O(n) time </strong>using a simple loop.  Let the input array be arr[0..n-1]. We initialize the result as 1 (smallest possible outcome) and traverse the given array.  Let the smallest element that cannot be represented by elements at indexes from 0 to (i-1) be ‘res’, there are following two possibilities when we consider element at index i:</p>
<p><em><strong>1) We decide that ‘res’ is the final result</strong></em>: If arr[i] is greater than ‘res’, then we found the gap which is ‘res’ because the elements after arr[i] are also going to be greater than ‘res’.</p>
<p><em><strong>2) The value of ‘res’ is incremented after considering arr[i]</strong></em>: The value of ‘res’ is incremented by arr[i] (why? If elements from 0 to (i-1) can represent 1 to ‘res-1′, then elements from 0 to i can represent from 1 to ‘res + arr[i] – 1′  be adding ‘arr[i]’ to all subsets that represent 1 to ‘res’)</p>
<p>Following is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate" title="">

// C++ program to find the smallest positive value that cannot be

// represented as sum of subsets of a given sorted array

#include &lt;iostream&gt;

using namespace std;



// Returns the smallest number that cannot be represented as sum

// of subset of elements from set represented by sorted array arr[0..n-1]

int findSmallest(int arr[], int n)

{

   int res = 1; // Initialize result



   // Traverse the array and increment 'res' if arr[i] is

   // smaller than or equal to 'res'.

   for (int i = 0; i &lt; n &amp;&amp; arr[i] &lt;= res; i++)

       res = res + arr[i];



   return res;

}



// Driver program to test above function

int main()

{

   int arr1[] = {1, 3, 4, 5};

   int n1 = sizeof(arr1)/sizeof(arr1[0]);

   cout &lt;&lt; findSmallest(arr1, n1) &lt;&lt; endl;



   int arr2[] = {1, 2, 6, 10, 11, 15};

   int n2 = sizeof(arr2)/sizeof(arr2[0]);

   cout &lt;&lt; findSmallest(arr2, n2) &lt;&lt; endl;



   int arr3[] = {1, 1, 1, 1};

   int n3 = sizeof(arr3)/sizeof(arr3[0]);

   cout &lt;&lt; findSmallest(arr3, n3) &lt;&lt; endl;



   int arr4[] = {1, 1, 3, 4};

   int n4 = sizeof(arr4)/sizeof(arr4[0]);

   cout &lt;&lt; findSmallest(arr4, n4) &lt;&lt; endl;



   return 0;

}

</pre>
<p>Output:
<pre>2

4

5

10

</pre>
<p>Time Complexity of above program is O(n). </p>
<p>This article is contributed by <strong>Rahul Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post46"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange array in alternating positive & negative items with O(1) extra space | Set 1

</button> <div id="post46" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange array in alternating positive &amp; negative items with O(1) extra space | Set 1</h1>
</header>
<div class="entry-content">
<p>Given an array of positive and negative numbers, arrange them in an alternate fashion such that every positive number is followed by negative and vice-versa maintaining the order of appearance.<span id="more-130935"></span><br/>
Number of positive and negative numbers need not be equal. If there are more positive numbers they appear at the end of the array. If there are more negative numbers, they too appear in the end of the array.</p>
<p>Example:
<pre>

Input:  arr[] = {1, 2, 3, -4, -1, 4}

Output: arr[] = {-4, 1, -1, 2, 3, 4}



Input:  arr[] = {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8}

output: arr[] = {-5, 5, -2, 2, -8, 4, 7, 1, 8, 0} </pre>
<p>This question has been asked at many places (See <a href="http://www.geeksforgeeks.org/amazon-interview-set-118-campus-internship/" target="_blank">this </a>and <a href="http://www.geeksforgeeks.org/amazon-interview-set-114-campus-internship/" target="_blank">this</a>)</p>
<p>The above problem can be easily solved if O(n) extra space is allowed. It becomes interesting due to the limitations that O(1) extra space and order of appearances.<br/>
The idea is to process array from left to right. While processing, find the first out of place element in the remaining unprocessed array.  An element is out of place if it is negative and at odd index, or it is positive and at even index.  Once we find an out of place element, we find the first element after it with opposite sign.  We right rotate the subarray between these two elements (including these two).</p>
<p>Following is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]; title: ; notranslate" title="">

/*  C++ program to rearrange positive and negative integers in alternate

    fashion while keeping the order of positive and negative numbers. */

#include &lt;iostream&gt;

#include &lt;assert.h&gt;

using namespace std;



// Utility function to right rotate all elements between [outofplace, cur]

void rightrotate(int arr[], int n, int outofplace, int cur)

{

    char tmp = arr[cur];

    for (int i = cur; i &gt; outofplace; i--)

        arr[i] = arr[i-1];

    arr[outofplace] = tmp;

}



void rearrange(int arr[], int n)

{

    int outofplace = -1;



    for (int index = 0; index &lt; n; index ++)

    {

        if (outofplace &gt;= 0)

        {

            // find the item which must be moved into the out-of-place

            // entry if out-of-place entry is positive and current

            // entry is negative OR if out-of-place entry is negative

            // and current entry is negative then right rotate

            //

            // [...-3, -4, -5, 6...] --&gt;   [...6, -3, -4, -5...]

            //      ^                          ^

            //      |                          |

            //     outofplace      --&gt;      outofplace

            //

            if (((arr[index] &gt;= 0) &amp;&amp; (arr[outofplace] &lt; 0))

                || ((arr[index] &lt; 0) &amp;&amp; (arr[outofplace] &gt;= 0)))

            {

                rightrotate(arr, n, outofplace, index);



                // the new out-of-place entry is now 2 steps ahead

                if (index - outofplace &gt; 2)

                    outofplace = outofplace + 2;

                else

                    outofplace = -1;

            }

        }





        // if no entry has been flagged out-of-place

        if (outofplace == -1)

        {

            // check if current entry is out-of-place

            if (((arr[index] &gt;= 0) &amp;&amp; (!(index &amp; 0x01)))

                || ((arr[index] &lt; 0) &amp;&amp; (index &amp; 0x01)))

            {

                outofplace = index;

            }

        }

    }

}



// A utility function to print an array 'arr[]' of size 'n'

void printArray(int arr[], int n)

{

    for (int i = 0; i &lt; n; i++)

      cout &lt;&lt; arr[i] &lt;&lt; " ";

    cout &lt;&lt; endl;

}



// Driver program to test abive function

int main()

{

    //int arr[n] = {-5, 3, 4, 5, -6, -2, 8, 9, -1, -4};

    //int arr[] = {-5, -3, -4, -5, -6, 2 , 8, 9, 1 , 4};

    //int arr[] = {5, 3, 4, 2, 1, -2 , -8, -9, -1 , -4};

    //int arr[] = {-5, 3, -4, -7, -1, -2 , -8, -9, 1 , -4};

    int arr[] = {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8};

    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Given array is \n";

    printArray(arr, n);



    rearrange(arr, n);



    cout &lt;&lt; "Rearranged array is \n";

    printArray(arr, n);



    return 0;

}

</pre>
<p>Output:
<pre>Given array is

-5 -2 5 2 4 7 1 8 0 -8

Rearranged array is

-5 5 -2 2 -8 4 7 1 8 0</pre>
<p><a href="http://www.geeksforgeeks.org/rearrange-array-in-alternating-positive-negative-items-with-o1-extra-space-set-2/">Rearrange array in alternating positive &amp; negative items with O(1) extra space | Set 2</a></p>
<p>This article is contributed by <a href="https://www.linkedin.com/pub/sandeep-joshi/97/57a/26b" target="_blank"><strong>Sandeep Joshi</strong></a>.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post47"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum Sum Path in Two Arrays

</button> <div id="post47" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum Sum Path in Two Arrays</h1>
</header>
<div class="entry-content">
<p>Given two sorted arrays such the arrays may have some common elements.  Find the sum of the maximum sum path to reach from beginning of any array to end of any of the two arrays.<span id="more-130266"></span>  We can switch from one array to another array only at common elements.</p>
<p>Expected time complexity is O(m+n) where m is the number of elements in ar1[] and n is the number of elements in ar2[].</p>
<p>Examples:
<pre>

Input:  ar1[] = {2, 3, 7, 10, 12}, ar2[] = {1, 5, 7, 8}

Output: 35

35 is sum of 1 + 5 + <strong>7</strong> + 10 + 12.

We start from first element of arr2 which is 1, then we

move to 5, then 7.  From 7, we switch to ar1 (7 is common)

and traverse 10 and 12.



Input:  ar1[] = {10, 12}, ar2 = {5, 7, 9}

Output: 22

22 is sum of 10 and 12.

Since there is no common element, we need to take all 

elements from the array with more sum.



Input:  ar1[] = {2, 3, 7, 10, 12, 15, 30, 34}

        ar2[] = {1, 5, 7, 8, 10, 15, 16, 19}

Output: 122

122 is sum of 1, 5, <strong>7</strong>, 8, <strong>10</strong>, 12, <strong>15</strong>, 30, 34

</pre>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong> </p>
<p>The idea is to do something similar to merge process of <a href="http://geeksquiz.com/merge-sort/" target="_blank">merge sort</a>. We need to calculate sums of elements between all common points for both arrays. Whenever we see a common point, we compare the two sums and add the maximum of two to the result. Following are detailed steps. </p>
<p>1) Initialize result as 0. Also initialize two variables sum1 and sum2 as 0.  Here sum1 and sum2 are used to store sum of element in ar1[] and ar2[] respectively.  These sums are between two common points.</p>
<p>2) Now run a loop to traverse elements of both arrays. While traversing compare current elements of ar1[] and ar2[].</p>
<p>    2.a) If current element of ar1[] is smaller than current element of ar2[], then update sum1, else if current element of ar2[] is smaller, then update sum2.</p>
<p>    2.b) If current element of ar1[] and ar2[] are same, then take the maximum of sum1 and sum2 and add it to the result. Also add the common element to the result.</p>
<p>Following is C++ implementation of above approach.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]; title: ; notranslate" title="">

#include&lt;iostream&gt;

using namespace std;



// Utility function to find maximum of two integers

int max(int x, int y) { return (x &gt; y)? x : y; }



// This function returns the sum of elements on maximum path

// from beginning to end

int maxPathSum(int ar1[], int ar2[], int m, int n)

{

    // initialize indexes for ar1[] and ar2[]

    int i = 0, j = 0;



    // Initialize result and current sum through ar1[] and ar2[].

    int  result = 0, sum1 = 0, sum2 = 0;



    // Below 3 loops are similar to merge in merge sort

    while (i &lt; m &amp;&amp; j &lt; n)

    {

        // Add elements of ar1[] to sum1

        if (ar1[i] &lt; ar2[j])

            sum1 += ar1[i++];



        // Add elements of ar2[] to sum2

        else if (ar1[i] &gt; ar2[j])

            sum2 += ar2[j++];



        else  // we reached a common point

        {

            // Take the maximum of two sums and add to result

            result += max(sum1, sum2);



            // Update sum1 and sum2 for elements after this

            // intersection point

            sum1 = 0, sum2 = 0;



            // Keep updating result while there are more common

            // elements

            while (i &lt; m &amp;&amp;  j &lt; n &amp;&amp; ar1[i] == ar2[j])

            {

                result = result + ar1[i++];

                j++;

            }

        }

    }



    // Add remaining elements of ar1[]

    while (i &lt; m)

        sum1  +=  ar1[i++];



    // Add remaining elements of ar2[]

    while (j &lt; n)

        sum2 +=  ar2[j++];



    // Add maximum of two sums of remaining elements

    result +=  max(sum1, sum2);



    return result;

}



// Driver program to test above function

int main()

{

    int ar1[]  = {2, 3, 7, 10, 12, 15, 30, 34};

    int ar2[] =  {1, 5, 7, 8, 10, 15, 16, 19};

    int m = sizeof(ar1)/sizeof(ar1[0]);

    int n = sizeof(ar2)/sizeof(ar2[0]);

    cout &lt;&lt; "Maximum sum path is " 

         &lt;&lt; maxPathSum(ar1, ar2, m, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]; title: ; notranslate" title="">

# Python program to find maximum sum path



# This function returns the sum of elements on maximum path from 

# beginning to end

def maxPathSum(ar1,ar2 , m , n):

    

    # initialize indexes for ar1[] and ar2[]

    i, j = 0, 0

    

    # Initialize result and current sum through ar1[] and ar2[]

    result, sum1, sum2= 0, 0, 0

    

    # Below 3 loops are similar to merge in merge sort

    while (i &lt; m and j &lt; n):

      

        # Add elements of ar1[] to sum1

        if ar1[i] &lt; ar2[j]:

            sum1 += ar1[i]

            i+=1

        

        # Add elements of ar2[] to sum1    

        elif ar1[i] &gt; ar2[j]:

            sum2 += ar2[j]

            j+=1

        

        else:   # we reached a common point

        

            # Take the maximum of two sums and add to result

            result+= max(sum1,sum2)

            

            # Update sum1 and sum2 for elements after this intersection point

            sum1, sum2 = 0, 0

            

            # Keep updating result while there are more common elements

            while (i &lt; m and j &lt; n and ar1[i]==ar2[j]):

                result += ar1[i]

                i+=1

                j+=1

    

    # Add remaining elements of ar1[]

    while i &lt; m:

        sum1 += ar1[i]

        i+=1

    # Add remaining elements of b[]

    while j &lt; n:

        sum2 += ar2[j]

        j+=1

    

    # Add maximum of two sums of remaining elements

    result += max(sum1,sum2)

    

    return result



# Driver function

ar1 = [2, 3, 7, 10, 12, 15, 30, 34]

ar2 = [1, 5, 7, 8, 10, 15, 16, 19]

m = len(ar1)

n = len(ar2)

print "Maximum sum path is", maxPathSum(ar1, ar2, m, n)



# This code is contributed by __Devesh Agrawal__

</pre>
<p></p></div></div><br/>
Output:
<pre>Maximum sum path is 122</pre>
<p>Time complexity: In every iteration of while loops, we process an element from either of the two arrays.  There are total m + n elements.  Therefore, time complexity is O(m+n).</p>
<p>This article is contributed by <strong>Piyush Gupta</strong>.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post48"> <span class="glyphicon glyphicon-collapse-down"></span>

Smallest subarray with sum greater than a given value

</button> <div id="post48" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Smallest subarray with sum greater than a given value</h1>
</header>
<div class="entry-content">
<p>Given an array of integers and a number x, find the smallest subarray with sum greater than the given value.<span id="more-128632"></span></p>
<pre>

Examples:

arr[] = {1, 4, 45, 6, 0, 19}

   x  =  51

Output: 3

Minimum length subarray is {4, 45, 6}



arr[] = {1, 10, 5, 2, 7}

   x  = 9

Output: 1

Minimum length subarray is {10}



arr[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250}

    x = 280

Output: 4

Minimum length subarray is {100, 1, 0, 200}

</pre>
<p>A <strong>simple solution </strong>is to use two nested loops. The outer loop picks a starting element, the inner loop considers all elements (on right side of current start) as ending element.  Whenever sum of elements between current start and end becomes more than the given number, update the result if current length is smaller than the smallest length so far.<br/>
Following is C++ implementation of simple approach.</p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]; title: ; notranslate" title="">

# include &lt;iostream&gt;

using namespace std;



// Returns length of smallest subarray with sum greater than x.

// If there is no subarray with given sum, then returns n+1

int smallestSubWithSum(int arr[], int n, int x)

{

    //  Initilize length of smallest subarray as n+1

     int min_len = n + 1;



     // Pick every element as starting point

     for (int start=0; start&lt;n; start++)

     {

          // Initialize sum starting with current start

          int curr_sum = arr[start];



          // If first element itself is greater

          if (curr_sum &gt; x) return 1;



          // Try different ending points for curremt start

          for (int end=start+1; end&lt;n; end++)

          {

              // add last element to current sum

              curr_sum += arr[end];



              // If sum becomes more than x and length of

              // this subarray is smaller than current smallest

              // length, update the smallest length (or result)

              if (curr_sum &gt; x &amp;&amp; (end - start + 1) &lt; min_len)

                 min_len = (end - start + 1);

          }

     }

     return min_len;

}



/* Driver program to test above function */

int main()

{

    int arr1[] = {1, 4, 45, 6, 10, 19};

    int x = 51;

    int n1 = sizeof(arr1)/sizeof(arr1[0]);

    cout &lt;&lt; smallestSubWithSum(arr1, n1, x) &lt;&lt; endl;



    int arr2[] = {1, 10, 5, 2, 7};

    int n2 = sizeof(arr2)/sizeof(arr2[0]);

    x  = 9;

    cout &lt;&lt; smallestSubWithSum(arr2, n2, x) &lt;&lt; endl;



    int arr3[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250};

    int n3 = sizeof(arr3)/sizeof(arr3[0]);

    x  = 280;

    cout &lt;&lt; smallestSubWithSum(arr3, n3, x) &lt;&lt; endl;



    return 0;

}

</pre>
<p>Output:
<pre>3

1

4 </pre>
<p>Time Complexity: Time complexity of the above approach is clearly O(n<sup>2</sup>).</p>
<p><strong>Efficient Solution:</strong> This problem can be solved in <strong>O(n) time</strong> using the idea used in <a href="http://www.geeksforgeeks.org/find-subarray-with-given-sum/" target="_blank">this </a>post. Thanks to Ankit and Nitin for suggesting this optimized solution.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]; title: ; notranslate" title="">

// O(n) solution for finding smallest subarray with sum

// greater than x

#include &lt;iostream&gt;

using namespace std;



// Returns length of smallest subarray with sum greater than x.

// If there is no subarray with given sum, then returns n+1

int smallestSubWithSum(int arr[], int n, int x)

{

    // Initialize current sum and minimum length

    int curr_sum = 0, min_len = n+1;



    // Initialize starting and ending indexes

    int start = 0, end = 0;

    while (end &lt; n)

    {

        // Keep adding array elements while current sum

        // is smaller than x

        while (curr_sum &lt;= x &amp;&amp; end &lt; n)

            curr_sum += arr[end++];



        // If current sum becomes greater than x.

        while (curr_sum &gt; x &amp;&amp; start &lt; n)

        {

            // Update minimum length if needed

            if (end - start &lt; min_len)

                min_len = end - start;



            // remove starting elements

            curr_sum -= arr[start++];

        }

    }

    return min_len;

}



/* Driver program to test above function */

int main()

{

    int arr1[] = {1, 4, 45, 6, 10, 19};

    int x = 51;

    int n1 = sizeof(arr1)/sizeof(arr1[0]);

    cout &lt;&lt; smallestSubWithSum(arr1, n1, x) &lt;&lt; endl;



    int arr2[] = {1, 10, 5, 2, 7};

    int n2 = sizeof(arr2)/sizeof(arr2[0]);

    x  = 9;

    cout &lt;&lt; smallestSubWithSum(arr2, n2, x) &lt;&lt; endl;



    int arr3[] = {1, 11, 100, 1, 0, 200, 3, 2, 1, 250};

    int n3 = sizeof(arr3)/sizeof(arr3[0]);

    x  = 280;

    cout &lt;&lt; smallestSubWithSum(arr3, n3, x);



    return 0;

}

</pre>
<p>Output:
<pre>3

1

4 </pre>
<p>This article is contributed by <strong>Rahul Jain</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post49"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the number of zeroes

</button> <div id="post49" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the number of zeroes</h1>
</header>
<div class="entry-content">
<p>Given an array of 1s and 0s which has all 1s first followed by all 0s.  Find the number of 0s.  Count the number of zeroes in the given array.<span id="more-128171"></span></p>
<p>Examples:</p>
<pre>

Input: arr[] = {1, 1, 1, 1, 0, 0}

Output: 2



Input: arr[] = {1, 0, 0, 0, 0}

Output: 4



Input: arr[] = {0, 0, 0}

Output: 3



Input: arr[] = {1, 1, 1, 1}

Output: 0

</pre>
<div id="practice"></div>
<p>A <strong>simple solution</strong> is to traverse the input array.  As soon as we find a 0, we return n – index of first 0.  Here n is number of elements in input array.  Time complexity of this solution would be O(n).</p>
<p>Since the input array is sorted, we can use <a href="http://www.geeksforgeeks.org/count-number-of-occurrences-in-a-sorted-array/" target="_blank"><strong>Binary Search</strong> to find the first occurrence</a> of 0.  Once we have index of first element, we can return count as n – index of first zero.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]; title: ; notranslate" title="">

// A divide and conquer solution to find count of zeroes in an array

// where all 1s are present before all 0s

#include &lt;stdio.h&gt;



/* if 0 is present in arr[] then returns the index of FIRST occurrence

   of 0 in arr[low..high], otherwise returns -1 */

int firstZero(int arr[], int low, int high)

{

    if (high &gt;= low)

    {

        // Check if mid element is first 0

        int mid = low + (high - low)/2;

        if (( mid == 0 || arr[mid-1] == 1) &amp;&amp; arr[mid] == 0)

            return mid;



        if (arr[mid] == 1)  // If mid element is not 0

            return firstZero(arr, (mid + 1), high);

        else  // If mid element is 0, but not first 0

            return firstZero(arr, low, (mid -1));

    }

    return -1;

}



// A wrapper over recursive function firstZero()

int countZeroes(int arr[], int n)

{

    // Find index of first zero in given array

    int first = firstZero(arr, 0, n-1);



    // If 0 is not present at all, return 0

    if (first == -1)

        return 0;



    return (n - first);

}



/* Driver program to check above functions */

int main()

{

    int arr[] =   {1, 1, 1, 0, 0, 0, 0, 0};

    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Count of zeroes is %d", countZeroes(arr, n));

    return 0;

}

</pre>
<p>Output:
<pre>Count of zeroes is 5 </pre>
<p>Time Complexity: O(Logn) where n is number of elements in arr[].</p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post50"> <span class="glyphicon glyphicon-collapse-down"></span>

Count all possible groups of size 2 or 3 that have sum as multiple of 3

</button> <div id="post50" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count all possible groups of size 2 or 3 that have sum as multiple of 3</h1>
</header>
<div class="entry-content">
<p>Given an unsorted integer (positive values only) array of size ‘n’, we can form a group of two or three, <span id="more-127707"></span>the group should be such that the sum of all elements in that group is a multiple of 3. Count all possible number of groups that can be generated in this way.</p>
<pre>

Input: arr[] = {3, 6, 7, 2, 9}

Output: 8

// Groups are {3,6}, {3,9}, {9,6}, {7,2}, {3,6,9},

//            {3,7,2}, {7,2,6}, {7,2,9}





Input: arr[] = {2, 1, 3, 4}

Output: 4

// Groups are {2,1}, {2,4}, {2,1,3}, {2,4,3}

</pre>
<div id="practice"></div>
<p>The idea is to see remainder of every element when divided by 3. A set of elements can form a group only if sun of their remainders is multiple of 3.  Since the task is to enumerate groups, we count all elements with different remainders.</p>
<pre>

1. Hash all elements in a count array based on remainder, i.e, 

   for all elements a[i], do c[a[i]%3]++;

2. Now c[0] contains the number of elements which when divided

   by 3 leave remainder 0 and similarly c[1] for remainder 1 

   and c[2] for 2.

3. Now for group of 2, we have 2 possibilities

   a. 2 elements of remainder 0 group. Such possibilities are 

      c[0]*(c[0]-1)/2

   b. 1 element of remainder 1 and 1 from remainder 2 group

      Such groups are c[1]*c[2].

4. Now for group of 3,we have 4 possibilities

   a. 3 elements from remainder group 0.

      No. of such groups are c[0]C3

   b. 3 elements from remainder group 1.

      No. of such groups are c[1]C3

   c. 3 elements from remainder group 2.

      No. of such groups are c[2]C3

   d. 1 element from each of 3 groups. 

      No. of such groups are c[0]*c[1]*c[2].

5. Add all the groups in steps 3 and 4 to obtain the result.

</pre>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]; title: ; notranslate" title="">

#include&lt;stdio.h&gt;



// Returns count of all possible groups that can be formed from elements

// of a[].

int findgroups(int arr[], int n)

{

    // Create an array C[3] to store counts of elements with remainder

    // 0, 1 and 2.  c[i] would store count of elements with remainder i

    int c[3] = {0}, i;



    int res = 0; // To store the result



    // Count elements with remainder 0, 1 and 2

    for (i=0; i&lt;n; i++)

        c[arr[i]%3]++;



    // Case 3.a: Count groups of size 2 from 0 remainder elements

    res += ((c[0]*(c[0]-1))&gt;&gt;1);



    // Case 3.b: Count groups of size 2 with one element with 1

    // remainder and other with 2 remainder

    res += c[1] * c[2];



    // Case 4.a: Count groups of size 3 with all 0 remainder elements

    res += (c[0] * (c[0]-1) * (c[0]-2))/6;



    // Case 4.b: Count groups of size 3 with all 1 remainder elements

    res += (c[1] * (c[1]-1) * (c[1]-2))/6;



    // Case 4.c: Count groups of size 3 with all 2 remainder elements

    res += ((c[2]*(c[2]-1)*(c[2]-2))/6);



    // Case 4.c: Count groups of size 3 with different remainders

    res += c[0]*c[1]*c[2];



    // Return total count stored in res

    return res;

}



// Driver program to test above functions

int main()

{

    int arr[] = {3, 6, 7, 2, 9};

    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Required number of groups are %d\n", findgroups(arr,n));

    return 0;

}</pre>
<p>Output:
<pre>Required number of groups are 8</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<div id="company_tags"></div>
<p>This article is contributed by <a href="http://in.linkedin.com/in/amitjainju" target="_blank">Amit Jain</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post51"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange an array so that arr[i] becomes arr[arr[i]] with O(1) extra space

</button> <div id="post51" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange an array so that arr[i] becomes arr[arr[i]] with O(1) extra space</h1>
</header>
<div class="entry-content">
<p>Given an array <em>arr[]</em> of size <em>n</em> where every element is in range from <em>0</em> to <em>n-1</em>. Rearrange the given array so that <em>arr[i]</em> becomes <em>arr[arr[i]]</em>. <span id="more-127284"></span> This should be done with <em>O(1)</em> extra space.</p>
<p>Examples:
<pre>

Input: arr[]  = {3, 2, 0, 1}

Output: arr[] = {1, 0, 3, 2}



Input: arr[] = {4, 0, 2, 1, 3}

Output: arr[] = {3, 4, 2, 0, 1}



Input: arr[] = {0, 1, 2, 3}

Output: arr[] = {0, 1, 2, 3}</pre>
<p>If the extra space condition is removed, the question becomes very easy.  The main part of the question is to do it without extra space.<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=417" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
The credit for following solution goes to<a href="http://www.careercup.com/question?id=4909367207919616" target="_blank"> Ganesh Ram Sundaram </a>.  Following are the steps. </p>
<p><strong>1)</strong> Increase every array element arr[i] by (arr[arr[i]] % n)*n.<br/>
<strong>2)</strong> Divide every element by n.</p>
<pre>

Let us understand the above steps by an example array {3, 2, 0, 1}

In first step, every value is incremented by (arr[arr[i]] % n)*n

After first step array becomes {7, 2, 12, 9}. 

<em><strong>The important thing is, after the increment operation

of first step, every element holds both old values and new values. 

Old value can be obtained by arr[i]%n and new value can be obtained

by arr[i]/n.</strong></em>



In second step, all elements are updated to new or output values 

by doing arr[i] = arr[i]/n.

After second step, array becomes {1, 0, 3, 2}

</pre>
<p>Following is C++ implementation of the above approach.</p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15]; title: ; notranslate" title="">

#include &lt;iostream&gt;

using namespace std;



// The function to rearrange an array in-place so that arr[i]

// becomes arr[arr[i]].

void rearrange(int arr[], int n)

{

    // First step: Increase all values by (arr[arr[i]]%n)*n

    for (int i=0; i &lt; n; i++)

        arr[i] += (arr[arr[i]]%n)*n;



    // Second Step: Divide all values by n

    for (int i=0; i&lt;n; i++)

        arr[i] /= n;

}



// A utility function to print an array of size n

void printArr(int arr[], int n)

{

    for (int i = 0; i &lt; n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";

    cout &lt;&lt; endl;

}





/* Driver program to test above functions*/

int main()

{

    int arr[] = {3, 2, 0, 1};

    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Given array is \n";

    printArr(arr, n);



    rearrange(arr, n);



    cout &lt;&lt; "Modified array is \n";

    printArr(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>Given array is

3 2 0 1

Modified array is

1 0 3 2</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>The problem with above solution is, it may cause overflow.  </p>
<p><strong>Please see below post for a better solution:<br/>
<a href="http://www.geeksforgeeks.org/rearrange-array-arrj-becomes-arri-j/">Rearrange an array such that ‘arr[j]’ becomes ‘i’ if ‘arr[i]’ is ‘j’</a></strong></p>
<p>This article is contributed by <strong>Himanshu Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post52"> <span class="glyphicon glyphicon-collapse-down"></span>

Move all zeroes to end of array

</button> <div id="post52" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Move all zeroes to end of array</h1>
</header>
<div class="entry-content">
<p>Given an array of random numbers, Push all the zero’s of a given array to the end of the array. <span id="more-123493"></span>For example, if the given arrays is {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0}, it should be changed to {1, 9, 8, 4, 2, 7, 6, 0, 0, 0, 0}.  The order of all other elements should be same. Expected time complexity is O(n) and extra space is O(1).<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=291" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
There can be many ways to solve this problem.  Following is a simple and interesting way to solve this problem.<br/>
Traverse the given array ‘arr’ from left to right.  While traversing, maintain count of non-zero elements in array. Let the count be ‘count’. For every non-zero element arr[i], put the element at ‘arr[count]’ and increment ‘count’.  After complete traversal, all non-zero elements have already been shifted to front end and ‘count’ is set as index of first 0. Now all we need to do is that run a loop which makes all elements zero from ‘count’ till end of the array.</p>
<p>Below is C++ implementation of the above approach. </p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate" title="">

// A C++ program to move all zeroes at the end of array

#include &lt;iostream&gt;

using namespace std;



// Function which pushes all zeros to end of an array.

void pushZerosToEnd(int arr[], int n)

{

    int count = 0;  // Count of non-zero elements



    // Traverse the array. If element encountered is non-

    // zero, then replace the element at index 'count' 

    // with this element

    for (int i = 0; i &lt; n; i++)

        if (arr[i] != 0)

            arr[count++] = arr[i]; // here count is 

                                   // incremented



    // Now all non-zero elements have been shifted to 

    // front and  'count' is set as index of first 0. 

    // Make all elements 0 from count to end.

    while (count &lt; n)

        arr[count++] = 0;

}



// Driver program to test above function

int main()

{

    int arr[] = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9};

    int n = sizeof(arr) / sizeof(arr[0]);

    pushZerosToEnd(arr, n);

    cout &lt;&lt; "Array after pushing all zeros to end of array :\n";

    for (int i = 0; i &lt; n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate" title="">

/* Java program to push zeroes to back of array */

import java.io.*;



class PushZero

{

    // Function which pushes all zeros to end of an array.

    static void pushZerosToEnd(int arr[], int n)

    {

        int count = 0;  // Count of non-zero elements



        // Traverse the array. If element encountered is

        // non-zero, then replace the element at index 'count'

        // with this element

        for (int i = 0; i &lt; n; i++)

            if (arr[i] != 0)

                arr[count++] = arr[i]; // here count is

                                       // incremented



        // Now all non-zero elements have been shifted to

        // front and 'count' is set as index of first 0.

        // Make all elements 0 from count to end.

        while (count &lt; n)

            arr[count++] = 0;

    }



    /*Driver function to check for above functions*/

    public static void main (String[] args)

    {

        int arr[] = {1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9};

        int n = arr.length;

        pushZerosToEnd(arr, n);

        System.out.println("Array after pushing zeros to the back: ");

        for (int i=0; i&lt;n; i++)

            System.out.print(arr[i]+" ");

    }

}

/* This code is contributed by Devesh Agrawal */

</pre>
<p></p></div></div><br/>
Output:
<pre>Array after pushing all zeros to end of array :

1 9 8 4 2 7 6 9 0 0 0 0</pre>
<p><strong>Time Complexity:</strong> O(n) where n is number of elements in input array.</p>
<p><strong>Auxiliary Space: </strong>O(1)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/0jXTju134Hw?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by<strong> <a href="https://www.facebook.com/chandra.prakash.52643?fref=ts" target="_blank">Chandra Prakash</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post53"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the Increasing subsequence of length three with maximum product

</button> <div id="post53" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the Increasing subsequence of length three with maximum product</h1>
</header>
<div class="entry-content">
<p>Given a sequence of non-negative integers, find the subsequence of length 3 having maximum product with the numbers of the subsequence being in ascending order. <span id="more-119800"></span></p>
<p>Examples:
<pre> 

Input: 

arr[] = {6, 7, 8, 1, 2, 3, 9, 10} 

Output: 

8 9 10



Input: 

arr[] = {1, 5, 10, 8, 9}

Output: 5 8 9</pre>
<p>Since we want to find the maximum product, we need to find following two things for every element in the given sequence:<br/>
<strong>LSL:</strong> The largest smaller element on left of given element<br/>
<strong>LGR:</strong> The largest greater element on right of given element.</p>
<p>Once we find LSL and LGR for an element, we can find  the product of element with its LSL and LGR (if they both exist).   We calculate this product for every element and return maximum of all products.</p>
<p>A <strong>simple method</strong> is to use nested loops. The outer loop traverses every element in sequence. Inside the outer loop, run two inner loops (one after other) to find LSL and LGR of current element. Time complexity of this method is O(n<sup>2</sup>). </p>
<p>We can do this <strong>in O(nLogn) time</strong>.  For simplicity, let us first create two arrays LSL[] and LGR[] of size n each where n is number of elements in input array arr[]. The main task is to fill two arrays LSL[] and LGR[].  Once we have these two arrays filled, all we need to find maximum product LSL[i]*arr[i]*LGR[i] where 0 &lt; i &lt; n-1 (Note that LSL[i] doesn't exist for i = 0 and LGR[i] doesn't exist for i = n-1).

We can <strong>fill LSL[]</strong> in O(nLogn) time. The idea is to use a Balanced Binary Search Tree like AVL. We start with empty AVL tree, insert the leftmost element in it.   Then we traverse the input array starting from the second element to second last element. For every element currently being traversed, we find the floor of it in AVL tree. If floor exists, we store the floor in LSL[], otherwise we store NIL. After storing the floor, we insert the current element in the AVL tree. </p>
<p>We can <strong>fill LGR[]</strong> in O(n) time. The idea is similar to <a href="http://www.geeksforgeeks.org/replace-every-element-with-the-greatest-on-right-side/" target="_blank">this </a>post. We traverse from right side and keep track of the largest element. If the largest element is greater than current element, we store it in LGR[], otherwise we store NIL. </p>
<p>Finally, we run a O(n) loop and <strong>return maximum of LSL[i]*arr[i]*LGR[i]</strong></p>
<p>Overall complexity of this approach is O(nLogn) + O(n) + O(n) which is O(nLogn).  Auxiliary space required is O(n). Note that we can avoid space required for LSL, we can find and use LSL values in final loop. </p>
<p>This article is contributed by<a href=" http://in.linkedin.com/in/amitjainju/" target="_blank"> <strong>Amit Jain</strong></a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post54"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange positive and negative numbers in O(n) time and O(1) extra space

</button> <div id="post54" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange positive and negative numbers in O(n) time and O(1) extra space</h1>
</header>
<div class="entry-content">
<p>An array contains both positive and negative numbers in random order. Rearrange the array elements so that positive and negative numbers are placed alternatively. <span id="more-10982"></span>Number of positive and negative numbers need not be equal. If there are more positive numbers they appear at the end of the array. If there are more negative numbers, they too appear in the end of the array.</p>
<p>For example, if the input array is [-1, 2, -3, 4, 5, 6, -7, 8, 9], then the output should be [9, -7, 8, -3, 5, -1, 2, 4, 6]</p>
<p>The solution is to first separate positive and negative numbers using partition process of QuickSort. In the partition process, consider 0 as value of pivot element so that all negative numbers are placed before positive numbers. Once negative and positive numbers are separated, we start from the first negative number and first positive number, and swap every alternate negative number with next positive number. </p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]; title: ; notranslate" title="">

// A C++ program to put positive numbers at even indexes (0, 

// 2, 4,..) and negative numbers at odd indexes (1, 3, 5, ..)

#include &lt;stdio.h&gt;



// prototype for swap

void swap(int *a, int *b);



// The main function that rearranges elements of given array. 

// It puts  positive elements at even indexes (0, 2, ..) and 

// negative numbers at odd indexes (1, 3, ..).

void rearrange(int arr[], int n)

{

    // The following few lines are similar to partition process

    // of QuickSort.  The idea is to consider 0 as pivot and

    // divide the array around it.

    int i = -1;

    for (int j = 0; j &lt; n; j++)

    {

        if (arr[j] &lt; 0)

        {

            i++;

            swap(&amp;arr[i], &amp;arr[j]);

        }

    }



    // Now all positive numbers are at end and negative numbers

    // at the beginning of array. Initialize indexes for starting

    // point of positive and negative numbers to be swapped

    int pos = i+1, neg = 0;



    // Increment the negative index by 2 and positive index by 1,

    // i.e., swap every alternate negative number with next 

    // positive number

    while (pos &lt; n &amp;&amp; neg &lt; pos &amp;&amp; arr[neg] &lt; 0)

    {

        swap(&amp;arr[neg], &amp;arr[pos]);

        pos++;

        neg += 2;

    }

}



// A utility function to swap two elements

void swap(int *a, int *b)

{

    int temp = *a;

    *a = *b;

    *b = temp;

}



// A utility function to print an array

void printArray(int arr[], int n)

{

    for (int i = 0; i &lt; n; i++)

        printf("%4d ", arr[i]);

}



// Driver program to test above functions

int main()

{

    int arr[] = {-1, 2, -3, 4, 5, 6, -7, 8, 9};

    int n = sizeof(arr)/sizeof(arr[0]);

    rearrange(arr, n);

    printArray(arr, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate" title="">

// A JAVA program to put positive numbers at even indexes

// (0, 2, 4,..) and negative numbers at odd indexes (1, 3,

// 5, ..)

import java.io.*;



class Alternate {



    // The main function that rearranges elements of given

    // array.  It puts positive elements at even indexes (0,

    // 2, ..) and negative numbers at odd indexes (1, 3, ..).

    static void rearrange(int arr[], int n)

    {

        // The following few lines are similar to partition

        // process of QuickSort.  The idea is to consider 0

        // as pivot and divide the array around it.

        int i = -1, temp = 0;

        for (int j = 0; j &lt; n; j++)

        {

            if (arr[j] &lt; 0)

            {

                i++;

                temp = arr[i];

                arr[i] = arr[j];

                arr[j] = temp;

            }

        }



        // Now all positive numbers are at end and negative numbers at

        // the beginning of array. Initialize indexes for starting point

        // of positive and negative numbers to be swapped

        int pos = i+1, neg = 0;



        // Increment the negative index by 2 and positive index by 1, i.e.,

        // swap every alternate negative number with next positive number

        while (pos &lt; n &amp;&amp; neg &lt; pos &amp;&amp; arr[neg] &lt; 0)

        {

            temp = arr[neg];

            arr[neg] = arr[pos];

            arr[pos] = temp;

            pos++;

            neg += 2;

        }

    }



    // A utility function to print an array

    static void printArray(int arr[], int n)

    {

        for (int i = 0; i &lt; n; i++)

            System.out.print(arr[i] + "   ");

    }



    /*Driver function to check for above functions*/

    public static void main (String[] args)

    {

        int arr[] = {-1, 2, -3, 4, 5, 6, -7, 8, 9};

        int n = arr.length;

        rearrange(arr,n);

        System.out.println("Array after rearranging: ");

        printArray(arr,n);

    }

}

/*This code is contributed by Devesh Agrawal*/

</pre>
<p></p></div></div><br/>
Output:
<pre>    4   -3    5   -1    6   -7    2    8    9</pre>
<p><strong>Time Complexity:</strong> O(n) where n is number of elements in given array.<br/>
<strong>Auxiliary Space: </strong>O(1)</p>
<p>Note that the partition process changes relative order of elements.</p>
<p>This article is compiled by <strong>Abhay Rathi</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p>If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post55"> <span class="glyphicon glyphicon-collapse-down"></span>

Stock Buy Sell to Maximize Profit

</button> <div id="post55" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Stock Buy Sell to Maximize Profit</h1>
</header>
<div class="entry-content">
<p>The cost of a stock on each day is given in an array, find the max profit that you can make by buying and selling in those days. <span id="more-116283"></span> For example, if the given array is {100, 180, 260, 310, 40, 535, 695}, the maximum profit can earned by buying on day 0, selling on day 3. Again buy on day 4 and sell on day 6.  If the given array of prices is sorted in decreasing order, then profit cannot be earned at all.<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=371" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
If we are allowed to buy and sell only once, then we can use following algorithm.<a href="http://www.geeksforgeeks.org/maximum-difference-between-two-elements/" target="_blank"> Maximum difference between two elements</a>. Here we are allowed to buy and sell multiple times.  Following is algorithm for this problem.<br/>
<strong>1.</strong> Find the local minima and store it as starting index. If not exists, return.<br/>
<strong>2. </strong>Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.<br/>
<strong>3.</strong> Update the solution (Increment count of buy sell pairs)<br/>
<strong>4.</strong> Repeat the above steps if end is not reached.</p>
<pre class="brush: cpp; highlight: [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate" title="">

// Program to find best buying and selling days

#include &lt;stdio.h&gt;



// solution structure

struct Interval

{

    int buy;

    int sell;

};



// This function finds the buy sell schedule for maximum profit

void stockBuySell(int price[], int n)

{

    // Prices must be given for at least two days

    if (n == 1)

        return;



    int count = 0; // count of solution pairs



    // solution vector

    Interval sol[n/2 + 1];



    // Traverse through given price array

    int i = 0;

    while (i &lt; n-1)

    {

        // Find Local Minima. Note that the limit is (n-2) as we are

        // comparing present element to the next element. 

        while ((i &lt; n-1) &amp;&amp; (price[i+1] &lt;= price[i]))

            i++;



        // If we reached the end, break as no further solution possible

        if (i == n-1)

            break;



        // Store the index of minima

        sol[count].buy = i++;



        // Find Local Maxima.  Note that the limit is (n-1) as we are

        // comparing to previous element

        while ((i &lt; n) &amp;&amp; (price[i] &gt;= price[i-1]))

            i++;



        // Store the index of maxima

        sol[count].sell = i-1;



        // Increment count of buy/sell pairs

        count++;

    }



    // print solution

    if (count == 0)

        printf("There is no day when buying the stock will make profit\n");

    else

    {

       for (int i = 0; i &lt; count; i++)

          printf("Buy on day: %d\t Sell on day: %d\n", sol[i].buy, sol[i].sell);

    }



    return;

}



// Driver program to test above functions

int main()

{

    // stock prices on consecutive days

    int price[] = {100, 180, 260, 310, 40, 535, 695};

    int n = sizeof(price)/sizeof(price[0]);



    // fucntion call

    stockBuySell(price, n);



    return 0;

}

</pre>
<p>Output:
<pre>Buy on day : 0   Sell on day: 3

Buy on day : 4   Sell on day: 6</pre>
<p><strong>Time Complexity:</strong> The outer loop runs till i becomes n-1.  The inner two loops increment value of i in every iteration.  So overall time complexity is O(n)</p>
<p>This article is compiled by <a href="https://www.facebook.com/aasshishh?fref=ts">Ashish Anand</a> and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post56"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the maximum repeating number in O(n) time and O(1) extra space

</button> <div id="post56" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the maximum repeating number in O(n) time and O(1) extra space</h1>
</header>
<div class="entry-content">
<p>Given an array of size <em>n</em>, the array contains numbers in range from 0 to <em>k-1</em> where <em>k</em> is a positive integer and <em>k &lt;= n.</em> Find the maximum repeating number in this array.<span id="more-116144"></span>  For example, let <em>k</em> be 10 the given array be <em>arr[] </em>= {1, 2, 2, 2, 0, 2, 0, 2, 3, 8, 0, 9, 2, 3}, the maximum repeating number would be 2.  Expected time complexity is <em>O(n) </em>and extra space allowed is <em>O(1)</em>.  Modifications to array are allowed.  </p>
<p>The <strong>naive approach </strong>is to run two loops, the outer loop picks an element one by one, the inner loop counts number of occurrences of the picked element. Finally return the element with maximum count. Time complexity of this approach is<em> O(n^2)</em>.</p>
<p>A <strong>better approach</strong> is to create a count array of size k and initialize all elements of <em>count[] </em>as 0.  Iterate through all elements of input array, and for every element <em>arr[i]</em>, increment <em>count[arr[i]]</em>. Finally, iterate through <em>count[]</em> and return the index with maximum value.  This approach takes O(n) time, but requires O(k) space.</p>
<p>Following is the <strong><em>O(n)</em> time and<em> O(1)</em> extra space</strong> approach. Let us understand the approach with a simple example where<em> arr[]</em> = {2, 3, 3, 5, 3, 4, 1, 7}, <em>k </em>= 8, <em>n </em>= 8 (number of elements in arr[]).</p>
<p><strong>1)</strong> Iterate though input array <em>arr[]</em>, for every element <em>arr[i]</em>, increment <em>arr[arr[i]%k]</em> by <em>k</em> (<em>arr[]</em> becomes {2, 11, 11, 29, 11, 12, 1, 15 })</p>
<p><strong>2)</strong> Find the maximum value in the modified array (maximum value is 29). Index of the maximum value is the maximum repeating element (index of 29 is 3).</p>
<p><strong>3)</strong> If we want to get the original array back, we can iterate through the array one more time and do <em>arr[i] = arr[i] % k</em> where <em>i </em>varies from 0 to <em>n-1</em>.</p>
<p><em>How does the above algorithm work? </em>Since we use <em>arr[i]%k</em> as index and add value <em>k</em> at the index <em>arr[i]%k</em>, the index which is equal to maximum repeating element will have the maximum value in the end. Note that <em>k </em>is added maximum number of times at the index equal to maximum repeating element and all array elements are smaller than <em>k.</em></p>
<p>Following is C++ implementation of the above algorithm.<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate" title="">

// C++ program to find the maximum repeating number



#include&lt;iostream&gt;

using namespace std;



// Returns maximum repeating element in arr[0..n-1].

// The array elements are in range from 0 to k-1

int maxRepeating(int* arr, int n, int k)

{

    // Iterate though input array, for every element

    // arr[i], increment arr[arr[i]%k] by k

    for (int i = 0; i&lt; n; i++)

        arr[arr[i]%k] += k;



    // Find index of the maximum repeating element

    int max = arr[0], result = 0;

    for (int i = 1; i &lt; n; i++)

    {

        if (arr[i] &gt; max)

        {

            max = arr[i];

            result = i;

        }

    }



    /* Uncomment this code to get the original array back

       for (int i = 0; i&lt; n; i++)

          arr[i] = arr[i]%k; */



    // Return index of the maximum element

    return result;

}



// Driver program to test above function

int main()

{

    int arr[] = {2, 3, 3, 5, 3, 4, 1, 7};

    int n = sizeof(arr)/sizeof(arr[0]);

    int k = 8;



    cout &lt;&lt; "The maximum repeating number is " &lt;&lt;

         maxRepeating(arr, n, k) &lt;&lt; endl;



    return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post57"> <span class="glyphicon glyphicon-collapse-down"></span>

Merge Overlapping Intervals

</button> <div id="post57" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Merge Overlapping Intervals</h1>
</header>
<div class="entry-content">
<p>Given a set of time intervals in any order, merge all overlapping intervals into one and output the result which should have only mutually exclusive intervals. Let the intervals  be represented as pairs of integers for simplicity. <span id="more-116020"></span><br/>
For example, let the given set of intervals be  {{1,3}, {2,4}, {5,7}, {6,8} }. The intervals {1,3} and {2,4} overlap with each other, so they should be merged and become {1, 4}. Similarly {5, 7} and {6, 8} should be merged and become {5, 8}<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=126" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
Write a function which produces the set of merged intervals for the given set of intervals. </p>
<p>A <strong>simple approach</strong> is to start from the first interval and compare it with all other intervals for overlapping, if it overlaps with any other interval, then remove the other interval from list and merge the other into the first interval. Repeat the same steps for remaining intervals after first. This approach cannot be implemented in better than O(n^2) time.</p>
<p>An <strong>efficient approach</strong> is to first sort the intervals according to starting time.  Once we have the sorted intervals, we can combine all intervals in a linear traversal.  The idea is, in sorted array of intervals, if interval[i] doesn’t overlap with interval[i-1], then interval[i+1] cannot overlap with interval[i-1] because starting time of interval[i+1] must be greater than or equal to interval[i]. Following is the detailed step by step algorithm.</p>
<pre>

<strong>1.</strong> Sort the intervals based on increasing order of 

    starting time.

<strong>2. </strong>Push the first interval on to a stack.

<strong>3. </strong>For each interval do the following

   <strong>a. </strong>If the current interval does not overlap with the stack 

       top, push it.

   <strong>b. </strong>If the current interval overlaps with stack top and ending

       time of current interval is more than that of stack top, 

       update stack top with the ending  time of current interval.

<strong>4.</strong> At the end stack contains the merged intervals. </pre>
<p>Below is a C++ implementation of the above approach.</p>
<pre class="brush: cpp; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]; title: ; notranslate" title="">

// A C++ program for merging overlapping intervals

#include&lt;bits/stdc++.h&gt;

using namespace std;



// An interval has start time and end time

struct Interval

{

    int start, end;

};



// Compares two intervals according to their staring time.

// This is needed for sorting the intervals using library

// function std::sort(). See http://goo.gl/iGspV

bool compareInterval(Interval i1, Interval i2)

{

    return (i1.start &lt; i2.start);

}



// The main function that takes a set of intervals, merges

// overlapping intervals and prints the result

void mergeIntervals(Interval arr[], int n)

{

    // Test if the given set has at least one interval

    if (n &lt;= 0)

        return;



    // Create an empty stack of intervals

    stack&lt;Interval&gt; s;



    // sort the intervals in increasing order of start time

    sort(arr, arr+n, compareInterval);



    // push the first interval to stack

    s.push(arr[0]);



    // Start from the next interval and merge if necessary

    for (int i = 1 ; i &lt; n; i++)

    {

        // get interval from stack top

        Interval top = s.top();



        // if current interval is not overlapping with stack top,

        // push it to the stack

        if (top.end &lt; arr[i].start)

            s.push(arr[i]);



        // Otherwise update the ending time of top if ending of current

        // interval is more

        else if (top.end &lt; arr[i].end)

        {

            top.end = arr[i].end;

            s.pop();

            s.push(top);

        }

    }



    // Print contents of stack

    cout &lt;&lt; "\n The Merged Intervals are: ";

    while (!s.empty())

    {

        Interval t = s.top();

        cout &lt;&lt; "[" &lt;&lt; t.start &lt;&lt; "," &lt;&lt; t.end &lt;&lt; "] ";

        s.pop();

    }

    return;

}



// Driver program

int main()

{

    Interval arr[] =  { {6,8}, {1,9}, {2,4}, {4,7} };

    int n = sizeof(arr)/sizeof(arr[0]);

    mergeIntervals(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre> The Merged Intervals are: [1,9] </pre>
<p>Time complexity of the method is O(nLogn) which is for sorting.  Once the array of intervals is sorted, merging takes linear time.</p>
<p><u><strong>A  O(n Log n) and O(1) Extra Space Solution</strong></u><br/>
The above solution requires O(n) extra space for stack.  We can avoid use of extra space by doing merge operations in-place. Below are detailed steps.
<pre>

1) Sort all intervals in decreasing order of start time.

2) Traverse sorted intervals starting from first interval, 

   do following for every interval.

      a) If current interval is not first interval and it 

         overlaps with previous interval, then merge it with

         previous interval. Keep doing it while the interval

         overlaps with the previous one.         

      b) Else add current interval to output list of intervals.</pre>
<p>Note that if intervals are sorted by decreasing order of start times, we can quickly check if intervals overlap or not by comparing start time of previous interval with end time of current interval.</p>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate" title="">

// C++ program to merge overlapping Intervals in

// O(n Log n) time and O(1) extra space.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// An Interval

struct Interval

{

    int s, e;

};



// Function used in sort

bool mycomp(Interval a, Interval b)

{   return a.s &gt; b.s; }



void mergeIntervals(Interval arr[], int n)

{

    // Sort Intervals in decreasing order of

    // start time

    sort(arr, arr+n, mycomp);



    int index = 0; // Stores index of last element

    // in output array (modified arr[])



    // Traverse all input Intervals

    for (int i=0; i&lt;n; i++)

    {

        // If this is not first Interval and overlaps

        // with the previous one

        if (index != 0 &amp;&amp; arr[index-1].s &lt;= arr[i].e)

        {

            while (index != 0 &amp;&amp; arr[index-1].s &lt;= arr[i].e)

            {

                // Merge previous and current Intervals

                arr[index-1].e = max(arr[index-1].e, arr[i].e);

                arr[index-1].s = min(arr[index-1].s, arr[i].s);

                index--;

            }

        }

        else // Doesn't overlap with previous, add to

            // solution

            arr[index] = arr[i];



        index++;

    }



    // Now arr[0..index-1] stores the merged Intervals

    cout &lt;&lt; "\n The Merged Intervals are: ";

    for (int i = 0; i &lt; index; i++)

        cout &lt;&lt; "[" &lt;&lt; arr[i].s &lt;&lt; ", " &lt;&lt; arr[i].e &lt;&lt; "] ";

}



// Driver program

int main()

{

    Interval arr[] =  { {6,8}, {1,9}, {2,4}, {4,7} };

    int n = sizeof(arr)/sizeof(arr[0]);

    mergeIntervals(arr, n);

    return 0;

}</pre>
<p>Output:
<pre> The Merged Intervals are: [1,9] </pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a> for suggesting this method. </p>
<p>This article is compiled by Ravi Chandra Enaganti. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post58"> <span class="glyphicon glyphicon-collapse-down"></span>

Arrange given numbers to form the biggest number

</button> <div id="post58" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Arrange given numbers to form the biggest number</h1>
</header>
<div class="entry-content">
<p>Given an array of numbers, arrange them in a way that yields the largest value.  For example, if the given numbers are {54, 546, 548, 60}, the arrangement 6054854654 gives the largest value.<span id="more-114732"></span> And if the given numbers are {1, 34, 3, 98, 9, 76, 45, 4}, then the arrangement 998764543431 gives the largest value.<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=380" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
A simple solution that comes to our mind is to sort all numbers in descending order, but simply sorting doesn’t work. For example, 548 is greater than 60, but in output 60 comes before 548. As a second example, 98 is greater than 9, but 9 comes before 98 in output.</p>
<p>So how do we go about it? The idea is to use any comparison based sorting algorithm. In the used sorting algorithm, instead of using the default comparison, write a comparison function myCompare() and use it to sort numbers. Given two numbers X and Y, how should myCompare() decide which number to put first – we compare two numbers XY (Y appended at the end of X) and YX (X appended at the end of Y).  If XY is larger, then X should come before Y in output, else Y should come before.  For example, let X and Y be 542 and 60. To compare X and Y, we compare 54260 and 60542. Since 60542 is greater than 54260, we put Y first.</p>
<p>Following is C++ implementation of the above approach.  To keep the code simple, numbers are considered as strings, and <a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector">vector </a>is used instead of normal array. </p>
<pre class="brush: cpp; highlight: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]; title: ; notranslate" title="">

// Given an array of numbers, program to arrange the numbers to form the

// largest number

#include &lt;iostream&gt;

#include &lt;string&gt;

#include &lt;vector&gt;

#include &lt;algorithm&gt;

using namespace std;



// A comparison function which is used by sort() in printLargest()

int myCompare(string X, string Y)

{

    // first append Y at the end of X

    string XY = X.append(Y);



    // then append X at the end of Y

    string YX = Y.append(X);



    // Now see which of the two formed numbers is greater

    return XY.compare(YX) &gt; 0 ? 1: 0;

}



// The main function that prints the arrangement with the largest value.

// The function accepts a vector of strings

void printLargest(vector&lt;string&gt; arr)

{

    // Sort the numbers using library sort funtion. The function uses

    // our comparison function myCompare() to compare two strings.

    // See http://www.cplusplus.com/reference/algorithm/sort/ for details

    sort(arr.begin(), arr.end(), myCompare);



    for (int i=0; i &lt; arr.size() ; i++ )

        cout &lt;&lt; arr[i];

}



// driverr program to test above functions

int main()

{

    vector&lt;string&gt; arr;



    //output should be 6054854654

    arr.push_back("54");

    arr.push_back("546");

    arr.push_back("548");

    arr.push_back("60");

    printLargest(arr);



    // output should be 777776

    /*arr.push_back("7");

    arr.push_back("776");

    arr.push_back("7");

    arr.push_back("7");*/



    //output should be 998764543431

    /*arr.push_back("1");

    arr.push_back("34");

    arr.push_back("3");

    arr.push_back("98");

    arr.push_back("9");

    arr.push_back("76");

    arr.push_back("45");

    arr.push_back("4");

    */



   return 0;

}

</pre>
<p>Output:
<pre>6054854654</pre>
<p>This article is compiled by <strong>Ravi Chandra Enaganti</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post59"> <span class="glyphicon glyphicon-collapse-down"></span>

Construction of Longest Monotonically Increasing Subsequence (N log N)

</button> <div id="post59" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Construction of Longest Monotonically Increasing Subsequence (N log N)</h1>
</header>
<div class="entry-content">
<p>In my previous post, I have explained about longest <a href="http://www.geeksforgeeks.org/archives/9591" target="_blank">monotonically increasing sub-sequence</a> (LIS) problem in detail. <span id="more-27614"></span>However, the post only covered code related to querying size of LIS, but not the construction of LIS. I left it as an exercise. If you have solved, cheers. If not, you are not alone, here is code.</p>
<p>If you have not read my previous post, read <a href="http://www.geeksforgeeks.org/archives/9591" target="_blank">here</a>. Note that the below code prints LIS in reverse order. We can modify print order using a stack (explicit or system stack). I am leaving explanation as an exercise (easy).</p>
<pre class="brush: cpp; highlight: [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate" title="">

#include &lt;iostream&gt;

#include &lt;string.h&gt;

#include &lt;stdio.h&gt;

using namespace std;



// Binary search

int GetCeilIndex(int A[], int T[], int l, int r, int key) {

   int m;



   while( r - l &gt; 1 ) {

      m = l + (r - l)/2;

      if( A[T[m]] &gt;= key )

         r = m;

      else

         l = m;

   }



   return r;

}



int LongestIncreasingSubsequence(int A[], int size) {

   // Add boundary case, when array size is zero

   // Depend on smart pointers



   int *tailIndices = new int[size];

   int *prevIndices = new int[size];

   int len;



   memset(tailIndices, 0, sizeof(tailIndices[0])*size);

   memset(prevIndices, 0xFF, sizeof(prevIndices[0])*size);



   tailIndices[0] = 0;

   prevIndices[0] = -1;

   len = 1; // it will always point to empty location

   for( int i = 1; i &lt; size; i++ ) {

      if( A[i] &lt; A[tailIndices[0]] ) {

         // new smallest value

         tailIndices[0] = i;

      } else if( A[i] &gt; A[tailIndices[len-1]] ) {

         // A[i] wants to extend largest subsequence

         prevIndices[i] = tailIndices[len-1];

         tailIndices[len++] = i;

      } else {

         // A[i] wants to be a potential condidate of future subsequence

         // It will replace ceil value in tailIndices

        int pos = GetCeilIndex(A, tailIndices, -1, len-1, A[i]);



        prevIndices[i] = tailIndices[pos-1];

        tailIndices[pos] = i;

      }

   }

   cout &lt;&lt; "LIS of given input" &lt;&lt; endl;

   for( int i = tailIndices[len-1]; i &gt;= 0; i = prevIndices[i] )

      cout &lt;&lt; A[i] &lt;&lt; "   ";

   cout &lt;&lt; endl;



   delete[] tailIndices;

   delete[] prevIndices;



   return len;

}



int main() {

   int A[] = { 2, 5, 3, 7, 11, 8, 10, 13, 6 };

   int size = sizeof(A)/sizeof(A[0]);



   printf("LIS size %d\n", LongestIncreasingSubsequence(A, size));



   return 0;

}

</pre>
<p><strong>Exercises:</strong></p>
<p>1. You know <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank">Kadane</a>‘s algorithm to find <a href="http://www.geeksforgeeks.org/archives/576" target="_blank">maximum sum sub-array</a>. Modify Kadane’s algorithm to trace starting and ending location of maximum sum sub-array.</p>
<p>2. Modify <a href="http://en.wikipedia.org/wiki/Maximum_subarray_problem" target="_blank">Kadane</a>‘s algorithm to find maximum sum sub-array in a circular array. Refer GFG forum for many comments on the question.</p>
<p>3. Given two integers A and B as input. Find number of Fibonacci numbers existing in between these two numbers (including A and B). For example, A = 3 and B = 18, there are 4 Fibonacci numbers in between {3, 5, 8, 13}. Do it in O(log K) time, where K is max(A, B). What is your observation?</p>
<p>— <a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post60"> <span class="glyphicon glyphicon-collapse-down"></span>

Subarray/Substring vs Subsequence and Programs to Generate them

</button> <div id="post60" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Subarray/Substring vs Subsequence and Programs to Generate them</h1>
</header>
<div class="entry-content">
<p><center><strong>Subarray/Substring</strong></center><br/>
A subbarray is a <strong>contiguous</strong> part of array. An array that is inside another array. For example, consider the array [1, 2, 3, 4], There are 10 non-empty sub-arrays.  The subbarays are (1), (2), (3), (4), (1,2), (2,3), (3,4), (1,2,3), (2,3,4) and (1,2,3,4). In general, for an array/string of size n, there are <strong>n*(n+1)/2</strong> non-empty  subarrays/subsrings.</p>
<p><strong><em>How to generate all subarrays?</em></strong><br/>
We can run two nested loops, the outer loop picks starting element and inner loop considers all elements on right of the picked elements as ending element of subarray.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate" title="">

/*  C++ code to generate all possible subarrays/subArrays

    Complexity- O(n^3) */

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Prints all subarrays in arr[0..n-1]

void subArray(int arr[], int n)

{

    // Pick starting point

    for (int i=0; i &lt;n; i++)

    {

        // Pick ending point

        for (int j=i; j&lt;n; j++)

        {

            // Print subarray between current starting

            // and ending points

            for (int k=i; k&lt;=j; k++)

                cout &lt;&lt; arr[k] &lt;&lt; " ";



            cout &lt;&lt; endl;

        }

    }

}



// Driver program

int main()

{

    int arr[] = {1, 2, 3, 4};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "All Non-empty Subarrays\n";

    subArray(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>All Non-empty Subarrays

1 

1 2 

1 2 3 

1 2 3 4 

2 

2 3 

2 3 4 

3 

3 4 

4 </pre>
<p> <br/>
<center><strong>Subsequence</strong> </center><br/>
A subsequence is a sequence that can be derived from another sequence by zero or more elements, without changing the order of the remaining elements.<br/>
For the same example, there are 15 sub-sequences. They are (1), (2), (3), (4), (1,2), (1,3),(1,4), (2,3), (2,4), (3,4), (1,2,3), (1,2,4), (1,3,4), (2,3,4), (1,2,3,4). More generally, we can say that for a sequence of size n, we can have (<strong>2<sup>n</sup>-1</strong>) non-empty sub-sequences in total.<br/>
<em><br/>
A string example to differentiate:</em>  Consider strings “geeksforgeeks” and “gks”. “gks” is a subsequence of “geeksforgeeks” but not a substring.  “geeks” is both a subsequence and subarray.  Every subarray is a subsequence. More specifically, <strong>Subsequence is a generalization of substring.</strong></p>
<p><strong><em>How to generate all Subsequences?</em></strong><br/>
We can use <a href="http://www.geeksforgeeks.org/power-set/">algorithm to generate power set</a> for generation of all subsequences.  </p>
<pre class="brush: cpp; title: ; notranslate" title="">

/*  C++ code to generate all possible subsequences.

    Time Complexity O(n * 2^n) */

#include&lt;bits/stdc++.h&gt;

using namespace std;



void printSubsequences(int arr[], int n)

{

    /* Number of subsequences is (2**n -1)*/

    unsigned int opsize = pow(2, n);



    /* Run from counter 000..1 to 111..1*/

    for (int counter = 1; counter &lt; opsize; counter++)

    {

        for (int j = 0; j &lt; n; j++)

        {

            /* Check if jth bit in the counter is set

            	If set then print jth element from arr[] */

            if (counter &amp; (1&lt;&lt;j))

                cout &lt;&lt; arr[j] &lt;&lt; " ";

        }

        cout &lt;&lt; endl;

    }

}



// Driver program

int main()

{

    int arr[] = {1, 2, 3, 4};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "All Non-empty Subsequences\n";

    printSubsequences(arr, n);

    return 0;

}

</pre>
<pre>

All Non-empty Subsequences

1 

2 

1 2 

3 

1 3 

2 3 

1 2 3 

4 

1 4 

2 4 

1 2 4 

3 4 

1 3 4 

2 3 4 

1 2 3 4</pre>
<p>This article is contributed by <strong>Harshit Gupta</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post61"> <span class="glyphicon glyphicon-collapse-down"></span>

Form minimum number from given sequence

</button> <div id="post61" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Form minimum number from given sequence</h1>
</header>
<div class="entry-content">
<p>Given a pattern containing only I’s and D’s. <strong>I</strong> for increasing and <strong>D</strong> for decreasing. Devise an algorithm to print the minimum number following that pattern. Digits from 1-9 and digits can’t repeat.</p>
<p>   Examples:
<pre>

   Input: D        Output: 21

   Input: I        Output: 12

   Input: DD       Output: 321

   Input: II       Output: 123

   Input: DIDI     Output: 21435

   Input: IIDDD    Output: 126543

   Input: DDIDDIID Output: 321654798 

</pre>
<p>Source: <a href="http://www.geeksforgeeks.org/amazon-interview-experience-set-241-1-5-years-experience/">Amazon Interview Question</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=371" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p>Below are some important observations</p>
<p>Since digits can’t repeat, there can be at most 9 digits in output.  </p>
<p>Also number of digits in output is one more than number of characters in input. Note that the first character of input corresponds to two digits in output.</p>
<p>Idea is to iterate over input array and keep track of last printed digit and maximum digit printed so far. Below is C++ implementation.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109]; title: ; notranslate" title="">

// C++ program to print minimum number that can be formed

// from a given sequence of Is and Ds

#include &lt;iostream&gt;

using namespace std;



// Prints the minimum number that can be formed from

// input sequence of I's and D's

void PrintMinNumberForPattern(string arr)

{

    // Initialize current_max (to make sure that

    // we don't use repeated character

    int curr_max = 0;



    // Initialize last_entry (Keeps track for

    // last printed digit)

    int last_entry = 0;



    int j;



    // Iterate over input array

    for (int i=0; i&lt;arr.length(); i++)

    {

        // Initialize 'noOfNextD' to get count of

        // next D's available

        int noOfNextD = 0;



        switch(arr[i])

        {

        case 'I':

            // If letter is 'I'



            // Calculate number of next consecutive D's

            // available

            j = i+1;

            while (arr[j] == 'D' &amp;&amp; j &lt; arr.length())

            {

                noOfNextD++;

                j++;

            }

              

            if (i==0)

            {

                curr_max = noOfNextD + 2;



                // If 'I' is first letter, print incremented

                // sequence from 1

                cout &lt;&lt; " " &lt;&lt; ++last_entry;

                cout &lt;&lt; " " &lt;&lt; curr_max;



                // Set max digit reached

                last_entry = curr_max;

            }

            else

            {

                // If not first letter



                // Get next digit to print

                curr_max = curr_max + noOfNextD + 1;



                // Print digit for I

                last_entry = curr_max;

                cout &lt;&lt; " " &lt;&lt; last_entry;

            }



            // For all next consecutive 'D' print 

            // decremented sequence

            for (int k=0; k&lt;noOfNextD; k++)

            {

                cout &lt;&lt; " " &lt;&lt; --last_entry;

                i++;

            }

            break;



        // If letter is 'D'

        case 'D':

            if (i == 0)

            {

                // If 'D' is first letter in sequence

                // Find number of Next D's available

                j = i+1;

                while (arr[j] == 'D' &amp;&amp; j &lt; arr.length())

                {

                    noOfNextD++;

                    j++;

                }



                // Calculate first digit to print based on 

                // number of consecutive D's

                curr_max = noOfNextD + 2;



                // Print twice for the first time

                cout &lt;&lt; " " &lt;&lt; curr_max &lt;&lt; " " &lt;&lt; curr_max - 1;



                // Store last entry

                last_entry = curr_max - 1;

            }

            else

            {

                // If current 'D' is not first letter



                // Decrement last_entry

                cout &lt;&lt; " " &lt;&lt; last_entry - 1;

                last_entry--;

            }

            break;

        }

    }

    cout &lt;&lt; endl;

}



// Driver program to test above

int main()

{

    PrintMinNumberForPattern("IDID");

    PrintMinNumberForPattern("I");

    PrintMinNumberForPattern("DD");

    PrintMinNumberForPattern("II");

    PrintMinNumberForPattern("DIDI");

    PrintMinNumberForPattern("IIDDD");

    PrintMinNumberForPattern("DDIDDIID");

    return 0;

}

</pre>
<p>Output:
<pre>

 1 3 2 5 4

 1 2

 3 2 1

 1 2 3

 2 1 4 3 5

 1 2 6 5 4 3

 3 2 1 6 5 4 7 9 8

</pre>
<p>This solution is suggested by Swapnil Trambake.</p>
<p><strong>Alternate Solution:</strong><br/>
Let’s observe a few facts in case of minimum number:</p>
<ul>
<li>The digits can’t repeat hence there can be 9 digits at most in output.</li>
<li>To form a minimum number , at every index of the output,  we are interested in the minimum number which can be placed at that index.</li>
</ul>
<p>The idea is to iterate over the entire input array , keeping track of the minimum number (1-9) which can be placed at that position of the output.</p>
<p>The tricky part of course occurs when ‘D’ is encountered at index other than 0. In such a case we have to track the nearest ‘I’ to the left of ‘D’ and increment each number in the output vector by 1 in between ‘I’ and ‘D’. </p>
<p>We cover the base case as follows:</p>
<ul>
<li>If the first character of input is ‘I’ then we append 1 and 2 in the output vector and the minimum available number is set to 3 .The index of most recent ‘I’ is set to 1.</li>
<li>If the first character of input is ‘D’ then we append 2 and 1 in the output vector and the minimum available number is set to 3,  and the index of most recent ‘I’  is set to 0.</li>
</ul>
<p>Now we iterate the input string from index 1 till its end and:</p>
<ul>
<li>If the character scanned is ‘I’  ,minimum value which has not been used yet is appended to the output vector .We increment the value of minimum no. available  and index of most recent ‘I’ is also updated.</li>
<li>If the character scanned is ‘D’ at index i of input array,  we append the ith element from output vector in the output and track the nearest ‘I’ to the left of ‘D’ and increment each number in the output vector by 1 in between ‘I’ and ‘D’.</li>
</ul>
<p>Following is the C++ program for the same:</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]; title: ; notranslate" title="">

// C++ program to print minimum number that can be formed

// from a given sequence of Is and Ds

#include&lt;bits/stdc++.h&gt;

using namespace std;



void printLeast(string arr)

{

    // min_avail represents the minimum number which is

    // still available for inserting in the output vector.

    // pos_of_I keeps track of the most recent index

    // where 'I' was encountered w.r.t the output vector

    int min_avail = 1, pos_of_I = 0;



    //vector to store the output

    vector&lt;int&gt;v;



    // cover the base cases

    if (arr[0]=='I')

    {

        v.push_back(1);

        v.push_back(2);

        min_avail = 3;

        pos_of_I = 1;

    }

    else

    {

        v.push_back(2);

        v.push_back(1);

        min_avail = 3;

        pos_of_I = 0;

    }



    // Traverse rest of the input

    for (int i=1; i&lt;arr.length(); i++)

    {

        if (arr[i]=='I')

        {

            v.push_back(min_avail);

            min_avail++;

            pos_of_I = i+1;

        }

        else

        {

            v.push_back(v[i]);

            for (int j=pos_of_I; j&lt;=i; j++)

                v[j]++;



            min_avail++;

        }

    }



    // print the number

    for (int i=0; i&lt;v.size(); i++)

        cout &lt;&lt; v[i] &lt;&lt; " ";

    cout &lt;&lt; endl;

}



// Driver program to check the above function

int main()

{

    printLeast("IDID");

    printLeast("I");

    printLeast("DD");

    printLeast("II");

    printLeast("DIDI");

    printLeast("IIDDD");

    printLeast("DDIDDIID");

    return 0;

}

</pre>
<p>Output:
<pre>

1 3 2 5 4 

1 2 

3 2 1 

1 2 3 

2 1 4 3 5 

1 2 6 5 4 3 

3 2 1 6 5 4 7 9 8 </pre>
<p>This solution is suggested by <a href="https://www.linkedin.com/in/ashutosh-kumar-9527a7105?trk=nav_responsive_tab_profile">Ashutosh Kumar</a>.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post62"> <span class="glyphicon glyphicon-collapse-down"></span>

Merge two sorted arrays with O(1) extra space

</button> <div id="post62" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Merge two sorted arrays with O(1) extra space</h1>
</header>
<div class="entry-content">
<p>We are given two sorted array. We need to merge these two arrays such that the initial numbers (after complete sorting) are in the first array and the remaining numbers are in the second array.  Extra space allowed in O(1).</p>
<p>Example:</p>
<pre>

Input: ar1[] = {1, 5, 9, 10, 15, 20};

       ar2[] = {2, 3, 8, 13};

Output: ar1[] = {1, 2, 3, 5, 8, 9}

        ar2[] = {10, 13, 15, 20}  

</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>This task is simple and O(m+n) if we are allowed to use extra space. But it becomes really complicated when extra space is not allowed and doesn’t look possible in less than O(m*n) worst case time. </p>
<p>The idea is to begin from last element of ar2[] and search it in ar1[]. If there is a greater element in ar1[], then we move last element of ar1[] to ar2[]. To keep ar1[] and ar2[] sorted, we need to place last element of ar2[] at correct place in ar1[]. We can use <a href="http://geeksquiz.com/insertion-sort/">Insertion Sort</a> type of insertion for this. Below is algorithm:</p>
<pre>

1) Iterate through every element of ar2[] starting from <strong>last</strong> 

   element. Do following for every element ar2[i]

    a) Store last element of ar1[i]: last = ar1[i]

    b) Loop from last element of ar1[] while element ar1[j] is 

       smaller than ar2[i].

          ar1[j+1] = ar1[j] // Move element one position ahead

          j--

    c) If any element of ar1[] was moved or (j != m-1)

          ar1[j+1] = ar2[i] 

          ar2[i] = last  

</pre>
<p>In above loop, elements in ar1[] and ar2[] are always kept sorted.</p>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate" title="">

// C++ program for implementation of Sieve of Atkin

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Merge ar1[] and ar2[] with O(1) extra space

void merge(int ar1[], int ar2[], int m, int n)

{

    // Iterate through all elements of ar2[] starting from

    // the last element

    for (int i=n-1; i&gt;=0; i--)

    {

        /* Find the smallest element greater than ar2[i]. Move all

           elements one position ahead till the smallest greater

           element is not found */

        int j, last = ar1[m-1];

        for (j=m-1; j &gt;= 0 &amp;&amp; ar1[j] &gt; ar2[i]; j--)

            ar1[j+1] = ar1[j];



        // If there was a greater element

        if (j != m-1)

        {

            ar1[j+1] = ar2[i];

            ar2[i] = last;

        }

    }

}



// Driver program

int main(void)

{

    int ar1[] = {1, 5, 9, 10, 15, 20};

    int ar2[] = {2, 3, 8, 13};

    int m = sizeof(ar1)/sizeof(ar1[0]);

    int n = sizeof(ar2)/sizeof(ar2[0]);

    merge(ar1, ar2, m, n);



    cout &lt;&lt; "After Merging \nFirst Array: ";

    for (int i=0; i&lt;m; i++)

        cout &lt;&lt; ar1[i] &lt;&lt; " ";

    cout &lt;&lt; "\nSecond Array: ";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; ar2[i] &lt;&lt; " ";

   return 0;

}

</pre>
<p>Output:
<pre>

After Merging 

First Array: 1 2 3 5 8 9 

Second Array: 10 13 15 20 </pre>
<p><strong>Illustration:</strong>
<pre>

Initial Arrays:

   ar1[] = {1, 5, 9, 10, 15, 20};

   ar2[] = {2, 3, 8, <strong>13</strong>};



After First Iteration:

   ar1[] = {1, 5, 9, 10, 13, 15};

   ar2[] = {2, 3, <strong>8</strong>, 20};

// 20 is moved from ar1[] to ar2[]

// 13 from ar2[] is inserted in ar1[]



After Second Iteration:

   ar1[] = {1, 5, 8, 9, 10, 13};

   ar2[] = {2, <strong>3</strong>, 15, 20};

// 15 is moved from ar1[] to ar2[]

// 8 from ar2[] is inserted in ar1[]



After Third Iteration:

   ar1[] = {1, 3, 5, 8, 9, 10};

   ar2[] = {<strong>2</strong>, 13, 15, 20};

// 13 is moved from ar1[] to ar2[]

// 3 from ar2[] is inserted in ar1[]



After Fourth Iteration:

   ar1[] = {1, 2, 3, 5, 8, 9};

   ar2[] = {10, 13, 15, 20};</pre>
<p>// 10 is moved from ar1[] to ar2[]<br/>
// 2 from ar2[] is inserted in ar1[]</p>
<p>The worst case time complexity of code/algorithm is O(m*n). The worst case occurs when all elements of ar1[] are greater than all elements of ar2[].</p>
<p>Thanks to Shubham Chauhan for suggesting above solution. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post63"> <span class="glyphicon glyphicon-collapse-down"></span>

Longest Span with same Sum in two Binary arrays

</button> <div id="post63" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Longest Span with same Sum in two Binary arrays</h1>
</header>
<div class="entry-content">
<p>Given two binary arrays arr1[] and arr2[] of same size n.  Find length of the longest common span (i, j) where j &gt;= i such that arr1[i] + arr1[i+1] + …. + arr1[j] = arr2[i] + arr2[i+1] + …. + arr2[j].</p>
<p>Expected time complexity is Θ(n).</p>
<p>Examples:</p>
<pre>

Input: arr1[] = {0, 1, 0, 0, 0, 0};

       arr2[] = {1, 0, 1, 0, 0, 1};

Output: 4

The longest span with same sum is from index 1 to 4.



Input: arr1[] = {0, 1, 0, 1, 1, 1, 1};

       arr2[] = {1, 1, 1, 1, 1, 0, 1};

Output: 6

The longest span with same sum is from index 1 to 6.



Input: arr1[] = {0, 0, 0};

       arr2[] = {1, 1, 1};

Output: 0



Input: arr1[] = {0, 0, 1, 0};

       arr2[] = {1, 1, 1, 1};

Output: 1

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=188" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p><center><strong>Method 1 (Simple Solution)</strong></center><br/>
One by one by consider same subarrays of both arrays.  For all subarrays, compute sums and if sums are same and current length is more than max length, then update max length.  Below is C++ implementation of simple approach.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]; title: ; notranslate" title="">

// A Simple C++ program to find longest common

// subarray of two binary arrays with same sum

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns length of the longest common subarray

// with same sum

int longestCommonSum(bool arr1[], bool arr2[], int n)

{

    // Initialize result

    int maxLen = 0;



    // One by one pick all possible starting points

    // of subarrays

    for (int i=0; i&lt;n; i++)

    {

       // Initialize sums of current subarrays

       int sum1 = 0, sum2 = 0;



       // Conider all points for starting with arr[i]

       for (int j=i; j&lt;n; j++)

       {

           // Update sums

           sum1 += arr1[j];

           sum2 += arr2[j];



           // If sums are same and current length is

           // more than maxLen, update maxLen

           if (sum1 == sum2)

           {

             int len = j-i+1;

             if (len &gt; maxLen)

                maxLen = len;

           }

       }

    }

    return maxLen;

}



// Driver progra+m to test above function

int main()

{

    bool  arr1[] = {0, 1, 0, 1, 1, 1, 1};

    bool  arr2[] = {1, 1, 1, 1, 1, 0, 1};

    int n = sizeof(arr1)/sizeof(arr1[0]);

    cout &lt;&lt; "Length of the longest common span with same "

            "sum is "&lt;&lt; longestCommonSum(arr1, arr2, n);

    return 0;

}

</pre>
<p>Output:
<pre>

Length of the longest common span with same sum is 6</pre>
<p>Time Complexity: O(n<sup>2</sup>)<br/>
Auxiliary Space: O(1)</p>
<p> <br/>
<center><strong>Method 2 (Using Auxiliary Array)</strong></center><br/>
The idea is based on below observations.</p>
<ol>
<li> Since there are total n elements, maximum sum is n for both arrays.</li>
<li> Difference between two sums varies from <strong>-n</strong> to <strong>n</strong>. So there are total 2n + 1 possible values of difference.</li>
<li> If differences between prefix sums of two arrays become same at two points, then subarrays between these two points have same sum.</li>
</ol>
<p>Below is Complete Algorithm.</p>
<ol>
<li> Create an auxiliary array of size 2n+1 to store starting points of all possible values of differences (Note that possible values of differences vary from -n to n, i.e., there are total 2n+1 possible values)</li>
<li> Initialize starting points of all differences as -1.</li>
<li> Initialize <strong>maxLen</strong> as 0 and prefix sums of both arrays as 0, <strong>preSum1</strong> = 0, <strong>preSum2</strong> = 0</li>
<li> Travers both arrays from i = 0 to n-1.
<ol>
<li type="a">Update prefix sums: preSum1 += arr1[i], preSum2 += arr2[i]</li>
<li type="a">Compute difference of current prefix sums: <strong>curr_diff </strong>= preSum1 – preSum2</li>
<li type="a">Find index in diff array: <strong>diffIndex</strong> = n + curr_diff // curr_diff can be negative and can go till -n </li>
<li type="a"><strong>If</strong> curr_diff is 0, then i+1 is maxLen so far</li>
<li type="a"><strong>Else If</strong> curr_diff is seen first time, i.e., starting point of current diff is -1, then update starting point as i</li>
<li type="a"><strong>Else</strong> (curr_diff is NOT seen first time), then consider i as ending point and find length of current same sum span. If this length is more, then update maxLen</li>
</ol>
</li>
<li> Return maxLen </li>
</ol>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62]; title: ; notranslate" title="">

// A O(n) and O(n) extra space C++ program to find

// longest common subarray of two binary arrays with

// same sum

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns length of the longest common sum in arr1[]

// and arr2[]. Both are of same size n.

int longestCommonSum(bool arr1[], bool arr2[], int n)

{

    // Initialize result

    int maxLen = 0;



    // Initialize prefix sums of two arrays

    int preSum1 = 0, preSum2 = 0;



    // Create an array to store staring and ending

    // indexes of all possible diff values. diff[i]

    // would store starting and ending points for

    // difference "i-n"

    int diff[2*n+1];



    // Initialize all starting and ending values as -1.

    memset(diff, -1, sizeof(diff));



    // Traverse both arrays

    for (int i=0; i&lt;n; i++)

    {

        // Update prefix sums

        preSum1 += arr1[i];

        preSum2 += arr2[i];



        // Comput current diff and index to be used

        // in diff array. Note that diff can be negative

        // and can have minimum value as -1.

        int curr_diff = preSum1 - preSum2;

        int diffIndex = n + curr_diff;



        // If current diff is 0, then there are same number

        // of 1's so far in both arrays, i.e., (i+1) is

        // maximum length.

        if (curr_diff == 0)

            maxLen = i+1;



        // If current diff is seen first time, then update

        // starting index of diff.

        else if ( diff[diffIndex] == -1)

            diff[diffIndex] = i;



        // Current diff is already seen

        else

        {

            // Find lenght of this same sum common span

            int len = i - diff[diffIndex];



            // Update max len if needed

            if (len &gt; maxLen)

                maxLen = len;

        }

    }

    return maxLen;

}



// Driver progra+m to test above function

int main()

{

    bool  arr1[] = {0, 1, 0, 1, 1, 1, 1};

    bool  arr2[] = {1, 1, 1, 1, 1, 0, 1};

    int n = sizeof(arr1)/sizeof(arr1[0]);

    cout &lt;&lt; "Length of the longest common span with same "

            "sum is "&lt;&lt; longestCommonSum(arr1, arr2, n);

    return 0;

}

</pre>
<p>Output:
<pre>

Length of the longest common span with same sum is 6</pre>
<p>Time Complexity: Θ(n)<br/>
Auxiliary Space: Θ(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/xtfj4-r_Ahs?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Sumit Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post64"> <span class="glyphicon glyphicon-collapse-down"></span>

Count Inversions of size three in a give array

</button> <div id="post64" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count Inversions of size three in a give array</h1>
</header>
<div class="entry-content">
<p>Given an array arr[] of size n. Three elements arr[i], arr[j] and arr[k] form an inversion of size 3 if a[i] &gt; a[j] &gt;a[k] and i &lt; j &lt; k.  Find total number of inversions of size 3.</p>
<p>Example:</p>
<pre>

Input:  {8, 4, 2, 1}

Output: 4

The four inversions are (8,4,2), (8,4,1), (4,2,1) and (8,2,1).



Input:  {9, 6, 4, 5, 8}

Output:  2

The two inversions are {9, 6, 4} and {9, 6, 5}

</pre>
<p>We have already discussed inversion count of size two by <a href="http://www.geeksforgeeks.org/counting-inversions/">merge sort</a>,<a href="http://www.geeksforgeeks.org/count-inversions-in-an-array-set-2-using-self-balancing-bst/"> Self Balancing BST</a> and <a href="http://www.geeksforgeeks.org/count-inversions-array-set-3-using-bit/">BIT</a>.</p>
<p><strong>Simple approach :-</strong> Loop for all possible value of i, j and k and check for the condition a[i] &gt; a[j] &gt; a[k] and i &lt; j &lt; k.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]; title: ; notranslate" title="">

// A Simple C++ O(n^3)  program to count inversions of size 3

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns counts of inversions of size three

int getInvCount(int arr[],int n)

{

    int invcount = 0;  // Initialize result



    for (int i=0; i&lt;n-2; i++)

    {

        for (int j=i+1; j&lt;n-1; j++)

        {

            if (arr[i]&gt;arr[j])

            {

                for (int k=j+1; k&lt;n; k++)

                {

                    if (arr[j]&gt;arr[k])

                        invcount++;

                }

            }

        }

    }

    return invcount;

}



// Driver program to test above function

int main()

{

    int arr[] = {8, 4, 2, 1};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Inversion Count : " &lt;&lt; getInvCount(arr, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate" title="">

// A simple Java implementation  to count inversion of size 3

class Inversion{

    

    // returns count of inversion of size 3

    int getInvCount(int arr[], int n)

    {

        int invcount = 0; // initialize result

        

        for(int i=0 ; i&lt; n-2; i++)

        {

            for(int j=i+1; j&lt;n-1; j++)

            {

                if(arr[i] &gt; arr[j])

                {

                    for(int k=j+1; k&lt;n; k++)

                    {

                        if(arr[j] &gt; arr[k])

                            invcount++;

                    }

                }

            }

        }

        return invcount;

    }



    // driver program to test above function

    public static void main(String args[])

    {

        Inversion inversion = new Inversion();

        int arr[] = new int[] {8, 4, 2, 1};

        int n = arr.length;

        System.out.print("Inversion count : " + 

                    inversion.getInvCount(arr, n));

    }

}

// This code is contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate" title="">



# A simple python O(n^3) program to count inversions of size 3



# Returns counts of inversions of size threee

def getInvCount(arr):

    n = len(arr)

    invcount = 0  #Initialize result    

    for i in range(0,n-1):

        for j in range(i+1 , n):

                if arr[i] &gt; arr[j]:

                    for k in range(j+1 , n):

                        if arr[j] &gt; arr[k]:

                            invcount += 1

    return invcount



# Driver program to test above function

arr = [8 , 4, 2 , 1]

print "Inversion Count : %d" %(getInvCount(arr))



# This code is contributed by Nikhil Kumar Singh(nickzuck_007)



</pre>
<p></p></div></div><br/>
Output:
<pre>Inversion Count : 4 </pre>
<p><strong>Time complexity</strong> of this approach is : O(n^3)</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post65"> <span class="glyphicon glyphicon-collapse-down"></span>

Find the subarray with least average

</button> <div id="post65" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find the subarray with least average</h1>
</header>
<div class="entry-content">
<p>Given an array arr[] of size n and integer k such that k &lt;= n.


<pre>

Input:  arr[] = {3, 7, 90, 20, 10, 50, 40}, k = 3

Output: Subarray between indexes 3 and 5

The subarray {20, 10, 50} has the least average 

among all subarrays of size 3.



Input:  arr[] = {3, 7, 5, 20, -10, 0, 12}, k = 2

Output: Subarray between [4, 5] has minimum average

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=169" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p>A <strong>Simple Solution</strong> is to consider every element as beginning of subarray of size k and compute sum of subarray starting with this element.  Time complexity of this solution is O(nk).</p>
<p>An <strong>Efficient Solution</strong> is to solve the above problem in O(n) time and O(1) extra space. The idea is to use sliding window of size k.  Keep track of sum of current k elements. To compute sum of current window, remove first element of previous window and add current element (last element of current window).</p>
<pre>

1) Initialize res_index = 0 // Beginning of result index

2) Find sum of first k elements. Let this sum be 'curr_sum'

3) Initialize min_sum = sum

4) Iterate from (k+1)'th to n'th element, do following

   for every element arr[i]

      a) curr_sum = curr_sum + arr[i] - arr[i-k]

      b) If curr_sum &lt; min_sum

           res_index = (i-k+1)

5) Print res_index and res_index+k-1 as beginning and ending

   indexes of resultant subarray.</pre>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate" title="">

// A Simple C++ program to find minimum average subarray

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Prints beginning and ending indexes of subarray

// of size k with minimum average

void findMinAvgSubarray(int arr[], int n, int k)

{

    // k must be smaller than or equal to n

    if (n &lt; k)

       return;



    // Initialize  beginning index of result

    int res_index = 0;



    // Compute sum of first subarray of size k

    int curr_sum = 0;

    for (int i=0; i&lt;k; i++)

       curr_sum += arr[i];



    // Initialize minimum sum as current sum

    int min_sum = curr_sum;



    // Traverse from (k+1)'th element to n'th element

    for (int i = k; i &lt; n; i++)

    {

        // Add current item and remove first item of

        // previous subarray

        curr_sum += arr[i] - arr[i-k];



        // Update result if needed

        if (curr_sum &lt; min_sum)

        {

            min_sum = curr_sum;

            res_index = (i-k+1);

        }

    }



    cout &lt;&lt; "Subarray between [" &lt;&lt; res_index &lt;&lt; ", "

        &lt;&lt; res_index + k - 1&lt;&lt; "] has minimum average";

}



// Driver program

int main()

{

    int arr[] = {3, 7, 90, 20, 10, 50, 40};

    int k = 3; // Subarray size

    int n = sizeof arr / sizeof arr[0];

    findMinAvgSubarray(arr, n, k);

    return 0;

}

</pre>
<p>Output:
<pre>Subarray between [3, 5] has minimum average</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>Source: <a href="http://qa.geeksforgeeks.org/2221/given-an-array-integers-find-subarray-having-least-">http://qa.geeksforgeeks.org/2221/given-an-array-integers-find-subarray-having-least-</a>average</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post66"> <span class="glyphicon glyphicon-collapse-down"></span>

Count triplets with sum smaller than a  given value

</button> <div id="post66" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count triplets with sum smaller than a  given value</h1>
</header>
<div class="entry-content">
<p>Given an array of distinct integers and a sum value. Find count of triplets with sum smaller than given sum value.  Expected Time Complexity is O(n<sup>2</sup>).</p>
<p>Examples:
<pre>

Input : arr[] = {-2, 0, 1, 3}

        sum = 2.

Output : 2

Explanation :  Below are triplets with sum less than 2

               (-2, 0, 1) and (-2, 0, 3) 



Input : arr[] = {5, 1, 3, 4, 7}

        sum = 12.

Output : 4

Explanation :  Below are triplets with sum less than 4

               (1, 3, 4), (1, 3, 5), (1, 3, 7) and 

               (1, 4, 5)</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>A <strong>Simple Solution</strong> is to run three loops to consider all triplets one by one. For every triplet, compare the sums and increment count if triplet sum is smaller than given sum. </p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]; title: ; notranslate" title="">

// A Simple C++ program to count triplets with sum smaller

// than a given value

#include&lt;bits/stdc++.h&gt;

using namespace std;



int countTriplets(int arr[], int n, int sum)

{

    // Initialize result

    int ans = 0;



    // Fix the first element as A[i]

    for (int i = 0; i &lt; n-2; i++)

    {

       // Fix the second element as A[j]

       for (int j = i+1; j &lt; n-1; j++)

       {

           // Now look for the third number

           for (int k = j+1; k &lt; n; k++)

               if (arr[i] + arr[j] + arr[k] &lt; sum)

                   ans++;

       }

    }



    return ans;

}



// Driver program

int main()

{

    int arr[] = {5, 1, 3, 4, 7};

    int n = sizeof arr / sizeof arr[0];

    int sum = 12;

    cout &lt;&lt; countTriplets(arr, n, sum) &lt;&lt; endl;

    return 0;

}

</pre>
<p>Output:
<pre>4</pre>
<p>Time complexity of above solution is O(n<sup>3</sup>). An <strong>Efficient Solution</strong> can count triplets in O(n<sup>2</sup>) by sorting the array first, and then using method 1 of <a href="http://www.geeksforgeeks.org/archives/484">this</a> post in a loop.</p>
<pre>

1) Sort the input array in increasing order.

2) Initialize result as 0.

3) Run a loop from i = 0 to n-2.  An iteration of this loop finds all

   triplets with arr[i] as first element.

     a) Initialize other two elements as corner elements of subarray

        arr[i+1..n-1], i.e., j = i+1 and k = n-1

     b) Move j and k toward each other until they meet, i.e., while (j &lt; k)

            (i) if (arr[i] + arr[j] + arr[k] &gt;= sum), then do k--



            // Else for current i and j, there can (k-j) possible third elements

            // that satisfy the constraint.

            (ii) Else Do ans += (k - j) followed by j++ </pre>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]; title: ; notranslate" title="">

// C++ program to count triplets with sum smaller than a given value

#include&lt;bits/stdc++.h&gt;

using namespace std;



int countTriplets(int arr[], int n, int sum)

{

    // Sort input array

    sort(arr, arr+n);



    // Initialize result

    int ans = 0;



    // Every iteration of loop counts triplet with

    // first element as arr[i].

    for (int i = 0; i &lt; n - 2; i++)

    {

        // Initialize other two elements as corner elements

        // of subarray arr[j+1..k]

        int j = i + 1, k = n - 1;



        // Use Meet in the Middle concept

        while (j &lt; k)

        {

            // If sum of current triplet is more or equal,

            // move right corner to look for smaller values

            if (arr[i] + arr[j] + arr[k] &gt;= sum)

                k--;



            // Else move left corner

            else

            {

                // This is important. For current i and j, there

                // can be total k-j third elements.

                ans += (k - j);

                j++;

            }

        }

    }

    return ans;

}



// Driver program

int main()

{

    int arr[] = {5, 1, 3, 4, 7};

    int n = sizeof arr / sizeof arr[0];

    int sum = 12;

    cout &lt;&lt; countTriplets(arr, n, sum) &lt;&lt; endl;

    return 0;

}

</pre>
<p>Output:
<pre>4</pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar </a>for suggesting this solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post67"> <span class="glyphicon glyphicon-collapse-down"></span>

Find zeroes to be flipped so that number of consecutive 1’s is maximized

</button> <div id="post67" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find zeroes to be flipped so that number of consecutive 1’s is maximized</h1>
</header>
<div class="entry-content">
<p>Given a binary array and an integer m, find the position of zeroes flipping which creates maximum number of consecutive 1s in array.</p>
<p>Examples:</p>
<pre>

Input:   arr[] = {1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1}

         m = 2

Output:  5 7

We are allowed to flip maximum 2 zeroes. If we flip

arr[5] and arr[7], we get 8 consecutive 1's which is

maximum possible under given constraints 



Input:   arr[] = {1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1}

         m = 1

Output:  7

We are allowed to flip maximum 1 zero. If we flip 

arr[7], we get 5 consecutive 1's which is maximum 

possible under given constraints.



Input:   arr[] = {0, 0, 0, 1}

         m = 4

Output:  0 1 2

Since m is more than number of zeroes, we can flip

all zeroes.

</pre>
<p>Source: <a href="http://www.careercup.com/question?id=5106425965576192">http://www.careercup.com/question?id=5106425965576192</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=189" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p>A <strong>Simple Solution</strong> is to consider every subarray by running two loops.  For every subarray, count number of zeroes in it.  Return the maximum size subarray with m or less zeroes.  Time Complexity of this solution is O(n<sup>2</sup>).</p>
<p>A <strong>Better Solution</strong> is to use auxiliary space to solve the problem in O(n) time.</p>
<p>For all positions of 0’s calculate left[] and right[] which defines the number of consecutive 1’s to the left of i and right of i respectively.  </p>
<p>For example, for arr[] = {1, 1, 0, 1, 1, 0, 0, 1, 1, 1} and m = 1, left[2] = 2 and right[2] = 2, left[5] = 2 and right[5] = 0, left[6] = 0 and right[6] = 3.</p>
<p>left[] and right[] can be filled in O(n) time by traversing array once and keeping track of last seen 1 and last seen 0.  While filling left[] and right[], we also store indexes of all zeroes in a third array say zeroes[]. For above example, this third array stores {2, 5, 6}</p>
<p>Now traverse zeroes[] and for all consecutive m entries in this array, compute the sum of 1s that can be produced.  This step can be done in O(n) using left[] and right[]. </p>
<p>An <strong>Efficient Solution</strong> can solve the problem in O(n) time and O(1) space.  The idea is to use Sliding Window for the given array.  The solution is taken from <a href="http://www.careercup.com/question?id=5106425965576192">here</a>.<br/>
Let us use a window covering from index wL to index wR. Let the number of zeros inside the window be zeroCount. We maintain the window with at most m zeros inside.</p>
<p>The main steps are:<br/>
– While zeroCount is no more than m: expand the window to the right (wR++) and update the count zeroCount.<br/>
– While zeroCount exceeds m, shrink the window from left (wL++), update zeroCount;<br/>
– Update the widest window along the way. The positions of output zeros are inside the best window.</p>
<p>Below is C++ implementation of the idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate" title="">

// C++ program to find positions of zeroes flipping which

// produces maximum number of xonsecutive 1's

#include&lt;bits/stdc++.h&gt;

using namespace std;



// m is maximum of number zeroes allowed to flip

// n is size of array

void findZeroes(int arr[], int n, int m)

{

    // Left and right indexes of current window

    int wL = 0, wR = 0; 



    // Left index and size of the widest window 

    int bestL = 0, bestWindow = 0; 



    // Count of zeroes in current window

    int zeroCount = 0; 



    // While right boundary of current window doesn't cross 

    // right end

    while (wR &lt; n)

    {

        // If zero count of current window is less than m,

        // widen the window toward right

        if (zeroCount &lt;= m)

        {

            if (arr[wR] == 0)

              zeroCount++;

            wR++;

        }



        // If zero count of current window is more than m,

        // reduce the window from left

        if (zeroCount &gt; m)

        {

            if (arr[wL] == 0)

              zeroCount--;

            wL++;

        }



        // Updqate widest window if this window size is more

        if (wR-wL &gt; bestWindow)

        {

            bestWindow = wR-wL;

            bestL = wL;

        }

    }



    // Print positions of zeroes in the widest window

    for (int i=0; i&lt;bestWindow; i++)

    {

        if (arr[bestL+i] == 0)

           cout &lt;&lt; bestL+i &lt;&lt; " ";

    }

}



// Driver program

int main()

{

   int arr[] = {1, 0, 0, 1, 1, 0, 1, 0, 1, 1};

   int m = 2;

   int n =  sizeof(arr)/sizeof(arr[0]);

   cout &lt;&lt; "Indexes of zeroes to be flipped are ";

   findZeroes(arr, n, m);

   return 0;

}

</pre>
<p>Output:
<pre>Indexes of zeroes to be flipped are 5 7</pre>
<p>This article is contributed by <a href="https://www.linkedin.com/pub/ekta-goel/75/12a/3a6">Ekta Goel</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post68"> <span class="glyphicon glyphicon-collapse-down"></span>

Reorder an array according to given indexes

</button> <div id="post68" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Reorder an array according to given indexes</h1>
</header>
<div class="entry-content">
<p>Given two integer arrays of same size, “arr[]” and “index[]”, reorder elements in “arr[]” according to given index array. It is not allowed to given array arr’s length.</p>
<p>Example:</p>
<pre>

Input:  arr[]   = [10, 11, 12];

        index[] = [1, 0, 2];

Output: arr[]   = [11, 10, 12]

        index[] = [0,  1,  2] 



Input:  arr[]   = [50, 40, 70, 60, 90]

        index[] = [3,  0,  4,  1,  2]

Output: arr[]   = [40, 60, 90, 50, 70]

        index[] = [0,  1,  2,  3,   4] 

</pre>
<p>Expected time complexity O(n) and auxiliary space O(1)</p>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>A <strong>Simple Solution </strong>is to use an auxiliary  array temp[] of same size as given arrays.  Traverse the given array and put all elements at their correct place in temp[] using index[]. Finally copy temp[] to arr[] and set all values of index[i] as i.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]; title: ; notranslate" title="">

// C++ program to sort an array according to given

// indexes

#include&lt;iostream&gt;

using namespace std;



// Function to reorder elements of arr[] according

// to index[]

void reorder(int arr[], int index[], int n)

{

    int temp[n];



    // arr[i] should be present at index[i] index

    for (int i=0; i&lt;n; i++)

        temp[index[i]] = arr[i];



    // Copy temp[] to arr[]

    for (int i=0; i&lt;n; i++)

    { 

       arr[i]   = temp[i];

       index[i] = i;

    }

}



// Driver program

int main()

{

    int arr[] = {50, 40, 70, 60, 90};

    int index[] = {3,  0,  4,  1,  2};

    int n = sizeof(arr)/sizeof(arr[0]);



    reorder(arr, index, n);



    cout &lt;&lt; "Reordered array is: \n";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";



    cout &lt;&lt; "\nModified Index array is: \n";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; index[i] &lt;&lt; " ";

    return 0;

}

</pre>
<p>Output:
<pre>Reordered array is: 

40 60 90 50 70 

Modified Index array is: 

0 1 2 3 4 

</pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/gccode">gccode</a> for suggesting above solution.</p>
<p>We can solve it <strong>Without Auxiliary Array</strong>. Below is algorithm.</p>
<pre>

1) Do following for every element arr[i]

   a) While index[i] is not equal to i

       (i)  Store array and index values of the target (or 

            correct) position where arr[i] should be placed.

            The correct position for arr[i] is index[i]

       (ii) Place arr[i] at its correct position. Also

            update index value of correct position.

       (iii) Copy old values of correct position (Stored in

            step (i)) to arr[i] and index[i] as the while 

            loop continues for i.

</pre>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]; title: ; notranslate" title="">

// A O(n) time and O(1) extra space C++ program to

// sort an array according to given indexes

#include&lt;iostream&gt;

using namespace std;



// Function to reorder elements of arr[] according

// to index[]

void reorder(int arr[], int index[], int n)

{

    // Fix all elements one by one

    for (int i=0; i&lt;n; i++)

    {

        // While index[i] and arr[i] are not fixed

        while (index[i] != i)

        {

            // Store values of the target (or correct) 

            // position before placing arr[i] there

            int  oldTargetI  = index[index[i]];

            char oldTargetE  = arr[index[i]];



            // Place arr[i] at its target (or correct)

            // position. Also copy corrected index for

            // new position

            arr[index[i]] = arr[i];

            index[index[i]] = index[i];



            // Copy old target values to arr[i] and

            // index[i]

            index[i] = oldTargetI;

            arr[i]   = oldTargetE;

        }

    }

}



// Driver program

int main()

{

    int arr[] = {50, 40, 70, 60, 90};

    int index[] = {3,  0,  4,  1,  2};

    int n = sizeof(arr)/sizeof(arr[0]);



    reorder(arr, index, n);



    cout &lt;&lt; "Reordered array is: \n";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";



    cout &lt;&lt; "\nModified Index array is: \n";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; index[i] &lt;&lt; " ";

    return 0;

}

</pre>
<p>Output:
<pre>Reordered array is: 

40 60 90 50 70 

Modified Index array is: 

0 1 2 3 4 

</pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/shyamala_lokre">shyamala_lokre</a> for suggesting above solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post69"> <span class="glyphicon glyphicon-collapse-down"></span>

Find maximum value of Sum( i*arr[i]) with only rotations on given array allowed

</button> <div id="post69" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find maximum value of Sum( i*arr[i]) with only rotations on given array allowed</h1>
</header>
<div class="entry-content">
<p>Given an array, only rotation operation is allowed on array. We can rotate the array as many times as we want.  Return the maximum possbile of summation of i*arr[i].<span id="more-135595"></span></p>
<p>Example:</p>
<pre>

Input: arr[] = {1, 20, 2, 10}

Output: 72

We can 72 by rotating array twice.

{2, 10, 1, 20}

20*3 + 1*2 + 10*1 + 2*0 = 72



Input: arr[] = {10, 1, 2, 3, 4, 5, 6, 7, 8, 9};

Output: 330

We can 330 by rotating array 9 times.

{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

0*1 + 1*2 + 2*3 ... 9*10 = 330

</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>A <strong>Simple Solution</strong> is to find all rotations one by one, check sum of every rotation and return the maximum sum. Time complexity of this solution is O(n<sup>2</sup>).  </p>
<p>We can solve this problem in O(n) time using an <strong>Efficient Solution</strong>.<br/>
Let R<sub>j</sub> be value of i*arr[i] with j rotations. The idea is to calculate next rotation value from previous rotation, i.e., calculate  R<sub>j</sub> from  R<sub>j-1</sub>.  We can calculate initial value of result as   R<sub>0</sub>, then keep calculating next rotation values.  </p>
<p><strong>How to efficiently calculate R<sub>j</sub> from R<sub>j-1</sub>?</strong><br/>
This can be done in O(1) time. Below are details.</p>
<pre>

Let us calculate initial value of i*arr[i] with no rotation

R<sub>0</sub> = 0*arr[0] + 1*arr[1] +...+ (n-1)*arr[n-1]



After 1 rotation arr[n-1], becomes first element of array, 

arr[0] becomes second element, arr[1] becomes third element

and so on.

R<sub>1</sub> = 0*arr[n-1] + 1*arr[0] +...+ (n-1)*arr[n-2]



R<sub>1</sub> - R<sub>0</sub> = arr[0] + arr[1] + ... + arr[n-2] - (n-1)*arr[n-1]



After 2 rotations arr[n-2], becomes first element of array, 

arr[n-1] becomes second element, arr[0] becomes third element

and so on.

R<sub>2</sub> = 0*arr[n-2] + 1*arr[n-1] +...+ (n?1)*arr[n-3]



R<sub>2</sub> - R<sub>1</sub> = arr[0] + arr[1] + ... + arr[n-3] - (n-1)*arr[n-2] + arr[n-1]



If we take a closer look at above values, we can observe 

below pattern



R<sub>j</sub> - R<sub>j-1</sub> = arrSum - n * arr[n-j]



Where arrSum is sum of all array elements, i.e., 



arrSum = &amp;Sum; arr[i]

        i&lt;=0&lt;=n-1 

</pre>
<p>Below is complete algorithm:
<pre>

1) Compute sum of all array elements. Let this sum be 'arrSum'.



2) Compute R<sub>0</sub> by doing i*arr[i] for given array. 

   Let this value be currVal.



3) Initialize result: maxVal = currVal // maxVal is result.



// This loop computes R<sub>j</sub> from  R<sub>j-1</sub> 

4) Do following for j = 1 to n-1

......a) currVal = currVal + arrSum-n*arr[n-j];

......b) If (currVal &gt; maxVal)

            maxVal = currVal   



5) Return maxVal</pre>
<p>Below are C++ and Python implementations of above idea.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

// C++ program to find max value of i*arr[i]

#include &lt;iostream&gt;

using namespace std;



// Returns max possible value of i*arr[i]

int maxSum(int arr[], int n)

{

    // Find array sum and i*arr[i] with no rotation

    int arrSum = 0;  // Stores sum of arr[i]

    int currVal = 0;  // Stores sum of i*arr[i]

    for (int i=0; i&lt;n; i++)

    {

        arrSum = arrSum + arr[i];

        currVal = currVal+(i*arr[i]);

    }



    // Initialize result as 0 rotation sum

    int maxVal = currVal;



    // Try all rotations one by one and find

    // the maximum rotation sum.

    for (int j=1; j&lt;n; j++)

    {

        currVal = currVal + arrSum-n*arr[n-j];

        if (currVal &gt; maxVal)

            maxVal = currVal;

    }



    // Return result

    return maxVal;

}



// Driver program

int main(void)

{

    int arr[] = {10, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "\nMax sum is " &lt;&lt; maxSum(arr, n);

    return 0;

}

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]; title: ; notranslate" title="">

'''Python program to find maximum value of Sum(i*arr[i])'''



# returns max possible value of Sum(i*arr[i])

def maxSum(arr):



	# stores sum of arr[i]

	arrSum = 0	



	# stores sum of i*arr[i]

	currVal = 0

	

	n = len(arr)



	for i in range(0, n):

		arrSum = arrSum + arr[i]

		currVal = currVal + (i*arr[i])



	# initialize result

	maxVal = currVal



	# try all rotations one by one and find the maximum 

	# rotation sum

	for j in range(1, n):

		currVal = currVal + arrSum-n*arr[n-j]

		if currVal &gt; maxVal:

			maxVal = currVal



	# return result

	return maxVal



# test maxsum(arr) function

arr = [10, 1, 2, 3, 4, 5, 6, 7, 8, 9]

print "Max sum is: ", maxSum(arr)

</pre>
<p></p></div></div><br/>
Output:
<pre>

Max sum is 330</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>This article is contributed by <strong>Nitesh Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post70"> <span class="glyphicon glyphicon-collapse-down"></span>

Find maximum average subarray of k length

</button> <div id="post70" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find maximum average subarray of k length</h1>
</header>
<div class="entry-content">
<p>Given an array with positive and negative numbers, find the maximum average subarray of given length.<span id="more-135314"></span></p>
<p>Example:</p>
<pre>

Input:  arr[] = {1, 12, -5, -6, 50, 3}, k = 4

Output: Maximum average subarray of length 4 begins

        at index 1.

Maximum average is (12 - 5 - 6 + 50)/4 = 51/4

</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>A <strong>Simple Solution</strong> is to run two loops.  The outer loop picks starting point, the inner loop goes till length ‘k’ from the starting point and computes average of elements.  Time complexity of this solution is O(n*k).</p>
<p>A <strong>Better Solution</strong> is to create an auxiliary array of size n. Store cumulative sum of elements in this array. Let the array be csum[]. csum[i] stores sum of elements from arr[0] to arr[i]. Once we have csum[] array with us, we can compute sum between two indexes in O(1) time.<br/>
Below is C++ implementation of this idea.  One observation is, a subarray of given length has maximum average if it has maximum sum.  So we can avoid floating point arithmetic by just comparing sum.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]; title: ; notranslate" title="">

// C++ program to find maximum average subarray

// of given length.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns beginning index of maximum average

// subarray of length 'k'

int findMaxAverage(int arr[], int n, int k)

{

    // Check if 'k' is valid

    if (k &gt; n)

        return -1;



    // Create and fill array to store cumulative

    // sum. csum[i] stores sum of arr[0] to arr[i]

    int *csum = new int[n];

    csum[0] = arr[0];

    for (int i=1; i&lt;n; i++)

       csum[i] = csum[i-1] + arr[i];



    // Initialize max_sm as sum of first subarray

    int max_sum = csum[k-1], max_end = k-1;



    // Find sum of other subarrays and update

    // max_sum if required.

    for (int i=k; i&lt;n; i++)

    {

        int curr_sum = csum[i] - csum[i-k];

        if (curr_sum &gt; max_sum)

        {

            max_sum = curr_sum;

            max_end = i;

        }

    }



    delete [] csum; // To avoid memory leak



    // Return starting index

    return max_end - k + 1;

}



// Driver program

int main()

{

    int arr[] = {1, 12, -5, -6, 50, 3};

    int k = 4;

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "The maximum average subarray of "

         "length "&lt;&lt; k &lt;&lt; " begins at index "

         &lt;&lt; findMaxAverage(arr, n, k);

    return 0;

}

</pre>
<p>Output:
<pre>

The maximum average subarray of length 4 begins at index 1</pre>
<p>Time Complexity of above solution is O(n), but it requires O(n) auxiliary space.  </p>
<p>We can avoid need of extra space by using below <strong>Efficient Method</strong>.<br/>
1) Compute sum of first ‘k’ elements, i.e., elements arr[0..k-1]. Let this sum be ‘sum’. Initialize ‘max_sum’ as ‘sum’<br/>
2) Do following for every element arr[i] where i varies from ‘k’ to ‘n-1′<br/>
…….a) Remove arr[i-k] from sum and add arr[i], i.e., do sum += arr[i] – arr[i-k]<br/>
…….b) If new sum becomes more than max_sum so far, update max_sum.<br/>
3) Return ‘max_sum’</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34]; title: ; notranslate" title="">

// C++ program to find maximum average subarray

// of given length.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns beginning index of maximum average

// subarray of length 'k'

int findMaxAverage(int arr[], int n, int k)

{

    // Check if 'k' is valid

    if (k &gt; n)

        return -1;



    // Compute sum of first 'k' elements

    int sum = arr[0];

    for (int i=1; i&lt;k; i++)

        sum += arr[i];



    int max_sum = sum, max_end = k-1;



    // Compute sum of remaining subarrays

    for (int i=k; i&lt;n; i++)

    {

        int sum = sum + arr[i] - arr[i-k];

        if (sum &gt; max_sum)

        {

            max_sum = sum;

            max_end = i;

        }

    }



    // Return starting index

    return max_end - k + 1;

}



// Driver program

int main()

{

    int arr[] = {1, 12, -5, -6, 50, 3};

    int k = 4;

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "The maximum average subarray of "

         "length "&lt;&lt; k &lt;&lt; " begins at index "

         &lt;&lt; findMaxAverage(arr, n, k);

    return 0;

}</pre>
<p>Output:
<pre>The maximum average subarray of length 4 begins at index 1</pre>
<p>Time complexity of this method is also O(n), but it requires constant extra space.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post71"> <span class="glyphicon glyphicon-collapse-down"></span>

Convert array into Zig-Zag fashion

</button> <div id="post71" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Convert array into Zig-Zag fashion</h1>
</header>
<div class="entry-content">
<p>Given an array of distinct elements, rearrange the elements of array in zig-zag fashion in O(n) time. The converted array should be in form a &lt; b &gt; c &lt; d &gt; e &lt; f. <span id="more-135272"></span></p>
<pre>

Example: 

Input:  arr[] = {4, 3, 7, 8, 6, 2, 1}

Output: arr[] = {3, 7, 4, 8, 2, 6, 1}



Input:  arr[] =  {1, 4, 3, 2}

Output: arr[] =  {1, 4, 2, 3}</pre>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong></p>
<p>A <strong>Simple Solution</strong> is to first sort the array. After sorting, exclude the first element, swap the remaining elements in pairs. (i.e. keep arr[0] as it is, swap arr[1] and arr[2], swap arr[3] and arr[4], and so on). Time complexity is O(nlogn) since we need to sort the array first.</p>
<p>We can convert in O(n) time using an <strong>Efficient Approach</strong>. The idea is to use modified one pass of bubble sort. Maintain a flag for representing which order(i.e. &lt; or &gt;) currently we need. If the current two elements are not in that order then swap those elements otherwise not.<br/>
Let us see the main logic using three consecutive elements A, B, C.  Suppose we are processing B and C currently and the current relation is ‘&lt;'. But we have B &gt; C.  Since current relation is ‘&lt;' previous relation must be '&gt;‘ i.e., A must be greater than B. So, the relation is A &gt; B and B &gt; C.  We can deduce A &gt; C. So if we swap B and C then the relation is A &gt; C and C &lt; B. Finally we get the desired order <strong>A C B</strong> </p>
<p>Refer <a href="http://geeksquiz.com/converting-an-array-of-integers-into-zig-zag-fashion/">this </a>for more explanation.</p>
<p>Below is C++ implementation of above algorithm</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]; title: ; notranslate" title="">

// C++ program to sort an array in Zig-Zag form

#include &lt;iostream&gt;

using namespace std;



// Program for zig-zag conversion of array

void zigZag(int arr[], int n)

{

    // Flag true indicates relation "&lt;" is expected,

    // else "&gt;" is expected.  The first expected relation

    // is "&lt;"

    bool flag = true;



    for (int i=0; i&lt;=n-2; i++)

    {

        if (flag)  /* "&lt;" relation expected */

        {

            /* If we have a situation like A &gt; B &gt; C,

               we get A &gt; B &lt; C by swapping B and C */

            if (arr[i] &gt; arr[i+1])

                swap(arr[i], arr[i+1]);

        }

        else /* "&gt;" relation expected */

        {

            /* If we have a situation like A &lt; B &lt; C,

               we get A &lt; C &gt; B by swapping B and C */

            if (arr[i] &lt; arr[i+1])

                swap(arr[i], arr[i+1]);

        }

        flag = !flag; /* flip flag */

    }

}



// Driver program

int main()

{

    int  arr[] = {4, 3, 7, 8, 6, 2, 1};

    int n = sizeof(arr)/sizeof(arr[0]);

    zigZag(arr, n);

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; "  ";

    return 0;

}

</pre>
<p>Output:
<pre>3  7  4  8  2  6  1 </pre>
<p>Time complexity: O(n)<br/>
Auxiliary Space: O(1)</p>
<p>This article is contributed by <strong>Siva Krishna Aleti</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post72"> <span class="glyphicon glyphicon-collapse-down"></span>

Trapping Rain Water

</button> <div id="post72" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Trapping Rain Water</h1>
</header>
<div class="entry-content">
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<span id="more-135234"></span></p>
<p>Examples:</p>
<pre>

Input: arr[]   = {2, 0, 2}

Output: 2

Structure is like below

| |

|_|

We can trap 2 units of water in the middle gap.



Input: arr[]   = {3, 0, 0, 2, 0, 4}

Output: 10

Structure is like below

     |

|    |

|  | |

|__|_| 

We can trap "3*2 units" of water between 3 an 2,

"1 unit" on top of bar 2 and "3 units" between 2 

and 4.  See below diagram also.



Input: arr[] = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]

Output: 6

       | 

   |   || |

_|_||_||||||

Trap "1 unit" between first 1 and 2, "4 units" between

first 2 and 3 and "1 unit" between second last 1 and last 2 </pre>
<p><a href="http://d1gjlxt8vb0knt.cloudfront.net//wp-content/uploads/watertrap.png"><img alt="watertrap" class="alignnone size-full wp-image-135235" height="390" src="http://d1gjlxt8vb0knt.cloudfront.net//wp-content/uploads/watertrap.png" width="310"/></a></p>
<p>Source: <a href="http://qa.geeksforgeeks.org/1875/trapping-rain-water">http://qa.geeksforgeeks.org/1875/trapping-rain-water</a><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=281" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
An element of array can store water if there are higher bars on left and right.   We can find amount of water to be stored in every element by finding the heights of bars on left and right sides.  The idea is to compute amount of water that can be stored in every element of array.   For example, consider the array {3, 0, 0, 2, 0, 4}, we can store two units of water at indexes 1 and 2, and one unit of water at index 2.</p>
<p>A <strong>Simple Solution</strong> is to traverse every array element and find the highest bars on left and right sides.  Take the smaller of two heights.  The difference between smaller height and height of current element is the amount of water that can be stored in this array element. Time complexity of this solution is O(n<sup>2</sup>).</p>
<p>An <strong>Efficient Solution</strong> is to prre-compute highest bar on left and right of every bar in O(n) time.  Then use these pre-computed values to find the amount of water in every array element.  Below is C++ implementation of this solution.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]; title: ; notranslate" title="">

// C++ program to find maximum amount of water that can

// be trapped within given set of bars.

#include&lt;bits/stdc++.h&gt;

using namespace std;



int findWater(int arr[], int n)

{

    // left[i] contains height of tallest bar to the

    // left of i'th bar including itself

    int left[n];



    // Right [i] contains height of tallest bar to

    // the right of ith bar including itself

    int right[n];



    // Initialize result

    int water = 0;



    // Fill left array

    left[0] = arr[0];

    for (int i = 1; i &lt; n; i++)

       left[i] = max(left[i-1], arr[i]);



    // Fill right array

    right[n-1] = arr[n-1];

    for (int i = n-2; i &gt;= 0; i--)

       right[i] = max(right[i+1], arr[i]);



    // Calculate the accumulated water element by element

    // consider the amount of water on i'th bar, the

    // amount of water accumulated on this particular

    // bar will be equal to min(left[i], right[i]) - arr[i] .

    for (int i = 0; i &lt; n; i++)

       water += min(left[i],right[i]) - arr[i];



    return water;

}



// Driver program

int main()

{

    int arr[] = {0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Maximum water that can be accumulated is "

         &lt;&lt; findWater(arr, n);

    return 0;

}</pre>
<p>Output:
<pre>Maximum water that can be accumulated is 6</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n)</p>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a> for above solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post73"> <span class="glyphicon glyphicon-collapse-down"></span>

Minimum number of swaps required for arranging pairs adjacent to each other

</button> <div id="post73" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Minimum number of swaps required for arranging pairs adjacent to each other</h1>
</header>
<div class="entry-content">
<p>There are n-pairs and therefore 2n people. everyone has one unique number ranging from 1 to 2n. All these 2n persons are arranged in random fashion in an Array of size 2n. We are also given who is partner of whom.<span id="more-135216"></span> Find the minimum number of swaps required to arrange these pairs such that all pairs become adjacent to each other.</p>
<p>Example:
<pre>

Input:

n = 3  

pairs[] = {1-&gt;3, 2-&gt;6, 4-&gt;5}  // 1 is partner of 3 and so on

arr[] = {3, 5, 6, 4, 1, 2}



Output: 2

We can get {3, 1, 5, 4, 6, 2} by swapping 5 &amp; 6, and 6 &amp; 1</pre>
<p>Source: <a href="http://qa.geeksforgeeks.org/1666/google-interview-question-minimum-no-of-swaps">Google Interview Question</a></p>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>The idea is to start from first and second elements and recur for remaining elements. Below are detailed steps/</p>
<pre>

1) If first and second elements are pair, then simply recur 

   for remaining n-1 pairs and return the value returned by 

   recursive call.



2) If first and second are NOT pair, then there are two ways to 

   arrange. So try both of them return the minimum of two.

   a) Swap second with pair of first and recur for n-1 elements. 

      Let the value returned by recursive call be 'a'.

   b) Revert the changes made by previous step.

   c) Swap first with pair of second and recur for n-1 elements. 

      Let the value returned by recursive call be 'b'.

   d) Revert the changes made by previous step before returning

      control to parent call.

   e) Return 1 + min(a, b)

</pre>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71]; title: ; notranslate" title="">

// C++ program to find minimum number of swaps required so that

// all pairs become adjacent.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// This function updates indexes of elements 'a' and 'b'

void updateindex(int index[], int a, int ai, int b, int bi)

{

    index[a] = ai;

    index[b] = bi;

}



// This function returns minimum number of swaps required to arrange

// all elements of arr[i..n] become aranged

int minSwapsUtil(int arr[], int pairs[], int index[], int i, int n)

{

    // If all pairs procesed so no swapping needed return 0

    if (i &gt; n) return 0;



    // If current pair is valid so DO NOT DISTURB this pair

    // and move ahead.

    if (pairs[arr[i]] == arr[i+1])

         return minSwapsUtil(arr, pairs, index, i+2, n);



    // If we reach here, then arr[i] and arr[i+1] don't form a pair



    // Swap pair of arr[i] with arr[i+1] and recursively compute

    // minimum swap required if this move is made.

    int one = arr[i+1];

    int indextwo = i+1;

    int indexone = index[pairs[arr[i]]];

    int two = arr[index[pairs[arr[i]]]];

    swap(arr[i+1], arr[indexone]);

    updateindex(index, one, indexone, two, indextwo);

    int a = minSwapsUtil(arr, pairs, index, i+2, n);



    // Backtrack to previous configuration. Also restore the

    // previous indices, of one and two

    swap(arr[i+1], arr[indexone]);

    updateindex(index, one, indextwo, two, indexone);

    one = arr[i], indexone = index[pairs[arr[i+1]]];



    // Now swap arr[i] with pair of arr[i+1] and recursively

    // compute minimum swaps required for the subproblem

    // after this move

    two = arr[index[pairs[arr[i+1]]]], indextwo = i;

    swap(arr[i], arr[indexone]);

    updateindex(index, one, indexone, two, indextwo);

    int b = minSwapsUtil(arr, pairs, index, i+2, n);



    // Backtrack to previous configuration.  Also restore

    // the previous indices, of one and two

    swap(arr[i], arr[indexone]);

    updateindex(index, one, indextwo, two, indexone);



    // Return minimum of two cases

    return 1 + min(a, b);

}



// Returns minimum swaps required

int minSwaps(int n, int pairs[], int arr[])

{

    int index[2*n + 1]; // To store indices of array elements



    // Store index of each element in array index

    for (int i = 1; i &lt;= 2*n; i++)

        index[arr[i]] = i;



    // Call the recursive function

    return minSwapsUtil(arr, pairs, index, 1, 2*n);

}



// Driver program

int main()

{

    // For simplicity, it is assumed that arr[0] is

    // not used.  The elements from index 1 to n are

    // only valid elements

    int arr[] = {0, 3, 5, 6, 4, 1, 2};



    // if (a, b) is pair than we have assigned elements

    // in array such that pairs[a] = b and pairs[b] = a

    int pairs[] = {0, 3, 6, 1, 5, 4, 2};

    int m = sizeof(arr)/sizeof(arr[0]);



    int n = m/2;  // Number of pairs n is half of total elements



    // If there are n elements in array, then

    // there are n pairs

    cout &lt;&lt; "Min swaps required is " &lt;&lt; minSwaps(n, pairs, arr);

    return 0;

}

</pre>
<p>Output:
<pre>Min swaps required is 2</pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a> for above solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post74"> <span class="glyphicon glyphicon-collapse-down"></span>

Generate all possible sorted arrays from alternate elements of two given sorted arrays

</button> <div id="post74" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Generate all possible sorted arrays from alternate elements of two given sorted arrays</h1>
</header>
<div class="entry-content">
<p>Given two sorted arrays A and B, generate all possible arrays such that first element is taken from A then from B then from A and so on in increasing order till the arrays exhausted.<span id="more-135063"></span> The generated arrays should end with an element from B.</p>
<pre>

For Example 

A = {10, 15, 25}

B = {1, 5, 20, 30}



The resulting arrays are:

  10 20

  10 20 25 30

  10 30

  15 20

  15 20 25 30

  15 30

  25 30</pre>
<p><strong>Source:</strong> <a href="http://qa.geeksforgeeks.org/251/asked-in-microsoft">Microsoft Interview Question</a></p>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong></p>
<p>The idea is to use recursion.  In the recursive function, a flag is passed to indicate whether current element in output should be taken from ‘A’ or ‘B’.  Below is C++ implementation.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62]; title: ; notranslate" title="">

#include&lt;bits/stdc++.h&gt;

using namespace std;



void printArr(int arr[], int n);



/* Function to generates and prints all sorted arrays from alternate elements of

   'A[i..m-1]' and 'B[j..n-1]'

   If 'flag' is true, then current element is to be included from A otherwise

   from B.

   'len' is the index in output array C[]. We print output  array  each time

   before including a character from A only if length of output array is

   greater than 0. We try than all possible combinations */

void generateUtil(int A[], int B[], int C[], int i, int j, int m, int n,

                  int len, bool flag)

{

    if (flag) // Include valid element from A

    {

        // Print output if there is at least one 'B' in output array 'C'

        if (len)

            printArr(C, len+1);



        // Recur for all elements of A after current index

        for (int k = i; k &lt; m; k++)

        {

            if (!len)

            {

                /* this block works for the very first call to include

                 	the first element in the output array */

                C[len] = A[k];



                // don't increment lem as B is included yet

                generateUtil(A, B, C, k+1, j, m, n, len, !flag);

            }

            else  	/* include valid element from A and recur */

            {

                if (A[k] &gt; C[len])

                {

                    C[len+1] = A[k];

                    generateUtil(A, B, C, k+1, j, m, n, len+1, !flag);

                }

            }

        }

    }

    else   /* Include valid element from B and recur */

    {

        for (int l = j; l &lt; n; l++)

        {

            if (B[l] &gt; C[len])

            {

                C[len+1] = B[l];

                generateUtil(A, B, C, i, l+1, m, n, len+1, !flag);

            }

        }

    }

}



/* Wrapper function */

void generate(int A[], int B[], int m, int n)

{

    int C[m+n];	/* output array */

    generateUtil(A, B, C, 0, 0, m, n, 0, true);

}



// A utility function to print an array

void printArr(int arr[], int n)

{

    for (int i = 0; i &lt; n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";

    cout &lt;&lt; endl;

}



// Driver program

int main()

{

    int A[] = {10, 15, 25};

    int B[] = {5, 20, 30};

    int n = sizeof(A)/sizeof(A[0]);

    int m = sizeof(B)/sizeof(B[0]);

    generate(A, B, n, m);

    return 0;

}

</pre>
<p>Output:
<pre>10 20

10 20 25 30

10 30

15 20

15 20 25 30

15 30

25 30</pre>
<p>This article is contributed by <a href="https://www.facebook.com/COOL.DUDE.BORN.NUD3?fref=ts">Gaurav Ahirwar</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above\</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post75"> <span class="glyphicon glyphicon-collapse-down"></span>

Count frequencies of all elements in array in O(1) extra space and O(n) time

</button> <div id="post75" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count frequencies of all elements in array in O(1) extra space and O(n) time</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array of n integers which can contain integers from 1 to n. Some elements can be repeated multiple times and some other elements can be absent from the array. <span id="more-134951"></span> Count frequency of all elements that are present and print the missing elements.</p>
<p><strong>Examples:</strong></p>
<pre>Input: arr[] = {2, 3, 3, 2, 5}

Output: Below are frequencies of all elements

        1 -&gt; 0

        2 -&gt; 2

        3 -&gt; 2

        4 -&gt; 0

        5 -&gt; 1



Input: arr[] = {4, 4, 4, 4}

Output: Below are frequencies of all elements

        1 -&gt; 0

        2 -&gt; 0

        3 -&gt; 0

        4 -&gt; 4</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=84" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
A <strong>Simple Solution</strong> is to create a count array of size n as the elements are in range from 1 to n. This solution works in O(n) time, but requires O(n) extra space.</p>
<p><strong>How to do it in O(1) extra space and O(n) time?</strong></p>
<p>Below are two methods to solve this in O(n) time and O(1) extra space. Both method modify given array to achieve O(1) extra space.</p>
<p><strong>Method 1 (By making elements negative)</strong><br/>
The idea is to traverse the given array, use elements as index and store their counts at the index. For example, when we see element 7, we go to index 6 and store the count. There are few problems to handle, one is the counts can get mixed with the elements, this is handled by storing the counts as negative. Other problem is loosing the element which is replaced by count, this is handled by first storing the element to be replaced at current index.</p>
<pre>

<strong>Algorithm:</strong>

1) Initialize i as 0

2) Do following while i &lt; n



   // If this element is already processed,

   // then nothing to do

   a) If arr[i] &lt;= 0

        i++;

        continue the loop from beginning



    // Find index corresponding to this element

    // For example, index for 5 is 4

    b)  elementIndex = arr[i]-1;

    

    // If the elementIndex has an element that is not

    // processed yet, then first store that element

    // to arr[i] so that we don't loose anything.

    c) if (arr[elementIndex] &gt; 0)

         (i) arr[i] = arr[elementIndex];



         // After storing arr[elementIndex], change it

         // to store initial count of 'arr[i]'

         (ii) arr[elementIndex] = -1;



     d) else       

            // If this is NOT first occurrence of arr[i],

            // then increment its count.

          (i) arr[elementIndex]--;



            // And initialize arr[i] as 0 means the element

            // 'i+1' is not seen so far

          (ii) arr[i] = 0;

          (iii) i++;



3) Now -arr[i] stores count of i+1. 

</pre>
<p>Below is C++ implementation of the above approach.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate" title="">

// C++ program to print frequencies of all array

// elements in O(1) extra space and O(n) time

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Function to find counts of all elements present in

// arr[0..n-1]. The array elements must be range from

// 1 to n

void findCounts(int *arr, int n)

{

    // Traverse all array elements

    int i = 0;

    while (i&lt;n)

    {

        // If this element is already processed,

        // then nothing to do

        if (arr[i] &lt;= 0)

        {

            i++;

            continue;

        }



        // Find index corresponding to this element

        // For example, index for 5 is 4

        int elementIndex = arr[i]-1;



        // If the elementIndex has an element that is not

        // processed yet, then first store that element

        // to arr[i] so that we don't loose anything.

        if (arr[elementIndex] &gt; 0)

        {

            arr[i] = arr[elementIndex];



            // After storing arr[elementIndex], change it

            // to store initial count of 'arr[i]'

            arr[elementIndex] = -1;

        }

        else

        {

            // If this is NOT first occurrence of arr[i],

            // then increment its count.

            arr[elementIndex]--;



            // And initialize arr[i] as 0 means the element

            // 'i+1' is not seen so far

            arr[i] = 0;

            i++;

        }

    }



    printf("\nBelow are counts of all elements\n");

    for (int i=0; i&lt;n; i++)

        printf("%d -&gt; %d\n", i+1, abs(arr[i]));

}



// Driver program to test above function

int main()

{

    int arr[] = {2, 3, 3, 2, 5};

    findCounts(arr, sizeof(arr)/ sizeof(arr[0]));



    int arr1[] = {1};

    findCounts(arr1, sizeof(arr1)/ sizeof(arr1[0]));



    int arr3[] = {4, 4, 4, 4};

    findCounts(arr3, sizeof(arr3)/ sizeof(arr3[0]));



    int arr2[] = {1, 3, 5, 7, 9, 1, 3, 5, 7, 9, 1};

    findCounts(arr2, sizeof(arr2)/ sizeof(arr2[0]));



    int arr4[] = {3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};

    findCounts(arr4, sizeof(arr4)/ sizeof(arr4[0]));



    int arr5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};

    findCounts(arr5, sizeof(arr5)/ sizeof(arr5[0]));



    int arr6[] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};

    findCounts(arr6, sizeof(arr6)/ sizeof(arr6[0]));



    return 0;

}

</pre>
<p>Output:</p>
<pre>Below are counts of all elements

1 -&gt; 0

2 -&gt; 2

3 -&gt; 2

4 -&gt; 0

5 -&gt; 1



Below are counts of all elements

1 -&gt; 1



Below are counts of all elements

1 -&gt; 0

2 -&gt; 0

3 -&gt; 0

4 -&gt; 4



Below are counts of all elements

1 -&gt; 3

2 -&gt; 0

3 -&gt; 2

4 -&gt; 0

5 -&gt; 2

6 -&gt; 0

7 -&gt; 2

8 -&gt; 0

9 -&gt; 2

10 -&gt; 0

11 -&gt; 0



Below are counts of all elements

1 -&gt; 0

2 -&gt; 0

3 -&gt; 11

4 -&gt; 0

5 -&gt; 0

6 -&gt; 0

7 -&gt; 0

8 -&gt; 0

9 -&gt; 0

10 -&gt; 0

11 -&gt; 0



Below are counts of all elements

1 -&gt; 1

2 -&gt; 1

3 -&gt; 1

4 -&gt; 1

5 -&gt; 1

6 -&gt; 1

7 -&gt; 1

8 -&gt; 1

9 -&gt; 1

10 -&gt; 1

11 -&gt; 1



Below are counts of all elements

1 -&gt; 1

2 -&gt; 1

3 -&gt; 1

4 -&gt; 1

5 -&gt; 1

6 -&gt; 1

7 -&gt; 1

8 -&gt; 1

9 -&gt; 1

10 -&gt; 1

11 -&gt; 1</pre>
<p><strong>How does above program work?</strong><br/>
Let us take below example to see step by step processing of<br/>
above program:<br/>
arr[] = {2, 3, 3, 2, 5}</p>
<p><strong>i = 0, arr[i] = 2, arr[] = {2, 3, 3, 2, 5}</strong><br/>
Since arr[i] &gt; 0, find elementIndex.<br/>
elementIndex = arr[i] – 1 = 2 – 1 = 1,<br/>
arr[elementIndex] or arr[1] is 3<br/>
Since arr[elementIndex] is postive,<br/>
arr[i] = arr[elementIndex] = 3<br/>
arr[elementIndex] = -1 // 2 is seen 1 times so far<br/>
i is not changed.</p>
<p><strong>i = 0, arr[i] = 3, arr[] = {3, -1, 3, 2, 5}</strong><br/>
Since arr[i] &gt; 0, find elementIndex.<br/>
elementIndex = arr[i] – 1 = 3 – 1 = 2<br/>
arr[elementIndex] or arr[2] is 3<br/>
Since arr[elementIndex] is postive<br/>
arr[i] = arr[elementIndex] = 3<br/>
arr[elementIndex] = -1 // 3 is seen 1 times so far<br/>
i is not changed.</p>
<p><strong>i = 0, arr[i] = 3, arr[] = {3, -1, -1, 2, 5}</strong><br/>
Since arr[i] &gt; 0, find elementIndex.<br/>
elementIndex = arr[i] – 1 = 3 – 1 = 2<br/>
arr[elementIndex] or arr[2] is -1<br/>
Since arr[elementIndex] is negative<br/>
arr[elementIndex] = arr[elementIndex] – 1<br/>
= -2 // 3 is seen 2 times so far<br/>
arr[i] = 0 // 1 is not seen so far<br/>
i is incremented</p>
<p><strong>i = 1, arr[i] = -1, arr[] = {0, -1, -2, 2, 5}</strong><br/>
Since arr[i] is negative, increment i</p>
<p><strong>i = 2, arr[i] = -2, arr[] = {0, -1, -2, 2, 5}</strong><br/>
Since arr[i] is negative, increment i</p>
<p><strong>i = 3, arr[i] = 2, arr[] = {0, -1, -2, 2, 5}</strong><br/>
Since arr[i] &gt; 0, we find elementIndex.<br/>
elementIndex = arr[i] – 1 = 2 – 1 = 1<br/>
arr[elementIndex] or arr[1] is -1<br/>
Since arr[elementIndex] is negative<br/>
arr[elementIndex] = arr[elementIndex] – 1<br/>
= -2 // 2 is seen 2 times so far<br/>
arr[i] = 0 // 4 is not seen so far<br/>
i is incremented</p>
<p><strong>i = 4, arr[i] = 5, arr[] = {0, -2, -2, 0, 5}</strong><br/>
Since arr[i] &gt; 0, we find elementIndex.<br/>
elementIndex = arr[i] – 1 = 5 – 1 = 4<br/>
arr[elementIndex] or arr[4] is 5<br/>
Since arr[elementIndex] is postive<br/>
arr[i] = arr[elementIndex] = 4<br/>
arr[elementIndex] = -1 // 5 is seen 1 times so far<br/>
i is not changed.</p>
<p><strong>i = 1, arr[i] = -1, arr[] = {0, -2, -2, 0, -1}</strong><br/>
Since arr[i] is negative, increment i</p>
<p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post76"> <span class="glyphicon glyphicon-collapse-down"></span>

Find Union and Intersection of two unsorted arrays

</button> <div id="post76" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find Union and Intersection of two unsorted arrays</h1>
</header>
<div class="entry-content">
<p>Given two unsorted arrays that represent two sets (elements in every array are distinct), find union and intersection of two arrays.<span id="more-134765"></span></p>
<p>For example, if the input arrays are:<br/>
arr1[] = {7, 1, 5, 2, 3, 6}<br/>
arr2[] = {3, 8, 6, 20, 7}<br/>
Then your program should print Union as {1, 2, 3, 5, 6, 7, 8, 20} and Intersection as {3, 6}.  Note that the elements of union and intersection can be printed in any order.</p>
<div id="practice"></div>
<p><u><strong>Method 1 (Naive)</strong></u><br/>
<em><strong>Union:</strong> </em><br/>
1) Initialize union U as empty.<br/>
2) Copy all elements of first array to U.<br/>
3) Do following for every element x of second array:<br/>
…..a) If x is not present in first array, then copy x to U.<br/>
4) Return U.</p>
<p><em><strong>Intersection:</strong> </em><br/>
1) Initialize intersection I as empty.<br/>
2) Do following for every element x of first array<br/>
…..a) If x is present in second array, then copy x to I.<br/>
4) Return I.</p>
<p>Time complexity of this method is O(mn) for both operations. Here m and n are number of elements in arr1[] and arr2[] respectively.</p>
<p><u><strong>Method 2 (Use Sorting)</strong></u><br/>
1) Sort arr1[] and arr2[]. This step takes O(mLogm + nLogn) time.<br/>
2) Use <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/">O(m + n) algorithms to find union and intersection of two sorted arrays</a>.</p>
<p>Overall time complexity of this method is O(mLogm + nLogn).</p>
<p><strong>Method 3 (Use Sorting and Searching)</strong><br/>
<em><strong>Union:</strong></em><br/>
1) Initialize union U as empty.<br/>
2) Find smaller of m and n and sort the smaller array.<br/>
3) Copy the smaller array to U.<br/>
4) For every element x of larger array, do following<br/>
…….b) Binary Search x in smaller array. If x is not present, then copy it to U.<br/>
5) Return U.</p>
<p><em><strong>Intersection:</strong></em><br/>
1) Initialize intersection I as empty.<br/>
2) Find smaller of m and n and sort the smaller array.<br/>
3) For every element x of larger array, do following<br/>
…….b) Binary Search x in smaller array. If x is present, then copy it to I.<br/>
4) Return I.</p>
<p>Time complexity of this method is min(mLogm + nLogm,  mLogn + nLogn) which can also be written as O((m+n)Logm, (m+n)Logn).  This approach works much better than the previous approach when difference between sizes of two arrays is significant.</p>
<p>Thanks to <a href="https://disqus.com/by/use_the_force/">use_the_force</a> for suggesting this method in a comment <a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/">here</a>. </p>
<p>Below is C++ implementation of this method.</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]; title: ; notranslate" title="">

// A C++ program to print union and intersection of two unsorted arrays

#include &lt;iostream&gt;

#include &lt;algorithm&gt;

using namespace std;



int binarySearch(int arr[], int l, int r, int x);



// Prints union of arr1[0..m-1] and arr2[0..n-1]

void printUnion(int arr1[], int arr2[], int m, int n)

{

    // Before finding union, make sure arr1[0..m-1] is smaller

    if (m &gt; n)

    {

        int *tempp = arr1;

        arr1 = arr2;

        arr2 = tempp;



        int temp = m;

        m = n;

        n = temp;

    }



    // Now arr1[] is smaller



    // Sort the first array and print its elements (these two

    // steps can be swapped as order in output is not important)

    sort(arr1, arr1 + m);

    for (int i=0; i&lt;m; i++)

        cout &lt;&lt; arr1[i] &lt;&lt; " ";



    // Search every element of bigger array in smaller array

    // and print the element if not found

    for (int i=0; i&lt;n; i++)

        if (binarySearch(arr1, 0, m-1, arr2[i]) == -1)

            cout &lt;&lt; arr2[i] &lt;&lt; " ";

}



// Prints intersection of arr1[0..m-1] and arr2[0..n-1]

void printIntersection(int arr1[], int arr2[], int m, int n)

{

    // Before finding intersection, make sure arr1[0..m-1] is smaller

    if (m &gt; n)

    {

        int *tempp = arr1;

        arr1 = arr2;

        arr2 = tempp;



        int temp = m;

        m = n;

        n = temp;

    }



    // Now arr1[] is smaller



    // Sort smaller array arr1[0..m-1]

    sort(arr1, arr1 + m);



    // Search every element of bigger array in smaller array

    // and print the element if found

    for (int i=0; i&lt;n; i++)

        if (binarySearch(arr1, 0, m-1, arr2[i]) != -1)

            cout &lt;&lt; arr2[i] &lt;&lt; " ";

}



// A recursive binary search function. It returns location of x in

// given array arr[l..r] is present, otherwise -1

int binarySearch(int arr[], int l, int r, int x)

{

    if (r &gt;= l)

    {

        int mid = l + (r - l)/2;



        // If the element is present at the middle itself

        if (arr[mid] == x)  return mid;



        // If element is smaller than mid, then it can only be present

        // in left subarray

        if (arr[mid] &gt; x) return binarySearch(arr, l, mid-1, x);



        // Else the element can only be present in right subarray

        return binarySearch(arr, mid+1, r, x);

    }



    // We reach here when element is not present in array

    return -1;

}



/* Driver program to test above function */

int main()

{

    int arr1[] = {7, 1, 5, 2, 3, 6};

    int arr2[] = {3, 8, 6, 20, 7};

    int m = sizeof(arr1)/sizeof(arr1[0]);

    int n = sizeof(arr2)/sizeof(arr2[0]);

    cout &lt;&lt; "Union of two arrays is \n";

    printUnion(arr1, arr2, m, n);

    cout &lt;&lt; "\nIntersection of two arrays is \n";

    printIntersection(arr1, arr2, m, n);

    return 0;

}

</pre>
<p>Output:
<pre>Union of two arrays is

3 6 7 8 20 1 5 2

Intersection of two arrays is

7 3 6</pre>
<p><u><strong>Method 4 (Use Hashing)</strong></u><br/>
<em><strong>Union:</strong></em><br/>
1) Initialize union U as empty.<br/>
1) Initialize an empty hash table.<br/>
2) Iterate through first array and put every element of first array in the hash table, and in U.<br/>
4) For every element x of second array, do following<br/>
…….a) Search x in the hash table. If x is not present, then copy it to U.<br/>
5) Return U.</p>
<p><em><strong>Intersection:</strong></em><br/>
1) Initialize intersection I as empty.<br/>
2) In initialize an empty hash table.<br/>
3) Iterate through first array and put every element of first array in the hash table.<br/>
4) For every element x of second array, do following<br/>
…….a) Search x in the hash table. If x is present, then copy it to I.<br/>
5) Return I.</p>
<p>Time complexity of this method is Θ(m+n) under the assumption that hash table search and insert operations take Θ(1) time.</p>
<div id="company_tags"></div>
<p>See following post for sorted arrays.<br/>
<a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/">Find Union and Intersection of two sorted arrays</a></p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post77"> <span class="glyphicon glyphicon-collapse-down"></span>

Pythagorean Triplet in an array

</button> <div id="post77" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Pythagorean Triplet in an array</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, write a function that returns true if there is a triplet (a, b, c) that satisfies a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup>.<span id="more-134718"></span></p>
<p>Example:</p>
<pre>

Input: arr[] = {3, 1, 4, 6, 5}

Output: True

There is a Pythagorean triplet (3, 4, 5).



Input: arr[] = {10, 4, 6, 12, 5}

Output: False

There is no Pythagorean triplet.

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=283" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Naive)</strong><br/>
A simple solution is to run three loops, three loops pick three array elements and check if current three elements form a Pythagorean Triplet.  </p>
<p>Below is C++ implementation of simple solution.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate" title="">

// A C++ program that returns true if there is a Pythagorean

// Triplet in a given aray.

#include &lt;iostream&gt;

using namespace std;



// Returns true if there is Pythagorean triplet in ar[0..n-1]

bool isTriplet(int ar[], int n)

{

    for (int i=0; i&lt;n; i++)

    {

       for (int j=i+1; j&lt;n; j++)

       {

          for (int k=j+1; k&lt;n; k++)

          {

            // Calculate square of array elements

            int x = ar[i]*ar[i], y = ar[j]*ar[j], z = ar[k]*ar[k];



            if (x == y + z || y == x + z || z == x + y)

                 return true;

          }

       }

    }



    // If we reach here, no triplet found

    return false;

}



/* Driver program to test above function */

int main()

{

    int ar[] = {3, 1, 4, 6, 5};

    int ar_size = sizeof(ar)/sizeof(ar[0]);

    isTriplet(ar, ar_size)? cout &lt;&lt; "Yes": cout &lt;&lt; "No";

    return 0;

}</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; title: ; notranslate" title="">

// A Java program that returns true if there is a Pythagorean

// Triplet in a given aray.

import java.io.*;



class PythagoreanTriplet {

    

    // Returns true if there is Pythagorean triplet in ar[0..n-1]

    static boolean isTriplet(int ar[], int n)

    {

        for (int i=0; i&lt;n; i++)

        {

            for (int j=i+1; j&lt;n; j++)

            {    

                for (int k=j+1; k&lt;n; k++)

                {

                    // Calculate square of array elements

                    int x = ar[i]*ar[i], y = ar[j]*ar[j], z = ar[k]*ar[k];

 

                    if (x == y + z || y == x + z || z == x + y)

                        return true;

                }

            }

        }

 

        // If we reach here, no triplet found

        return false;

    }

    

    

    // Driver program to test above function

    public static void main(String[] args)

    {

        int ar[] = {3, 1, 4, 6, 5};

        int ar_size = ar.length;

        if(isTriplet(ar,ar_size)==true)

           System.out.println("Yes");

        else

           System.out.println("No");        

    }

}

/* This code is contributed by Devesh Agrawal */

</pre>
<p></p></div></div><br/>
Output:
<pre>Yes</pre>
<p>Time Complexity of the above solution is O(n<sup>3</sup>).  </p>
<p> </p>
<p><strong>Method 2 (Use Sorting)</strong><br/>
We can solve this in O(n<sup>2</sup>) time by sorting the array first.  </p>
<p>1) Do square of every element in input array. This step takes O(n) time.</p>
<p>2) Sort the squared array in increasing order. This step takes O(nLogn) time.</p>
<p>3) To find a triplet (a, b, c) such that a = b + c, do following.
<ol type="a">
<li> Fix ‘a’ as last element of sorted array.</li>
<li>  Now search for pair (b, c) in subarray between first element and ‘a’.  A pair (b, c) with given sum can be found in O(n) time using meet in middle algorithm discussed in method 1 of <a href="http://www.geeksforgeeks.org/write-a-c-program-that-given-a-set-a-of-n-numbers-and-another-number-x-determines-whether-or-not-there-exist-two-elements-in-s-whose-sum-is-exactly-x/">this </a>post. </li>
<li> If no pair found for current ‘a’, then move ‘a’ one position back and repeat step 3.2.</li>
</ol>
<p>Below is C++ implementation of above algorithm.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate" title="">

// A C++ program that returns true if there is a Pythagorean

// Triplet in a given array.

#include &lt;iostream&gt;

#include &lt;algorithm&gt;

using namespace std;



// Returns true if there is a triplet with following property

// A[i]*A[i] = A[j]*A[j] + A[k]*[k]

// Note that this function modifies given array

bool isTriplet(int arr[], int n)

{

    // Square array elements

    for (int i=0; i&lt;n; i++)

        arr[i] = arr[i]*arr[i];



    // Sort array elements

    sort(arr, arr + n);



    // Now fix one element one by one and find the other two

    // elements

    for (int i = n-1; i &gt;= 2; i--)

    {

        // To find the other two elements, start two index

        // variables from two corners of the array and move

        // them toward each other

        int l = 0; // index of the first element in arr[0..i-1]

        int r = i-1; // index of the last element in arr[0..i-1]

        while (l &lt; r)

        {

            // A triplet found

            if (arr[l] + arr[r] == arr[i])

                return true;



            // Else either move 'l' or 'r'

            (arr[l] + arr[r] &lt; arr[i])?  l++: r--;

        }

    }



    // If we reach here, then no triplet found

    return false;

}



/* Driver program to test above function */

int main()

{

    int arr[] = {3, 1, 4, 6, 5};

    int arr_size = sizeof(arr)/sizeof(arr[0]);

    isTriplet(arr, arr_size)? cout &lt;&lt; "Yes": cout &lt;&lt; "No";

    return 0;

}

</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate" title="">

// A Java program that returns true if there is a Pythagorean

// Triplet in a given aray.

import java.io.*;

import java.util.*;



class PythagoreanTriplet 

{    

    // Returns true if there is a triplet with following property

    // A[i]*A[i] = A[j]*A[j] + A[k]*[k]

    // Note that this function modifies given array

    static boolean isTriplet(int arr[], int n)

    {

        // Square array elements

        for (int i=0; i&lt;n; i++)

            arr[i] = arr[i]*arr[i];

 

        // Sort array elements

        Arrays.sort(arr);

 

        // Now fix one element one by one and find the other two

        // elements

        for (int i = n-1; i &gt;= 2; i--)

        {

            // To find the other two elements, start two index

            // variables from two corners of the array and move

            // them toward each other

            int l = 0; // index of the first element in arr[0..i-1]

            int r = i-1; // index of the last element in arr[0..i-1]

            while (l &lt; r)

            {

                // A triplet found

                if (arr[l] + arr[r] == arr[i])

                    return true;

 

                // Else either move 'l' or 'r'

                if (arr[l] + arr[r] &lt; arr[i])

                   l++;

                else

                   r--;

            }

        }

 

        // If we reach here, then no triplet found

        return false;

    }

    

    

    // Driver program to test above function

    public static void main(String[] args)

    {

        int arr[] = {3, 1, 4, 6, 5};

        int arr_size = arr.length;

        if (isTriplet(arr,arr_size)==true)

           System.out.println("Yes");

        else

           System.out.println("No");        

    }

}

/*This code is contributed by Devesh Agrawal*/

</pre>
</div></div>
<p>Output:
<pre> Yes </pre>
<p>Time complexity of this method is O(n<sup>2</sup>).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/oNtexwxSZ3s?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Harshit Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post78"> <span class="glyphicon glyphicon-collapse-down"></span>

Print missing elements that lie in range 0 – 99

</button> <div id="post78" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Print missing elements that lie in range 0 – 99</h1>
</header>
<div class="entry-content">
<p>Given an array of integers print the missing elements that lie in range 0-99.  If there are more than one missing, collate them, otherwise just print the number.<span id="more-134698"></span></p>
<p>Note that the input array may not be sorted and may contain numbers outside the range [0-99], but only this range is to be considered for printing missing elements.</p>
<p>Examples</p>
<pre>

     Input: {88, 105, 3, 2, 200, 0, 10}

     Output: 1

             4-9

             11-87

             89-99





     Input: {9, 6, 900, 850, 5, 90, 100, 99}

     Output: 0-4

             7-8

             10-89

             91-98</pre>
<p>Expected time complexity O(n), where n is the size of the input array.</p>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong></p>
<p>The idea is to use a boolean array of size 100 to keep track of array elements that lie in range 0 to 99.  We first traverse input array and mark such present elements in the boolean array.  Once all present elements are marked, the boolean array is used to print missing elements. </p>
<p>Following is C implementation of above idea.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]; title: ; notranslate" title="">

// C program for print missing elements

#include&lt;stdio.h&gt;

#define LIMIT 100



// A O(n) function to print missing elements in an array

void printMissing(int arr[], int n)

{

    // Initialize all number from 0 to 99 as NOT seen

    bool seen[LIMIT] = {false};



    // Mark present elements in range [0-99] as seen

    for (int i=0; i&lt;n; i++)

      if (arr[i] &lt; LIMIT)

       seen[arr[i]] = true;



    // Print missing element

    int i = 0;

    while (i &lt; LIMIT)

    {

        // If i is missing

        if (seen[i] == false)

        {

            // Find if there are more missing elements after i

            int j = i+1;

            while (j &lt; LIMIT &amp;&amp; seen[j] == false)

                  j++;



            // Print missing single or range

            (i+1 == j)? printf("%d\n", i): printf("%d-%d\n", i, j-1);



            // Update u

            i = j;

        }

        else

            i++;

    }

}



// Driver program

int main()

{

    int arr[] = {88, 105, 3, 2, 200, 0, 10};

    int n = sizeof(arr)/sizeof(arr[0]);

    printMissing(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>1

4-9

11-87

89-99</pre>
<p>Time complexity of the above program is O(n).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/qjNVJTUge7s?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <a href="https://sites.google.com/a/asu.edu/vignesh-narayanan/">Vignesh Narayanan</a> and <a href="https://sites.google.com/a/usc.edu/sowmya/">Sowmya Sampath</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post79"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange an array such that ‘arr[j]’ becomes ‘i’ if  ‘arr[i]’ is ‘j’

</button> <div id="post79" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange an array such that ‘arr[j]’ becomes ‘i’ if  ‘arr[i]’ is ‘j’</h1>
</header>
<div class="entry-content">
<p>Given an array of size n where all elements are in range from 0 to n-1, change contents of arr[] so that arr[i] = j is changed to arr[j] = i.<span id="more-134231"></span></p>
<p>Examples:</p>
<pre>

<strong>Example 1:</strong>

Input: arr[]  = {1, 3, 0, 2};

Output: arr[] = {2, 0, 3, 1};

Explanation for the above output.

Since arr[0] is 1, arr[1] is changed to 0

Since arr[1] is 3, arr[3] is changed to 1

Since arr[2] is 0, arr[0] is changed to 2

Since arr[3] is 2, arr[2] is changed to 3



<strong>Example 2:</strong>

Input: arr[]  = {2, 0, 1, 4, 5, 3};

Output: arr[] = {1, 2, 0, 5, 3, 4};



<strong>Example 3:</strong>

Input: arr[]  = {0, 1, 2, 3};

Output: arr[] = {0, 1, 2, 3};



<strong>Example 4:</strong>

Input: arr[]  = {3, 2, 1, 0};

Output: arr[] = {3, 2, 1, 0};

</pre>
<p>A <strong>Simple Solution </strong>is to create a temporary array and one by one copy ‘i’ to ‘temp[arr[i]]’ where i varies from 0 to n-1.  </p>
<p>Below is C implementation of the above idea.</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate" title="">

// A simple C program to rearrange contents of arr[] 

// such that arr[j] becomes j if arr[i] is j

#include&lt;stdio.h&gt;



// A simple method to rearrange 'arr[0..n-1]' so that 'arr[j]'

// becomes 'i' if 'arr[i]' is 'j'

void rearrangeNaive(int arr[], int n)

{

    // Create an auxiliary array of same size

    int temp[n], i;



    // Store result in temp[]

    for (i=0; i&lt;n; i++)

      temp[arr[i]] = i;



    // Copy temp back to arr[]

    for (i=0; i&lt;n; i++)

      arr[i] = temp[i];

}



// A utility function to print contents of arr[0..n-1]

void printArray(int arr[], int n)

{

    int i;

    for (i=0; i&lt;n; i++)

        printf("%d ", arr[i]);

    printf("\n");

}



// Drive program

int main()

{

    int arr[] = {1, 3, 0, 2};

    int n = sizeof(arr)/sizeof(arr[0]);



    printf("Given array is \n");

    printArray(arr, n);



    rearrangeNaive(arr,  n);



    printf("Modified array is \n");

    printArray(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>Given array is

1 3 0 2

Modified array is

2 0 3 1</pre>
<p>Time complexity of the above solution is O(n) and auxiliary space needed is O(n).</p>
<p><strong>Can we solve this in O(n) time and O(1) auxiliary space?</strong><br/>
The idea is based on the fact that the modified array is basically a permutation of input array.  We can find the target permutation by storing the next item before updating it.  </p>
<p>Let us consider array ‘{1, 3, 0, 2}’ for example.  We start with i = 0, arr[i] is 1. So we go to arr[1] and change it to 0 (because i is 0). Before we make the change, we store old value of arr[1] as the old value is going to be our new index i.  In next iteration, we have i = 3, arr[3] is 2, so we change arr[2] to 3.  Before making the change we store next i as old value of arr[2].  </p>
<p>The below code gives idea about this approach.</p>
<pre>

// This function works only when output is a permutation

// with one cycle.

void rearrangeUtil(int arr[], int n)

{

    // 'val' is the value to be stored at 'arr[i]'

    int val = 0;   // The next value is determined

                  // using current index

    int i = arr[0];  // The next index is determined

                     // using current value



    // While all elements in cycle are not processed

    while (i != 0)

    {

        // Store value at index as it is going to be

        // used as next index

        int new_i = arr[i];



        // Update arr[]

        arr[i] = val;



        // Update value and index for next iteration

        val = i;

        i = new_i;

    }



    arr[0] = val;  // Update the value at arr[0]

}

</pre>
<p><strong>The above function doesn’t work for inputs like  {2, 0, 1, 4, 5, 3}</strong>; as there are two cycles.  One cycle is (2, 0, 1) and other cycle is (4, 5, 3).<br/>
How to handle multiple cycles with the O(1) space constraint?<br/>
The idea is to process all cycles one by one.  To check whether an element is processed or not, we change the value of processed items arr[i] as -arr[i].  Since 0 can not be made negative, we first change all arr[i] to arr[i] + 1.   In the end, we make all values positive and subtract 1 to get old values back.</p>
<pre class="brush: cpp; highlight: [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]; title: ; notranslate" title="">

// A space efficient C program to rearrange contents of

//  arr[] such that arr[j] becomes j if arr[i] is j

#include&lt;stdio.h&gt;



// A utility function to rearrange elements in the cycle

// starting at arr[i]. This function assumes values in

// arr[] be from 1 to n.  It changes arr[j-1] to i+1

// if arr[i-1] is j+1

void rearrangeUtil(int arr[], int n, int i)

{

    // 'val' is the value to be stored at 'arr[i]'

    int val = -(i+1);  // The next value is determined

                       // using current index

    i = arr[i] - 1;  // The next index is determined

                     // using current value



    // While all elements in cycle are not processed

    while (arr[i] &gt; 0)

    {

        // Store value at index as it is going to be

        // used as next index

        int new_i = arr[i] - 1;



        // Update arr[]

        arr[i] = val;



        // Update value and index for next iteration

        val = -(i + 1);

        i = new_i;

    }

}



// A space efficient method to rearrange 'arr[0..n-1]'

// so that 'arr[j]' becomes 'i' if 'arr[i]' is 'j'

void rearrange(int arr[], int n)

{

    // Increment all values by 1, so that all elements

    // can be made negative to mark them as visited

    int i;

    for (i=0; i&lt;n; i++)

        arr[i]++;



    // Process all cycles

    for (i=0; i&lt;n; i++)

    {

       // Process cycle starting at arr[i] if this cycle is

       // not already processed

       if (arr[i] &gt; 0)

          rearrangeUtil(arr, n, i);

    }



    // Change sign and values of arr[] to get the original

    //  values back, i.e., values in range from 0 to n-1

    for (i=0; i&lt;n; i++)

          arr[i] = (-arr[i]) - 1;

}



// A utility function to print contents of arr[0..n-1]

void printArray(int arr[], int n)

{

    int i;

    for (i=0; i&lt;n; i++)

        printf("%d ", arr[i]);

    printf("\n");

}



// Drive program

int main()

{

    int arr[] =  {2, 0, 1, 4, 5, 3};

    int n = sizeof(arr)/sizeof(arr[0]);



    printf("Given array is \n");

    printArray(arr, n);



    rearrange(arr,  n);



    printf("Modified array is \n");

    printArray(arr, n);

    return 0;

}

</pre>
<p>Output:
<pre>Given array is

2 0 1 4 5 3

Modified array is

1 2 0 5 3 4 </pre>
<p>The time complexity of this method seems to be more than O(n) at first look.  If we take a closer look, we can notice that no element is processed more than constant number of times.</p>
<p>This article is contributed by <strong>Arun Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post80"> <span class="glyphicon glyphicon-collapse-down"></span>

Print all subarrays with 0 sum

</button> <div id="post80" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Print all subarrays with 0 sum</h1>
</header>
<div class="entry-content">
<p>Given an array, print all subarrays in the array which has sum 0.</p>
<p>Examples:</p>
<pre>

<strong>Input: </strong> arr = [6, 3, -1, -3, 4, -2, 2,

             4, 6, -12, -7]

<strong>Output: </strong> 

Subarray found from Index 2 to 4

Subarray found from Index 2 to 6          

Subarray found from Index 5 to 6

Subarray found from Index 6 to 9

Subarray found from Index 0 to 10

</pre>
<p>Related posts: <a href="http://www.geeksforgeeks.org/find-subarray-with-given-sum/">Find if there is a subarray with 0 sum </a></p>
<p><!-- To show strongly recommend and practice link    --></p>
<div id="practice"></div>
<p>A simple solution is to consider all subarrays one by one and check if sum of every subarray is equal to 0 or not. The complexity of this solution would be O(n^2).</p>
<p>A better approach is to use Hashing.</p>
<p>Do following for each element in the array</p>
<ol>
<li> Maintain sum of elements encountered so far in a variable (say sum).</li>
<li> If current sum is 0, we found a subarray starting from index 0 and ending at index current index</li>
<li> Check if current sum exists in the hash table or not.</li>
<li> If current sum exists in the hash table, that means we have subarray(s) present with 0 sum that ends at current index.</li>
<li> Insert current sum into the hash table </li>
</ol>
<p>Below is C++ implementation of above idea –</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]; title: ; notranslate" title="">

// C++ program to print all subarrays

// in the array which has sum 0

#include &lt;iostream&gt;

#include &lt;unordered_map&gt;

#include &lt;vector&gt;

using namespace std;

 

// Function to print all subarrays in the array which

// has sum 0

vector&lt; pair&lt;int, int&gt; &gt; findSubArrays(int arr[], int n)

{

    // create an empty map

    unordered_map&lt;int, vector&lt;int&gt; &gt; map;

 

    // create an empty vector of pairs to store

    // subarray starting and ending index

    vector &lt;pair&lt;int, int&gt;&gt; out;

 

    // Maintains sum of elements so far

    int sum = 0;

 

    for (int i = 0; i &lt; n; i++)

    {

        // add current element to sum

        sum += arr[i];

 

        // if sum is 0, we found a subarray starting

        // from index 0 and ending at index i

        if (sum == 0)

            out.push_back(make_pair(0, i));

 

        // If sum already exists in the map there exists

        // at-least one subarray ending at index i with

        // 0 sum

        if (map.find(sum) != map.end())

        {

            // map[sum] stores starting index of all subarrays

            vector&lt;int&gt; vc = map[sum];

            for (auto it = vc.begin(); it != vc.end(); it++)

                out.push_back(make_pair(*it + 1, i));

        }

 

        // Important - no else

        map[sum].push_back(i);

    }

 

    // return output vector

    return out;

}

 

// Utility function to print all subarrays with sum 0

void print(vector&lt;pair&lt;int, int&gt;&gt; out)

{

    for (auto it = out.begin(); it != out.end(); it++)

        cout &lt;&lt; "Subarray found from Index " &lt;&lt;

            it-&gt;first &lt;&lt; " to " &lt;&lt; it-&gt;second &lt;&lt; endl;

}

 

// Driver code

int main()

{

    int arr[] = {6, 3, -1, -3, 4, -2, 2, 4, 6, -12, -7};

    int n = sizeof(arr)/sizeof(arr[0]);

 

    vector&lt;pair&lt;int, int&gt; &gt; out = findSubArrays(arr, n);

 

    // if we didn’t find any subarray with 0 sum,

    // then subarray doesn’t exists

    if (out.size() == 0)

        cout &lt;&lt; "No subarray exists";

    else

        print(out);

 

    return 0;

}

</pre>
<p>Output:</p>
<pre>

Subarray found from Index 2 to 4

Subarray found from Index 2 to 6

Subarray found from Index 5 to 6

Subarray found from Index 6 to 9

Subarray found from Index 0 to 10

</pre>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post81"> <span class="glyphicon glyphicon-collapse-down"></span>

Find frequency of each element in a limited range array in less than O(n) time

</button> <div id="post81" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find frequency of each element in a limited range array in less than O(n) time</h1>
</header>
<div class="entry-content">
<p>Given an sorted array of positive integers, count number of occurrences for each element in the array. Assume all elements in the array are less than some constant M.</p>
<p>Do this without traversing the complete array. i.e. expected time complexity is less than O(n).</p>
<p>Examples:</p>
<pre>

<strong>Input:</strong> arr[] = [1, 1, 1, 2, 3, 3, 5,

               5, 8, 8, 8, 9, 9, 10] 

<strong>Output:</strong>

Element 1 occurs 3 times

Element 2 occurs 1 times

Element 3 occurs 2 times

Element 5 occurs 2 times

Element 8 occurs 3 times

Element 9 occurs 2 times

Element 10 occurs 1 times

</pre>
<p><!-- To show strongly recommend and practice link    --></p>
<div id="practice"></div>
<p><strong>Method 1 (Linear Search)</strong><br/>
The idea is traverse the input array and for each distinct element of array, store its frequency in a map and finally print the map. This approach takes O(n) time.</p>
<p><strong>Method 2 (Use Binary Search)</strong><br/>
This problem can be solved in less than O(n) using a modified binary search. The idea is to recursively divide the array into two equal subarrays if its end elements are different. If both its end elements are same, that means that all elements in the subarray is also same as the array is already sorted. We then simply increment the count of the element by size of the subarray.</p>
<p>The time complexity of above approach is O(m log n), where m is number of distinct elements in the array of size n. Since m &lt;= M (a constant), the time complexity of this solution is O(log n).</p>
<p>Below is C++ implementation of above idea –</p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]; title: ; notranslate" title="">

// C++ program to count number of occurrences of

// each element in the array in less than O(n) time

#include &lt;iostream&gt;

#include &lt;vector&gt;

using namespace std;

 

// A recursive function to count number of occurrences 

// for each element in the array without traversing 

// the whole array

void findFrequencyUtil(int arr[], int low, int high, 

                        vector&lt;int&gt;&amp; freq)

{

    // If element at index low is equal to element 

    // at index high in the array

    if (arr[low] == arr[high]) 

    {

        // increment the frequency of the element

        // by count of elements between high and low

        freq[arr[low]] += high - low + 1;

    } 

    else

    {

        // Find mid and recurse for left and right 

        // subarray

        int mid = (low + high) / 2;

        findFrequencyUtil(arr, low, mid, freq);

        findFrequencyUtil(arr, mid + 1, high, freq);

    }

}

 

// A wrapper over recursive function 

// findFrequencyUtil(). It print number of 

// occurrences of each element in the array.

void findFrequency(int arr[], int n)

{

    // create a empty vector to store frequencies

    // and initialize it by 0. Size of vector is 

    // maximum value (which is last value in sorted

    // array) plus 1.

    vector&lt;int&gt; freq(arr[n - 1] + 1, 0);

     

    // Fill the vector with frequency

    findFrequencyUtil(arr, 0, n - 1, freq);

 

    // Print the frequencies

    for (int i = 0; i &lt;= arr[n - 1]; i++)

        if (freq[i] != 0)

            cout &lt;&lt; "Element " &lt;&lt; i &lt;&lt; " occurs "

                 &lt;&lt; freq[i] &lt;&lt; " times" &lt;&lt; endl;

}

 

// Driver function

int main()

{

    int arr[] = { 1, 1, 1, 2, 3, 3, 5, 5,

                  8, 8, 8, 9, 9, 10 };

    int n = sizeof(arr) / sizeof(arr[0]);

 

    findFrequency(arr, n);

 

    return 0;

}

</pre>
<p>Output:</p>
<pre>

Element 1 occurs 3 times

Element 2 occurs 1 times

Element 3 occurs 2 times

Element 5 occurs 2 times

Element 8 occurs 3 times

Element 9 occurs 2 times

Element 10 occurs 1 times

</pre>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post82"> <span class="glyphicon glyphicon-collapse-down"></span>

Minimum sum of two numbers formed from digits of an array

</button> <div id="post82" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Minimum sum of two numbers formed from digits of an array</h1>
</header>
<div class="entry-content">
<p>Given an array of digits (values are from 0 to 9), find the minimum possible sum of two numbers formed from digits of the array.  All digits of given array must be used to form the two numbers.</p>
<pre>

Input: [6, 8, 4, 5, 2, 3]

Output: 604

The minimum sum is formed by numbers 

358 and 246



Input: [5, 3, 0, 7, 4]

Output: 82

The minimum sum is formed by numbers 

35 and 047 </pre>
<div id="practice"></div>
<p>A minimum number will be formed from set of digits when smallest digit appears at most significant position and next smallest digit appears at next most significant position ans so on..</p>
<p>The idea is to sort the array in increasing order and build two numbers by alternating picking digits from the array. So first number is formed by digits present in odd positions in the array and second number is formed by digits from even positions in the array. Finally, we return the sum of first and second number.</p>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; title: ; notranslate" title="">

// C++ program to find minimum sum of two numbers

// formed from digits of the array.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Function to find and return minimum sum of

// two numbers formed from digits of the array.

int solve(int arr[], int n)

{

    // sort the array

    sort(arr, arr + n);



    // let two numbers be a and b

    int a = 0, b = 0;

    for (int i = 0; i &lt; n; i++)

    {

        // fill a and b with every alternate digit

        // of input array

        if (i &amp; 1)

            a = a*10 + arr[i];

        else

            b = b*10 + arr[i];

    }



    // return the sum

    return a + b;

}



// Driver code

int main()

{

    int arr[] = {6, 8, 4, 5, 2, 3};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Sum is " &lt;&lt; solve(arr, n);

    return 0;

}

</pre>
<p>Output :
<pre>Sum is 604</pre>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post83"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum value K such that array has at-least K elements that are >= K

</button> <div id="post83" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum value K such that array has at-least K elements that are &gt;= K</h1>
</header>
<div class="entry-content">
<p>Given an array of <strong>positive</strong> integers, find maximum possible value K such that the array has at-least K elements that are greater than or equal to K. The array is unsorted and may contain duplicate values.</p>
<p>Examples :
<pre>

Input: [2, 3, 4, 5, 6, 7]

Output: 4

Explanation : 4 elements [4, 5, 6, 7] 

            are greater than equal to 4



Input: [1, 2, 3, 4]

Output: 2

Explanation : 3 elements [2, 3, 4] are 

               greater than equal to 2



Input: [4, 7, 2, 3, 8]

Output: 3 

Explanation : 4 elements [4, 7, 3, 8] 

          are greater than equal to 3

 



Input: [6, 7, 9, 8, 10]

Output: 5

Explanation : All 5 elements are greater

              than equal to 5 </pre>
<p>Expected time complexity : O(n)</p>
<div id="practice"></div>
<p> </p>
<p><center><strong>Method 1 [Simple : O(n<sup>2</sup>) time]</strong></center><br/>
Let size of input array be n.  Let us consider following important observations.</p>
<ol>
<li> The maximum possible value of result can be n.  We get the maximum possible value when all elements are greater than or equal to n.  For example, if input array is {10, 20, 30}, n is 3.  The value of result can’t be greater than 3. </li>
<li> The minimum possible value would be 1.  An example case when get this output is, when all elements are 1. </li>
</ol>
<p>So we can run a loop from n to 1 and count greater elements for every value.  </p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate" title="">

// C++ program to find maximum possible value K

// such that array has at-least K elements that

// are greater than or equals to K.

#include &lt;iostream&gt;

using namespace std;



// Function to return maximum possible value K

// such that array has atleast K elements that

// are greater than or equals to K

int findMaximumNum(unsigned int arr[], int n)

{

    // output can contain any number from n to 0

    // where n is length of the array



    // We start a loop from n as we need to find

    // maximum possible value

    for (int i = n; i &gt;= 1; i--)

    {

        // count contains total number of elements

        // in input array that are more than equal to i

        int count = 0;



        // traverse the input array and find count

        for (int j=0; j&lt;n; j++)

            if (i &lt;= arr[j])

                count++;



        if (count &gt;= i)

          return i;

    }    

    return 1;

}



// Driver code

int main()

{

    unsigned int arr[] = {1, 2, 3, 8, 10 };

    int n = sizeof(arr) / sizeof(arr[0]);

    cout &lt;&lt; findMaximumNum(arr, n);

    return 0;

}

</pre>
<p>Output :
<pre>3</pre>
<p><center><strong>Method 2 [Efficient : O(n) time and O(n) extra space]</strong></center><br/>
1) The idea is to construct axillary array of size n + 1, and use that array to find count of greater elements in input array.  Let the auxiliary array be freq[].  We initialize all elements of this array as 0.</p>
<p>2) We process all input elements.<br/>
        a) If an element arr[i] is less than n, then we increment its frequency, i.e., we do freq[arr[i]]++.<br/>
        b) Else we increment freq[n].</p>
<p>3) After step 2 we have two things.<br/>
        a) Frequencies of elements for elements smaller than n stored in freq[0..n-1].<br/>
        b) Count of elements greater than n stored in freq[n].</p>
<p>Finally, we process the freq[] array backwards to find the output by keeping sum of the values processed so far.</p>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]; title: ; notranslate" title="">

// C++ program to find maximum possible value K such

// that array has atleast K elements that are greater

// than or equals to K.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Function to return maximum possible value K such

// that array has at-least K elements that are greater

// than or equals to K.

int findMaximumNum(unsigned int arr[], int n)

{

    // construct axillary array of size n + 1 and

    // initialize the array with 0

    vector&lt;int&gt; freq(n+1, 0);



    // store the frequency of elements of

    // input array in the axillary array

    for (int i = 0; i &lt; n; i++)

    {

        // If element is smaller than n, update its

        // frequency

        if (arr[i] &lt; n)

            freq[arr[i]]++;



        // Else increment count of elements greater

        // than n.

        else

            freq[n]++;

    }



    // sum stores number of elements in input array

    // that are greater than or equal to current

    // index

    int sum = 0;



    // scan auxillary array backwards

    for (int i = n; i &gt; 0; i--)

    {

        sum += freq[i];



        // if sum is greater than current index,

        // current index is the answer

        if (sum &gt;= i)

            return i;

    }

}



// Driver code

int main()

{

    unsigned int arr[] = {1, 2, 3, 8, 10 };

    int n = sizeof(arr) / sizeof(arr[0]);



    cout &lt;&lt; findMaximumNum(arr, n);



    return 0;

}

</pre>
<p>Output :
<pre>3</pre>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post84"> <span class="glyphicon glyphicon-collapse-down"></span>

Find number of subarrays with even sum

</button> <div id="post84" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find number of subarrays with even sum</h1>
</header>
<div class="entry-content">
<p>Given an array, find the number of subarrays whose sum is even.</p>
<p>Example :
<pre>

Input : arr[] = {1, 2, 2, 3, 4, 1} 

Output : 9



There are possible subarrays with even

sum. The subarrays are 

1) {1, 2, 2, 3}  Sum = 8

2) {1, 2, 2, 3, 4}  Sum = 12

3) {2}  Sum = 2 (At index 1)

4) {2, 2}  Sum = 4

5) {2, 2, 3, 4, 1}  Sum = 12

6) {2}  Sum = 2 (At index 2)

7) {2, 3, 4, 1} Sum = 10

8) {3, 4, 1}  Sum = 8

9) {4}  Sum = 4 </pre>
<div id="practice"></div>
<p><strong>O(n<sup>2</sup>) time and O(1) space method [Brute Force]</strong><br/>
We can simply generate all the possible sub-arrays and find whether the sum of all  the elements in them is an even or not. If it is even then we will count that sub-array otherwise neglect it.</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate" title="">

/* C++ program to count number of sub-arrays

  whose sum is even using brute force

 Time Complexity - O(N^2)

 Space Complexity - O(1) */

#include&lt;iostream&gt;

using namespace std;



int countEvenSum(int arr[], int n)

{

    int result = 0;



    // Find sum of all subarrays and increment

    // result if sum is even

    for (int i=0; i&lt;=n-1; i++)

    {

        int sum = 0;

        for (int j=i; j&lt;=n-1; j++)

        {

            sum = sum + arr[j];

            if (sum % 2 == 0)

                    result++;

        }

    }



    return (result);

}



// Driver code

int main()

{

    int arr[] = {1, 2, 2, 3, 4, 1};

    int n = sizeof (arr) / sizeof (arr[0]);



    cout &lt;&lt; "The Number of Subarrays with even"

            " sum is " &lt;&lt; countEvenSum (arr, n);



    return (0);

}

</pre>
<p>Output :
<pre>

The Number of Subarrays with even sum is 9</pre>
<p> <br/>
<strong>O(n) Time and O(1) Space Method [Efficient]</strong><br/>
If we do compute the cumulative sum array in temp[] of our input array, then we can see that the sub-array starting from i and ending at j, has an even sum if temp[] if (temp[j] – temp[i]) % 2 = 0. So, instead of building a cumulative sum array we build a cumulative sum modulo 2 array, and find how many times 0 and 1 appears in temp[] array using handshake formula. [n * (n-1) /2]</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate" title="">

/* C++ program to count number of sub-arrays

with even sum using an efficient algorithm

Time Complexity - O(N)

Space Complexity - O(1)*/

#include&lt;iostream&gt;

using namespace std;



int countEvenSum(int arr[], int n)

{

    // A temporary array of size 2. temp[0] is

    // going to store count of even subarrays

    // and temp[1] count of odd.

    // temp[0] is initialized as 1 because there

    // a single even element is also counted as

    // a subarray

    int temp[2] = {1, 0};



    // Initialize count.  sum is sum of elements

    // under modulo 2 and ending with arr[i].

    int result = 0, sum = 0;



    // i'th iteration computes sum of arr[0..i]

    // under modulo 2 and increments even/odd count

    // according to sum's value

    for (int i=0; i&lt;=n-1; i++)

    {

        // 2 is added to handle negative numbers

        sum = ( (sum + arr[i]) % 2 + 2) % 2;



        // Increment even/odd count

        temp[sum]++;

    }



    // Use handshake lemma to count even subarrays

    // (Note that an even cam be formed by two even

    // or two odd)

    result = result + (temp[0]*(temp[0]-1)/2);

    result = result + (temp[1]*(temp[1]-1)/2);



    return (result);

}



// Driver code

int main()

{

    int arr[] = {1, 2, 2, 3, 4, 1};

    int n = sizeof (arr) / sizeof (arr[0]);



    cout &lt;&lt; "The Number of Subarrays with even"

            " sum is " &lt;&lt; countEvenSum (arr, n);



    return (0);

}

</pre>
<p>Output :
<pre>

The Number of Subarrays with even sum is 9</pre>
<p>This article is contributed by <strong>Rachit Belwariar</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post85"> <span class="glyphicon glyphicon-collapse-down"></span>

Maximum absolute difference between sum of two contiguous sub-arrays

</button> <div id="post85" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Maximum absolute difference between sum of two contiguous sub-arrays</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, find two non-overlapping contiguous sub-arrays such that the absolute difference between the sum of two sub-arrays is maximum.</p>
<p>For example,
<pre>

Input: [-2, -3, 4, -1, -2, 1, 5, -3]

Output: 12

Two subarrays are [-2, -3] and [4, -1, -2, 1, 5]



Input: [2, -1, -2, 1, -4, 2, 8]

Output: 16

Two subarrays are [-1, -2, 1, -4] and [2, 8] </pre>
<p>Expected time complexity is O(n).</p>
<p>The idea is for each index i in given array arr[0…n-1], compute maximum and minimum sum subarrays that lie in subarrays arr[0…i] and arr[i+1 …n-1]. We maintain four arrays that store the maximum and minimum sums in the subarrays arr[0…i] and arr[i+1 … n-1] for every index i in the array.</p>
<pre>

leftMax[] : An element leftMax[i] of this 

            array stores the maximum value 

            in subarray arr[0..i]



leftMin[] : An element leftMin[i] of this 

            array stores the minimum value

            in subarray arr[0..i]



rightMax[] : An element rightMax[i] of this 

             array stores the maximum value 

             in subarray arr[i+1..n-1]



rightMin[] : An element rightMin[i] of this

             array stores the minimum value

             in subarray arr[i+1..n-1] </pre>
<p>We can build above four arrays in O(n) time by using <a href="http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/">Kadane Algorithm</a>.</p>
<ol></ol></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post86"> <span class="glyphicon glyphicon-collapse-down"></span>

Find smallest range containing elements from k lists

</button> <div id="post86" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find smallest range containing elements from k lists</h1>
</header>
<div class="entry-content">
<p>Given k sorted lists of integers of size n each, find the smallest range that includes at least element from each of the k lists. If more than one smallest ranges are found, print any one of them.</p>
<p>Example :
<pre>

Input:

K = 3

arr1[] : [4, 7, 9, 12, 15]

arr2[] : [0, 8, 10, 14, 20]

arr3[] : [6, 12, 16, 30, 50]

Output:

The smallest range is [6 8] 

Explanation: Smallest range is formed by 

number 7 from first list, 8 from second

list and 6 from third list.





Input: 

k = 3

arr1[] : [4, 7, 30]

arr2[] : [1, 2]

arr3[] : [20, 40]

The smallest range is [2 20]  </pre>
<div id="practice"></div>
<p>The idea is to use min heap. Below are the steps –</p>
<ol>
<li>Create a min heap of size k and insert first elements of all k lists into the heap. </li>
<li> Maintain two variables min and max to store minimum and maximum values present in the heap at any point. Note min will always contain value of the root of the heap. </li>
<li>Repeat following steps
<ul>
<li> Get minimum element from heap (minimum is always at root) and compute the range.</li>
<li> Replace heap root with next element of the list from which the min element is extracted. After replacing the root, heapify the tree. Update max if next element is greater. If the list doesn’t have any more elements, break the loop.</li>
</ul>
</li>
</ol>
<p>Below is C++ implementation of above approach – </p>
<pre class="brush: cpp; highlight: [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145]; title: ; notranslate" title="">

// C++ program to finds out smallest range that includes

// elements from each of the given sorted lists.

#include&lt;iostream&gt;

#include&lt;limits.h&gt;

using namespace std;



#define N 5



// A min heap node

struct MinHeapNode

{

    int element; // The element to be stored

    int i; // index of the list from which the element is taken

    int j; // index of the next element to be picked from list

};



// Prototype of a utility function to swap two min heap nodes

void swap(MinHeapNode *x, MinHeapNode *y);



// A class for Min Heap

class MinHeap

{

    MinHeapNode *harr; // pointer to array of elements in heap

    int heap_size; // size of min heap

public:

    // Constructor: creates a min heap of given size

    MinHeap(MinHeapNode a[], int size);



    // to heapify a subtree with root at given index

    void MinHeapify(int );



    // to get index of left child of node at index i

    int left(int i) { return (2*i + 1); }



    // to get index of right child of node at index i

    int right(int i) { return (2*i + 2); }



    // to get the root

    MinHeapNode getMin() { return harr[0]; }



    // to replace root with new node x and heapify() new root

    void replaceMin(MinHeapNode x) { harr[0] = x; MinHeapify(0); }

};



// Constructor: Builds a heap from a given array a[] of given size

MinHeap::MinHeap(MinHeapNode a[], int size)

{

    heap_size = size;

    harr = a; // store address of array

    int i = (heap_size - 1)/2;

    while (i &gt;= 0)

    {

        MinHeapify(i);

        i--;

    }

}



// A recursive method to heapify a subtree with root at

// given index. This method assumes that the subtrees

// are already heapified

void MinHeap::MinHeapify(int i)

{

    int l = left(i);

    int r = right(i);

    int smallest = i;

    if (l &lt; heap_size &amp;&amp;

        harr[l].element &lt; harr[i].element)

        smallest = l;

    if (r &lt; heap_size &amp;&amp;

        harr[r].element &lt; harr[smallest].element)

        smallest = r;

    if (smallest != i)

    {

        swap(harr[i], harr[smallest]);

        MinHeapify(smallest);

    }

}



// This function takes an k sorted lists in the form of

// 2D array as an argument. It finds out smallest range

// that includes elements from each of the k lists.

void findSmallestRange(int arr[][N], int k)

{

    // Create a min heap with k heap nodes. Every heap node

    // has first element of an list

    int range = INT_MAX;

    int min = INT_MAX, max = INT_MIN;

    int start, end;



    MinHeapNode *harr = new MinHeapNode[k];

    for (int i = 0; i &lt; k; i++)

    {

        harr[i].element = arr[i][0]; // Store the first element

        harr[i].i = i; // index of list

        harr[i].j = 1; // Index of next element to be stored

                       // from list



        // store max element

        if (harr[i].element &gt; max)

            max = harr[i].element;

    }



    MinHeap hp(harr, k); // Create the heap



    // Now one by one get the minimum element from min

    // heap and replace it with next element of its list

    while (1)

    {

        // Get the minimum element and store it in output

        MinHeapNode root = hp.getMin();



        // update min

        min = hp.getMin().element;



        // update range

        if (range &gt; max - min + 1)

        {

            range = max - min + 1;

            start = min;

            end = max;

        }



        // Find the next element that will replace current

        // root of heap. The next element belongs to same

        // list as the current root.

        if (root.j &lt; N)

        {

            root.element = arr[root.i][root.j];

            root.j += 1;



            // update max element

            if (root.element &gt; max)

                max = root.element;

        }



        // break if we have reached end of any list

        else break;



        // Replace root with next element of list

        hp.replaceMin(root);

    }



    cout &lt;&lt; "The smallest range is " &lt;&lt; "["

         &lt;&lt; start &lt;&lt; " " &lt;&lt; end &lt;&lt; "]" &lt;&lt; endl;;

}



// Driver program to test above functions

int main()

{

    int arr[][N] = {

                    {4, 7, 9, 12, 15},

                    {0, 8, 10, 14, 20},

                    {6, 12, 16, 30, 50}

                    };

    int k = sizeof(arr)/sizeof(arr[0]);



    findSmallestRange(arr, k);



    return 0;

}

</pre>
<p>Output  :
<pre>The smallest range is [6 8]</pre>
<p><strong><br/>
Time Complexity:</strong> The while loop inside findSmallestRange() function can run maximum n*k times. In every iteration of loop, we call heapify which takes O(Logk) time. Therefore, the time complexity is O(nk Logk).</p>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post87"> <span class="glyphicon glyphicon-collapse-down"></span>

Pair with given product | Set 1 (Find if any pair exists)

</button> <div id="post87" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Pair with given product | Set 1 (Find if any pair exists)</h1>
</header>
<div class="entry-content">
<p>Given an array and a number x, find if there is a pair with product equal to x. </p>
<p>Examples :
<pre>

Input : arr[] = {10, 20, 9, 40};

        int x = 400;

Output : Yes



Input : arr[] = {10, 20, 9, 40};

        int x = 190;

Output : No



Input : arr[] = {-10, 20, 9, -40};

        int x = 400;

Output : Yes



Input : arr[] = {-10, 20, 9, 40};

        int x = -400;

Output : Yes



Input : arr[] = {0, 20, 9, 40};

        int x = 0;

Output : Yes

</pre>
<div id="practice"></div>
<p><strong>Naive approach ( O(n<sup>2</sup>) )</strong> is to run two loops to consider all possible pairs.  For every pair, check if product is equal to  x or not.  </p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate" title="">

// A simple C++ program to find if there is a pair

// with given product.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns true if there is a pair in arr[0..n-1]

// with product equal to x.

bool isProduct(int arr[], int n, int x)

{

    // Consider all possible pairs and check for

    // every pair.

    for (int i=0; i&lt;n-1; i++)

       for (int j=i+1; i&lt;n; i++)

          if (arr[i] * arr[j] == x)

              return true;



    return false;

}



// Driver code

int main()

{

    int arr[] = {10, 20, 9, 40};

    int x = 400;

    int n = sizeof(arr)/sizeof(arr[0]);

    isProduct(arr, n, x)? cout &lt;&lt; "Yes\n"

                        : cout &lt;&lt; "No\n";

    x = 190;

    isProduct(arr, n, x)? cout &lt;&lt; "Yes\n"

                        : cout &lt;&lt; "No\n";

    return 0;

}

</pre>
<p>Output :
<pre>Yes

No</pre>
<p> </p>
<p><strong>Efficient Solution ( O(n) ):</strong>  We can improve time complexity to O(n) using <a href="http://geeksquiz.com/hashing-set-1-introduction/">hashing</a>.  Below are steps.</p>
<ol>
<li> Create an empty hash table </li>
<li> Traverse array elments and do following for every element arr[i].
<ul>
<li>If arr[i] is 0 and x is also 0, return true, else ignore arr[i].</li>
<li>If x % arr[i] is 0 and x/arr[i] exists in table, return true.</li>
<li>Insert arr[i] into the hash table.</li>
</ul>
</li>
<li> Return false </li>
</ol>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]; title: ; notranslate" title="">

// C++ program to find if there is a pair

// with given product.

#include&lt;bits/stdc++.h&gt;

using namespace std;



// Returns true if there is a pair in arr[0..n-1]

// with product equal to x.

bool isProduct(int arr[], int n, int x)

{

    if (n &lt; 2)

        return false;



    // Create an empty set and insert first

    // element into it

    unordered_set&lt;int&gt; s;



    // Traverse remaining elements

    for (int i=0; i&lt;n; i++)

    {

        // 0 case must be handles explicitly as

        // x % 0 is undefined behaviour in C++

        if (arr[i] == 0)

        {

           if (x == 0)

               return true;

           else

               continue;

        }



        // x/arr[i] exists in hash, then we

        // found a pair

        if (x%arr[i] == 0)

        {

            if (s.find(x/arr[i]) != s.end())

               return true;



            // Insert arr[i]

            s.insert(arr[i]);

        }

    }

    return false;

}



// Driver code

int main()

{

    int arr[] = {10, 20, 9, 40};

    int x = 400;



    int n = sizeof(arr)/sizeof(arr[0]);

    isProduct(arr, n, x)? cout &lt;&lt; "Yes\n"

                       : cout &lt;&lt; "No\n";



    x = 190;

    isProduct(arr, n, x)? cout &lt;&lt; "Yes\n"

                        : cout &lt;&lt; "No\n";



    return 0;

}

</pre>
<p>Output :
<pre>Yes

No</pre>
<div id="company_tags"></div>
<p>In the next set, we will be discussing approach to print all pairs with product equal to 0.</p>
<p>This article is contributed by <strong>Shubham Goyal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post88"> <span class="glyphicon glyphicon-collapse-down"></span>

Find maximum product of a triplet in array

</button> <div id="post88" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find maximum product of a triplet in array</h1>
</header>
<div class="entry-content">
<p>Given an integer array, find a maximum product of a triplet in array.</p>
<p>Examples:
<pre>

Input:  [10, 3, 5, 6, 20]

Output: 1200

Multiplication of 10, 6 and 20

 

Input:  [-10, -3, -5, -6, -20]

Output: -90



Input:  [1, -4, 3, -6, 7, 0]

Output: 168</pre>
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=765">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<p> </p>
<p><strong>Approach 1 (Naive, O(n<sup>3</sup>) time, O(1) Space)</strong><br/>
A simple solution is to check for every triplet using three nested loops. Below is its C++ implementation –</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate" title="">

// A C++ program to find a maximum product of a

// triplet in array of integers

#include &lt;bits/stdc++.h&gt;

using namespace std;



/* Function to find a maximum product of a triplet

   in array of integers of size n */

int maxProduct(int arr[], int n)

{

    // if size is less than 3, no triplet exists

    if (n &lt; 3)

        return -1;



    // will contain max product

    int max_product = INT_MIN;



    for (int i = 0; i &lt; n - 2; i++)

        for (int j = i + 1; j &lt; n - 1; j++)

            for (int k = j + 1; k &lt; n; k++)

                max_product = max(max_product,

                        arr[i] * arr[j] * arr[k]);



    return max_product;

}



// Driver program to test above functions

int main()

{

    int arr[] = { 10, 3, 5, 6, 20 };

    int n = sizeof(arr) / sizeof(arr[0]);



    int max = maxProduct(arr, n);



    if (max == -1)

        cout &lt;&lt; "No Triplet Exists";

    else

        cout &lt;&lt; "Maximum product is " &lt;&lt; max;



    return 0;

}

</pre>
<p>Output :
<pre>Maximum product is 1200</pre>
<p> <br/>
<strong>Approach 2: O(n) Time, O(n) Space</strong></p>
<ol>
<li>Construct four auxiliary arrays leftMax[], rightMax[], leftMin[] and rightMin[] of same size as input array.</li>
<li> Fill leftMax[], rightMax[], leftMin[] and rightMin[] in below manner.
<ul>
<li>leftMax[i] will contain maximum element on left of arr[i] excluding arr[i]. For index 0, left will contain -1.</li>
<li>leftMin[i] will contain minimum element on left of arr[i] excluding arr[i]. For index 0, left will contain -1.</li>
<li>rightMax[i] will contain maximum element on right of arr[i] excluding arr[i]. For index n-1, right will contain -1.</li>
<li>rightMin[i] will contain minimum element on right of arr[i] excluding arr[i]. For index n-1, right will contain -1.</li>
</ul>
</li>
<li>For all array indexes i except first and last index, compute maximum of arr[i]*x*y where x can be leftMax[i] or leftMin[i] and y can be rightMax[i] or rightMin[i].</li>
<li>Return the maximum from step 3.</li>
</ol>
<p>Below is its C++ implementation –</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84]; title: ; notranslate" title="">

// A C++ program to find a maximum product of a triplet

// in array of integers

#include &lt;bits/stdc++.h&gt;

using namespace std;



/* Function to find a maximum product of a triplet

in array of integers of size n */

int maxProduct(int arr[], int n)

{

    // if size is less than 3, no triplet exists

    if (n &lt; 3)

        return -1;



    // Construct four auxiliary vectors

    // of size n and initailize them by -1

    vector&lt;int&gt; leftMin(n, -1);

    vector&lt;int&gt; rightMin(n, -1);

    vector&lt;int&gt; leftMax(n, -1);

    vector&lt;int&gt; rightMax(n, -1);



    // will contain max product

    int max_product = INT_MIN;



    // to store maximum element on left of array

    int max_sum = arr[0];



    // to store minimum element on left of array

    int min_sum = arr[0];



    // leftMax[i] will contain max element

    // on left of arr[i] excluding arr[i].

    // leftMin[i] will contain min element

    // on left of arr[i] excluding arr[i].

    for (int i = 1; i &lt; n; i++)

    {

        leftMax[i] = max_sum;

        if (arr[i] &gt; max_sum)

            max_sum = arr[i];



        leftMin[i] = min_sum;

        if (arr[i] &lt; min_sum)

            min_sum = arr[i];

    }



    // reset max_sum to store maximum element on

    // right of array

    max_sum = arr[n - 1];



    // reset min_sum to store minimum element on

    // right of array

    min_sum = arr[n - 1];



    // rightMax[i] will contain max element

    // on right of arr[i] excluding arr[i].

    // rightMin[i] will contain min element

    // on right of arr[i] excluding arr[i].

    for (int j = n - 2; j &gt;= 0; j--)

    {

        rightMax[j] = max_sum;

        if (arr[j] &gt; max_sum)

            max_sum = arr[j];



        rightMin[j] = min_sum;

        if (arr[j] &lt; min_sum)

            min_sum = arr[j];

    }



    // For all array indexes i except first and

    // last, compute maximum of arr[i]*x*y where

    // x can be leftMax[i] or leftMin[i] and

    // y can be rightMax[i] or rightMin[i].

    for (int i = 1; i &lt; n - 1; i++)

    {

        int max1 = max(arr[i] * leftMax[i] * rightMax[i],

                    arr[i] * leftMin[i] * rightMin[i]);



        int max2 = max(arr[i] * leftMax[i] * rightMin[i],

                    arr[i] * leftMin[i] * rightMax[i]);



        max_product = max(max_product, max(max1, max2));

    }



    return max_product;

}



// Driver program to test above functions

int main()

{

    int arr[] = { 1, 4, 3, -6, -7, 0 };

    int n = sizeof(arr) / sizeof(arr[0]);



    int max = maxProduct(arr, n);



    if (max == -1)

        cout &lt;&lt; "No Triplet Exists";

    else

        cout &lt;&lt; "Maximum product is " &lt;&lt; max;



    return 0;

}

</pre>
<p>Output :
<pre>Maximum product is 168</pre>
<p> <br/>
<strong>Approach 3: O(nlogn) Time, O(1) Space</strong></p>
<ol>
<li>Sort the array using some efficient in-place sorting algorithm in ascending order.</li>
<li> Return the maximum of product of last three elements of the array and product of first two elements and last element.</li>
<ol>
Below is its C++ implementation –</ol></ol></p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22]; title: ; notranslate" title="">

// A C++ program to find a maximum product of a

// triplet in array of integers

#include &lt;bits/stdc++.h&gt;

using namespace std;



/* Function to find a maximum product of a triplet

   in array of integers of size n */

int maxProduct(int arr[], int n)

{

    // if size is less than 3, no triplet exists

    if (n &lt; 3)

        return -1;



    // Sort the array in ascending order

    sort(arr, arr + n);



    // Return the maximum of product of last three

    // elements and product of first two elements

    // and last element

    return max(arr[0] * arr[1] * arr[n - 1],

               arr[n - 1] * arr[n - 2] * arr[n - 3]);

}



// Driver program to test above functions

int main()

{

    int arr[] = { -10, -3, 5, 6, -20 };

    int n = sizeof(arr) / sizeof(arr[0]);



    int max = maxProduct(arr, n);



    if (max == -1)

        cout &lt;&lt; "No Triplet Exists";

    else

        cout &lt;&lt; "Maximum product is " &lt;&lt; max;



    return 0;

}



</pre>
<p>Output :
<pre>Maximum product is 1200</pre>
<p> </p>
<p><strong>Approach 4: O(n) Time, O(1) Space</strong></p>
<ol>
<li>Scan the array and compute Maximum, second maximum and third maximum element present in the array.</li>
<li> Scan the array and compute Minimum and second minimum element present in the array.</li>
<li>Return the maximum of product of Maximum, second maximum and third maximum and product of Minimum, second minimum and Maximum element.</li>
</ol>
<p>Note – Step 1 and Step 2 can be done in single traversal of the array.</p>
<p>Below is its C++ implementation –</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate" title="">

// A O(n) C++ program to find maximum product pair in

// an array.

#include &lt;bits/stdc++.h&gt;

using namespace std;



/* Function to find a maximum product of a triplet

   in array of integers of size n */

int maxProduct(int arr[], int n)

{

    // if size is less than 3, no triplet exists

    if (n &lt; 3)

        return -1;



    // Initialize Maximum, second maximum and third

    // maximum element

    int maxA = INT_MIN, maxB = INT_MIN, maxC = INT_MIN;



    // Initialize Minimum and second mimimum element

    int minA = INT_MAX, minB = INT_MAX;



    for (int i = 0; i &lt; n; i++)

    {

        // Update Maximum, second maximum and third

        // maximum element

        if (arr[i] &gt; maxA)

        {

            maxC = maxB;

            maxB = maxA;

            maxA = arr[i];

        }



        // Update second maximum and third maximum element

        else if (arr[i] &gt; maxB)

        {

            maxC = maxB;

            maxB = arr[i];

        }



        // Update third maximum element

        else if (arr[i] &gt; maxC)

            maxC = arr[i];



        // Update Minimum and second mimimum element

        if (arr[i] &lt; minA)

        {

            minB = minA;

            minA = arr[i];

        }



        // Update second mimimum element

        else if(arr[i] &lt; minB)

            minB = arr[i];

    }



    return max(minA * minB * maxA,

               maxA * maxB * maxC);

}



// Driver program to test above function

int main()

{

    int arr[] = { 1, -4, 3, -6, 7, 0 };

    int n = sizeof(arr) / sizeof(arr[0]);



    int max = maxProduct(arr, n);



    if (max == -1)

        cout &lt;&lt; "No Triplet Exists";

    else

        cout &lt;&lt; "Maximum product is " &lt;&lt; max;



    return 0;

}

</pre>
<p>Output :
<pre>Maximum product is 168</pre>
<p><strong>Exercise:</strong><br/>
1. Print the triplet that has maximum product.</p>
<p>2. Find a minimum product of a triplet in array.</p>
<p>This article is contributed by <strong>Aditya Goel</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post89"> <span class="glyphicon glyphicon-collapse-down"></span>

Count pairs formed by distinct element sub-arrays

</button> <div id="post89" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count pairs formed by distinct element sub-arrays</h1>
</header>
<div class="entry-content">
<p>Given an array, count number of pairs that can be formed from all possible contiguous sub-arrays containing distinct numbers. The array contains positive numbers between 0 to n-1 where n is the size of the array.</p>
<p>Examples:
<pre>

Input:  [1, 4, 2, 4, 3, 2]

Output: 8

The subarrays with distinct elements 

are [1, 4, 2], [2, 4, 3] and [4, 3, 2].

There are 8 pairs that can be formed 

from above array.

(1, 4), (1, 2), (4, 2), (2, 4), (2, 3),

(4, 3), (4, 2), (3, 2)





Input:  [1, 2, 2, 3]

Output: 2

There are 2 pairs that can be formed

from above array.

(1, 2), (2, 3)</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>The idea is to use Sliding Window for the given array. Let us use a window covering from index left to index right and an Boolean array visited to mark elements in current window. The window invariant is that all elements inside the window are distinct. We keep on expanding the window to the right and if a duplicate is found, we shrink the window from left till all elements are distinct again. We update the count of pairs in current window along the way. An observation showed that in an expanding window, number of pairs can be incremented by value equal to window size – 1. For example, </p>
<pre>

<strong>Expanding Window   Count</strong>

  

[1]              Count = 0



[1, 2]           Count += 1 pair  

                 i.e. (1, 2)



[1, 2, 3]        Count += 2 pairs 

                 i.e. (1, 3) and (2, 3)



[1, 2, 3, 4]     Count += 3 pairs 

                 i.e. (1, 4), (2, 4) 

                 and (3, 4)</pre>
<p>So, total Count for above window of size 4 containing distinct elements is 6. Nothing need to be done when the window is shrinking.</p>
<p>Below is C++ implementation of the idea.</p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate" title="">

// C++ program to count number of distinct pairs

// that can be formed from all possible contiguous

// sub-arrays containing distinct numbers

#include &lt;bits/stdc++.h&gt;

using namespace std;



int countPairs(int arr[], int n)

{

    // initialize number of pairs to zero

    int count = 0;



    //Left and right indexes of current window

    int right = 0, left = 0;



    // Boolean array visited to mark elements in

    // current window. Initialized as false

    vector&lt;bool&gt; visited(n, false);



    // While right boundary of current window

    // doesn't cross right end

    while (right &lt; n)

    {

        // If current window contains all distinct

        // elements, widen the window toward right

        while (right &lt; n &amp;&amp; !visited[arr[right]])

        {

            count += (right - left);

            visited[arr[right]] = true;

            right++;

        }



        // If duplicate is found in current window,

        // then reduce the window from left

        while (left &lt; right &amp;&amp; (right != n &amp;&amp;

               visited[arr[right]]))

        {

            visited[arr[left]] = false;

            left++;

        }

    }



    return count;

}



// Driver code

int main()

{

    int arr[] = {1, 4, 2, 4, 3, 2};

    int n = sizeof arr / sizeof arr[0];



    cout &lt;&lt; countPairs(arr, n);



    return 0;

}

</pre>
<p>Output:
<pre>8</pre>
<p><strong>Time Complexity:</strong> The complexity might look O(n^2) as 2 while loop are involved but note that left and right index are changing from 0 to N-1. So overall complexity is O(n + n) = O(n). Auxiliary space required in above solution is O(n) as we are using visited array to mark elements of the current window.</p>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post90"> <span class="glyphicon glyphicon-collapse-down"></span>

Absolute distinct count in a sorted array

</button> <div id="post90" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Absolute distinct count in a sorted array</h1>
</header>
<div class="entry-content">
<p>Given a sorted array of integers, return the  number of distinct absolute values among the elements of the array. The input can contain duplicates values.</p>
<pre>

Input: [-3, -2, 0, 3, 4, 5]

Output: 5

There are 5 distinct absolute values

among the elements of this array, i.e.

0, 2, 3, 4 and 5)



Input:  [-1, -1, -1, -1, 0, 1, 1, 1, 1]

Output: 2



Input:  [-1, -1, -1, -1, 0]

Output: 2



Input:  [0, 0, 0]

Output: 1 

</pre>
<p>The solution should do only one scan of the input array and should not use any extra space. i.e. expected time complexity is O(n) and auxiliary space is O(1).</p>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>One simple solution is to use set. For each element of the input array, we insert its absolute value in the set. As set doesn’t support duplicate elements, the element’s absolute value will be inserted only once. Therefore, the required count is size of the set.</p>
<p>Below is C++ implementation of the idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; title: ; notranslate" title="">

// Program to find absolute distinct

// count of an array in O(n) time.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// The function returns number of

// distinct absolute values among

// the elements of the array

int distinctCount(int arr[], int n)

{

    unordered_set&lt;int&gt; s;



    // Note that set keeps only one

    // copy even if we try to insert

    // multiple values

    for (int i = 0 ; i &lt; n; i++)

        s.insert(abs(arr[i]));



    return s.size();

}



// Driver code

int main()

{

    int arr[] = {-2, -1, 0, 1, 1};

    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Count of absolute distinct values : "

         &lt;&lt; distinctCount(arr, n);



    return 0;

}

</pre>
<p>Output :
<pre>Count of absolute distinct values : 3</pre>
<p>Time Complexity : O(n)<br/>
Auxiliary Space : O(n)</p>
<p><strong><br/>
The above implementation takes O(n) extra space, how to do in O(1) extra space?<br/>
</strong></p>
<p>The idea is to take advantage of the fact that the array is already Sorted. We initialize the count of distinct elements to number of elements in the array. We start with two index variables from two corners of the array and check for pair in the input array with sum as 0. If pair with 0 sum is found or duplicates are encountered, we decrement the count of distinct elements.Finally we return the updated count.</p>
<p>Below is C++ implementation of the idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate" title="">

// Program to find absolute distinct

// count of an array using O(1) space.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// The function returns return number

// of distinct absolute values

// among the elements of the array

int distinctCount(int arr[], int n)

{

    // initialize count as number of elements

    int count = n;

    int i = 0, j = n - 1, sum = 0;



    while (i &lt; j)

    {

        // Remove duplicate elements from the

        // left of the current window (i, j)

        // and also decrease the count

        while (i != j &amp;&amp; arr[i] == arr[i + 1])

            count--, i++;



        // Remove duplicate elements from the

        // right of the current window (i, j)

        // and also decrease the count

        while (i != j &amp;&amp; arr[j] == arr[j - 1])

            count--, j--;



        // break if only one element is left

        if (i == j)

            break;



        // Now look for the zero sum pair

        // in current window (i, j)

        sum = arr[i] + arr[j];



        if (sum == 0)

        {

            // decrease the count if (positive,

            // negative) pair is encountered

            count--;

            i++, j--;

        }

        else if(sum &lt; 0)

            i++;

        else

            j--;

    }



    return count;

}



// Driver code

int main()

{

    int arr[] = {-2, -1, 0, 1, 1};

    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Count of absolute distinct values : "

         &lt;&lt; distinctCount(arr, n);



    return 0;

}

</pre>
<p>Output :
<pre>Count of absolute distinct values : 3</pre>
<p>Time Complexity : O(n)<br/>
Auxiliary Space : O(1)</p>
<p>This article is contributed by <strong>Aditya Goel</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post91"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange array in alternating positive & negative items with O(1) extra space | Set 2

</button> <div id="post91" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange array in alternating positive &amp; negative items with O(1) extra space | Set 2</h1>
</header>
<div class="entry-content">
<p>Given an array of positive and negative numbers, arrange them in an alternate fashion such that every positive number is followed by negative and vice-versa.  Order of elements in output doesn’t matter.  Extra positive or negative elements should be moved to end.</p>
<p>Examples
<pre>

Input :

arr[] = {-2, 3, 4, -1}

Output :

arr[] = {-2, 3, -1, 4} OR {-1, 3, -2, 4} OR ..



Input :

arr[] = {-2, 3, 1}

Output :

arr[] = {-2, 3, 1} OR {-2, 1, 3} 



Input : 

arr[] = {-5, 3, 4, 5, -6, -2, 8, 9, -1, -4}

Output :

arr[] = {-5, 3, -2, 5, -6, 4, -4, 9, -1, 8} 

        OR ..</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>We have already discussed a O(n<sup>2</sup>) solution that maintains the order of appearance in the array <a href="http://www.geeksforgeeks.org/rearrange-array-alternating-positive-negative-items-o1-extra-space/">here</a>. If we are allowed to change order of appearance, we can solve this problem in O(n) time and O(1) space.</p>
<p>The idea is to process the array and shift all negative values to the end in O(n) time. After all negative values are shifted to the end, we can easily rearrange array in alternating positive &amp; negative items. We basically swap next positive element at even position from next negative element in this step. </p>
<p>Following is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]; title: ; notranslate" title="">

// C++ program to rearrange array in alternating

// positive &amp; negative items with O(1) extra space

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Function to rearrange positive and negative

// integers in alternate fashion. The below

// solution doesn't maintain original order of

// elements

void rearrange(int arr[], int n)

{

    int i = -1, j = n;



    // shift all negative values to the end

    while (i &lt; j)

    {

        while (arr[++i] &gt; 0);

        while (arr[--j] &lt; 0);

        if (i &lt; j)

            swap(arr[i], arr[j]);

    }



    // i has index of leftmost negative element

    if (i == 0 || i == n)

        return;



    // start with first positive element at index 0



    // Rearrange array in alternating positive &amp;

    // negative items

    int k = 0;

    while (k &lt; n &amp;&amp; i &lt; n)

    {

    	// swap next positive element at even position

    	// from next negative element.

        swap(arr[k], arr[i]);

        i = i + 1;

        k = k + 2;

    }

}



// Utility function to print an array

void printArray(int arr[], int n)

{

    for (int i = 0; i &lt; n; i++)

      cout &lt;&lt; arr[i] &lt;&lt; " ";

    cout &lt;&lt; endl;

}



// Driver code

int main()

{

    int arr[] = {2, 3, -4, -1, 6, -9};



    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Given array is \n";

    printArray(arr, n);



    rearrange(arr, n);



    cout &lt;&lt; "Rearranged array is \n";

    printArray(arr, n);



    return 0;

}

</pre>
<p>Output:
<pre>

Given array is 

2 3 -4 -1 6 -9 

Rearranged array is 

-1 3 -4 2 -9 6 </pre>
<p>This article is contributed by <strong>Aditya Goel</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post92"> <span class="glyphicon glyphicon-collapse-down"></span>

Minimize the maximum difference between the heights

</button> <div id="post92" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Minimize the maximum difference between the heights</h1>
</header>
<div class="entry-content">
<p>Given heights of n towers and a value k. We need to either increase or decrease height of every tower by k (only once) where k &gt; 0. The task is to minimize the difference between the heights of the longest and the shortest tower after modifications, and output this difference.</p>
<p>Examples: </p>
<pre>

Input  : arr[] = {1, 15, 10}, k = 6

Output : arr[] = {7, 9, 4}

         Maximum difference is 5.

Explanation : We change 1 to 6, 15 to 

9 and 10 to 4. Maximum difference is 5

(between 4 and 9). We can't get a lower

difference.



Input : arr[] = {1, 5, 15, 10} 

        k = 3   

Output : arr[] = {4, 8, 12, 7}

Maximum difference is 8



Input : arr[] = {4, 6} 

        k = 10

Output : arr[] = {14, 16} OR {-6, -4}

Maximum difference is 2



Input : arr[] = {6, 10} 

        k = 3

Output : arr[] = {9, 7} 

Maximum difference is 2



Input : arr[] = {1, 10, 14, 14, 14, 15}

        k = 6 

Output: arr[] = {7, 4, 8, 8, 8, 9} 

Maximum difference is 5



Input : arr[] = {1, 2, 3}

        k = 2 

Output: arr[] = {3, 4, 5} 

Maximum difference is 2

</pre>
<p>Source : <a href="http://www.geeksforgeeks.org/adobe-interview-experience-set-24-on-campus-for-mts/">Adobe Interview Experience | Set 24 (On-Campus for MTS)</a></p>
<p><!--
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=726">
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>

</a> --></p>
<p>The idea is to sort all elements increasing order. Below are steps.</p>
<ol>
<li> Sort array in increasing order</li>
<li> Initialize maximum and minimum elements.<br/>
    maxe = arr[n-1], mine = arr[0]</li>
<li>  If k is more than difference between maximum  and minimum, add/subtract k to all elements as k cannot decrease the difference.  Example {6, 4}, k = 10. </li>
<li>  In sorted array, update first and last elements.<br/>
   arr[0]   += k;  // arr[0] is minimum and k is +ve<br/>
   arr[n-1] -= k;  // arr[n-1] is maximum and k is -ve</li>
<li> Initialize mac and min of modified array (only two elements have been finalized)<br/>
   new_max = max(arr[0], arr[n-1]), new_min = min(arr[0], arr[n-1])</li>
<li> Finalize middle n-2 elements. Do following for every element arr[j] where j lies from 1 to n-2.
<ul>
<li> If current element is less than min of modified array, add k.</li>
<li> Else If current element is more than max of modified array, subtract k.</li>
<li> arr[j] is between new_min and new_max.
<ol>
<li> If arr[j] is closer to new_max, subtract k</li>
<li> Else add k to arr[j]. </li>
</ol>
</li>
</ul>
<li> Update new_max and new_min if required<br/>
        new_max = max(arr[j], new_max),  new_min = min(arr[j], new_min)</li>
<li> Returns difference between new_max and new_min<br/>
    return (new_max – new_min); </li>
</li></ol>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75]; title: ; notranslate" title="">

// C++ program to find the minimum possible

// difference between maximum and minimum

// elements when we have to add/subtract

// every number by k

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Modifies the array by subtracting/adding

// k to every element such that the difference

// between maximum and minimum is minimized

int getMinDiff(int arr[], int n, int k)

{

    // There should be at least two elements

    if (n &lt;= 1)

        return 0;



    // Sort array in increasing order

    sort(arr, arr+n);



    // Initialize maximum and minimum

    int maxe = arr[n-1];

    int mine = arr[0];



    // If k is more than difference between maximum 

    // and minimum, add/subtract k to all elements

    // as k cannot decrease the difference

    if (k &gt;= maxe - mine)

    {

        for (int i=0; i&lt;n; i++)

            arr[i] += k; // Subtract would also work

        return (maxe - mine);

    }



    // In sorted array, first element is minimum

    // and last is maximum, we must add k to minium

    // and subtract k from maximum

    arr[0]   += k;

    arr[n-1] -= k;



    // Initialize mac and min of modified array (only

    // two elements have been finalized)

    int new_max = max(arr[0], arr[n-1]);

    int new_min = min(arr[0], arr[n-1]);



    // Finalize middle n-2 elements

    for (int j=1; j&lt;n-1; j++)

    {

        // If current element is less than min of

        // modified array, add k.

        if (arr[j] &lt; new_min)

            arr[j] += k;



        // If current element is more than max of

        // modified array, subtract k.

        else if (arr[j] &gt; new_max)

            arr[j] -= k;



        // arr[j] is between new_min and new_max



        // If arr[j] is closer to new_max, subtract k

        else if ((arr[j] - new_min) &gt; (new_max - arr[j]))

            arr[j] -= k;



        // Else add k

        else

            arr[j] += k;



        // Update new_max and new_min if required

        new_max = max(arr[j], new_max);

        new_min = min(arr[j], new_min);

    }



    // Returns difference between new_max and new_min

    return (new_max - new_min);

}



// Driver function to test the above function

int main()

{

    int arr[] = {1, 15, 10} ;

    int n = sizeof(arr)/sizeof(arr[0]);

    int k = 6;

    int res = getMinDiff(arr, n, k);



    cout &lt;&lt; "Modified array is \n";

    for (int i=0; i&lt;n; i++)

        cout &lt;&lt; arr[i] &lt;&lt; " ";



    cout &lt;&lt; "\nMaximum difference is " &lt;&lt; res;

    return 0;

}

</pre>
<p>Output :
<pre>Modified array is 

7 9 4 

Maximum difference is 5

</pre>
<p>Time Complexity : O(n Log n)</p>
<p>This article is contributed <strong>Shivam Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post93"> <span class="glyphicon glyphicon-collapse-down"></span>

Find minimum number of merge operations to make an array palindrome

</button> <div id="post93" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find minimum number of merge operations to make an array palindrome</h1>
</header>
<div class="entry-content">
<p>Given an array of positive integers. We need to make the given array a ‘Palindrome’. Only allowed operation on array is merge. Merging two adjacent elements means replacing them with their sum. The task is to find minimum number of merge operations required to make given array a ‘Palindrome’.</p>
<p>To make an array a palindromic we can simply apply merging operations n-1 times where n is the size of array (Note a single element array is alway palindrome similar to single character string). In that case, size of array will be reduced to 1. But in this problem we are asked to do it in minimum number of operations.</p>
<p>Example:</p>
<pre>

Input : arr[] = {15, 4, 15}

Output : 0

Array is already a palindrome. So we

do not need any merge operation.



Input : arr[] = {1, 4, 5, 1}

Output : 1

We can make given array palindrome with

minimum one merging (merging 4 and 5 to

make 9)



Input : arr[] = {11, 14, 15, 99}

Output : 3

We need to merge all elements to make

a palindrome.

</pre>
<p>Expected time complexity is O(n).</p>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=670" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p>Let f(i, j) be minimum merging operations to make subarray arr[i..j] a palindrome. If i == j answer is 0.  We start i from 0 and j from n-1.</p>
<ol>
<li>If arr[i] == arr[j], then there is no need to do any merging operations at index i or index j. Our answer in this case will be f(i+1, j-1).</li>
<li>Else, we need to do merging operations. Following cases arise.</li>
<ul>
<li>If arr[i] &gt; arr[j], then we should do merging operation at index j. We merge index j-1 and j, and update arr[j-1]  = arr[j-1] + arr[j]. Our answer in this case will be 1 + f(i, j-1).</li>
<li>For the case when arr[i] &lt; arr[j], update arr[i+1]  = arr[i+1] + arr[i]. Our answer in this case will be 1  + f(i+1, j).</li>
</ul>
<li>Our answer will be f(0, n-1), where n is size of array arr[].</li>
</ol>
<p>Therefore this problem can be solved iteratively using two pointers (first pointer pointing to start of the array and second pointer pointing to last element of the array) method and keeping count of total merging operations done till now.</p>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate" title="">

// C++ program to find number of operations

// to make an array palindrome

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Returns minimum number of count operations

// required to make arr[] palindrome

int findMinOps(int arr[], int n)

{

    int ans = 0; // Initialize result



    // Start from two corners

    for (int i=0,j=n-1; i&lt;=j;)

    {

        // If corner elements are same,

        // problem reduces arr[i+1..j-1]

        if (arr[i] == arr[j])

        {

            i++;

            j--;

        }



        // If left element is greater, then

        // we merge right two elements

        else if (arr[i] &gt; arr[j])

        {

            // need to merge from tail.

            j--;

            arr[j] += arr[j+1] ;

            ans++;

        }



        // Else we merge left two elements

        else

        {

            i++;

            arr[i] += arr[i-1];

            ans++;

        }

    }



    return ans;

}



// Driver program to test above

int main()

{

    int arr[] = {1, 4, 5, 9, 1};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Count of minimum operations is "

         &lt;&lt;  findMinOps(arr, n) &lt;&lt; endl;

    return 0;

}

</pre>
<p>Output :
<pre>Count of minimum operations is 1</pre>
<p>Time complexity for the given program is : O(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/wBGxPHXAPM4?feature=oembed" width="665"></iframe></p>
<p style="text-align: justify;">This article is contributed by <strong>Ashish Jain</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p style="text-align: justify;">Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post94"> <span class="glyphicon glyphicon-collapse-down"></span>

Count minimum steps to get the given desired array

</button> <div id="post94" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count minimum steps to get the given desired array</h1>
</header>
<div class="entry-content">
<p>Consider an array with n elements and value of all the elements is zero. We can perform following operations on the array.</p>
<ol>
<li>Incremental operations:Choose 1 element from the array and increment its value by 1. </li>
<li>Doubling operation: Double the values of all the elements of array.</li>
</ol>
<p><em><strong>We are given desired array target[] containing n elements. Compute and return the smallest possible number of the operations needed to change the array from all zeros to desired array.</strong></em></p>
<p>Sample test cases:
<pre>

Input: target[] = {2, 3}

Output: 4

To get the target array from {0, 0}, we 

first increment both elements by 1 (2 

operations), then double the array (1 

operation). Finally increment second

element (1 more operation)



Input: target[] = {2, 1}

Output: 3

One of the optimal solution is to apply the 

incremental operation 2 times to first and 

once on second element.



Input: target[] = {16, 16, 16}

Output: 7

The output solution looks as follows. First 

apply an incremental operation to each element. 

Then apply the doubling operation four times. 

Total number of operations is 3+4 = 7</pre>
<p>Source: <a href="http://qa.geeksforgeeks.org/7023/create-desired-array-from-zero-array">http://qa.geeksforgeeks.org/7023/create-desired-array-from-zero-array</a></p>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>One important thing to note is that the task is to count the number of steps to get the given target array (not to convert zero array to target array).  </p>
<p>The idea is to follow reverse steps, i.e. to convert target to array of zeros. Below are steps.
<pre>

Take the target array first. 



Initialize result as 0. 



If all are even, divide all elements by 2 

and increment result by 1. 



Find all odd elements, make them even by 

reducing them by 1. and for every reduction,

increment result by 1.



Finally we get all zeros in target array.</pre>
<p>Below is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate" title="">

/* C++ program to count minimum number of operations

   to get the given target array */

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Returns count of minimum operations to covert a

// zero array to target array with increment and

// doubling operations.

// This function computes count by doing reverse

// steps, i.e., convert target to zero array.

int countMinOperations(unsigned int target[], int n)

{

    // Initialize result (Count of minimum moves)

    int result = 0;



    // Keep looping while all elements of target

    // don't become 0.

    while (1)

    {

        // To store count of zeroes in current

        // target array

        int zero_count = 0;



        int i;  // To find first odd element

        for (i=0; i&lt;n; i++)

        {

            // If odd number found

            if (target[i] &amp; 1)

                break;



            // If 0, then increment zero_count

            else if (target[i] == 0)

                zero_count++;

        }



        // All numbers are 0

        if (zero_count == n)

          return result;



        // All numbers are even

        if (i == n)

        {

            // Divide the whole array by 2

            // and increment result

            for (int j=0; j&lt;n; j++)

               target[j] = target[j]/2;

            result++;

        }



        // Make all odd numbers even by subtracting

        // one and increment result.

        for (int j=i; j&lt;n; j++)

        {

           if (target[j] &amp; 1)

           {

              target[j]--;

              result++;

           }

        }

    }

}



/* Driver program to test above functions*/

int main()

{

    unsigned int arr[] = {16, 16, 16};

    int n = sizeof(arr)/sizeof(arr[0]);

    cout &lt;&lt; "Minimum number of steps required to "

           "get the given target array is " 

         &lt;&lt; countMinOperations(arr, n);

    return 0;

}

</pre>
<p>Output :
<pre>Minimum number of steps required to 

get the given target array is 7</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/AXlPTwCzpAo?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Shivam Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post95"> <span class="glyphicon glyphicon-collapse-down"></span>

Count pairs with given sum

</button> <div id="post95" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count pairs with given sum</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, and a number ‘sum’, find the number of pairs of integers in the array whose sum is equal to ‘sum’.</p>
<pre>

Examples:

Input  :  arr[] = {1, 5, 7, -1}, 

          sum = 6

Output :  2

Pairs with sum 6 are (1, 5) and (7, -1)



Input  :  arr[] = {1, 5, 7, -1, 5}, 

          sum = 6

Output :  3

Pairs with sum 6 are (1, 5), (7, -1) &amp;

                     (1, 5)         



Input  :  arr[] = {1, 1, 1, 1}, 

          sum = 2

Output :  6

There are 3! pairs with sum 2.



Input  :  arr[] = {10, 12, 10, 15, -1, 7, 6, 

                   5, 4, 2, 1, 1, 1}, 

          sum = 11

Output :  9

</pre>
<p>Expected time complexity O(n)</p>
<div id="practice"></div>
<p>A <strong>simple solution</strong> is be traverse each element and check if there’s another number in the array which can be added to it to give sum.<br/>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
</div></div></p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate" title="">

// C++ implementation of simple method to find count of

// pairs with given sum.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Returns number of pairs in arr[0..n-1] with sum equal

// to 'sum'

int getPairsCount(int arr[], int n, int sum)

{

    int count = 0; // Initialize result



    // Consider all possible pairs and check their sums

    for (int i=0; i&lt;n; i++)

        for (int j=i+1; j&lt;n; j++)

            if (arr[i]+arr[j] == sum)

                count++;



    return count;

}



// Driver function to test the above function

int main()

{

    int arr[] = {1, 5, 7, -1, 5} ;

    int n = sizeof(arr)/sizeof(arr[0]);

    int sum = 6;

    cout &lt;&lt; "Count of pairs is " 

         &lt;&lt; getPairsCount(arr, n, sum);

    return 0;

}

</pre>
</div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post96"> <span class="glyphicon glyphicon-collapse-down"></span>

Find lost element from a duplicated array

</button> <div id="post96" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find lost element from a duplicated array</h1>
</header>
<div class="entry-content">
<p>Given two arrays which are duplicates of each other except one element, that is one element from one of the array is missing, we need to find that missing element.</p>
<p>Examples:</p>
<pre>Input:  arr1[] = {1, 4, 5, 7, 9}

        arr2[] = {4, 5, 7, 9}

Output: 1

1 is missing from second array.



Input: arr1[] = {2, 3, 4, 5}

       arr2[] = {2, 3, 4, 5, 6}

Output: 6

6 is missing from first array.</pre>
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b></p>
<p>One <strong>simple solution </strong>is to iterate over arrays and check element by element and flag the missing element when an unmatch is found, but this solution requires linear time over size of array.</p>
<p>Another <strong>efficient solution</strong> is based on<a href="http://geeksquiz.com/binary-search/"> binary search </a>approach. Algorithm steps are as follows:</p>
<p> </p>
<ol>
<li>Start binary search in bigger array and get mid as (lo + hi) / 2</li>
<li>If value from both array is same then missing element must be in right part so set lo as mid</li>
<li>Else set hi as mid because missing element must be in left part of bigger array if mid elements are not equal.</li>
<li>Special case are handled separately as for single element and zero element array, single element itself will be the missing element.<br/>
If first element itself is not equal then that element will be the missing element./li&gt;
</li></ol>
<p>Below is C++ implementation of above steps</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate" title="">

// C++ program to find missing element from same

// arrays (except one missing element)

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Funtion to find missing element based on binary

// search approach.  arr1[] is of larger size and

// N is size of it.  arr1[] and arr2[] are assumed

// to be in same order.

int findMissingUtil(int arr1[], int arr2[], int N)

{

    // special case, for only element which is

    // missing in second array

    if (N == 1)

        return arr1[0];



    // special case, for first element missing

    if (arr1[0] != arr2[0])

        return arr1[0];



    // Initialize current corner points

    int lo = 0,  hi = N - 1;



    // loop until lo &lt; hi

    while (lo &lt; hi)

    {

        int mid = (lo + hi) / 2;



        // If element at mid indices are equal

        // then go to right subarray

        if (arr1[mid] == arr2[mid])

            lo = mid;

        else

            hi = mid;



        // if lo, hi becomes contiguous,  break

        if (lo == hi - 1)

            break;

    }



    // missing element will be at hi index of

    // bigger array

    return arr1[hi];

}



// This function mainly does basic error checking

// and calls findMissingUtil

void findMissing(int arr1[], int arr2[], int M, int N)

{

    if (N == M-1)

        cout &lt;&lt; "Missing Element is "

        &lt;&lt; findMissingUtil(arr1, arr2, M) &lt;&lt; endl;

    else if (M == N-1)

        cout &lt;&lt; "Missing Element is "

        &lt;&lt; findMissingUtil(arr2, arr1, N) &lt;&lt; endl;

    else

        cout &lt;&lt; "Invalid Input";

}



// Driver Code

int main()

{

    int arr1[] = {1, 4, 5, 7, 9};

    int arr2[] = {4, 5, 7, 9};



    int M = sizeof(arr1) / sizeof(int);

    int N = sizeof(arr2) / sizeof(int);



    findMissing(arr1, arr2, M, N);



    return 0;

}

</pre>
<p>Output :
<pre>Missing Element is 1</pre>
<p> <br/>
<center><strong>What if input arrays are not in same order?</strong></center><br/>
In this case, missing element is simply XOR of all elements of both arrays.  Thanks to Yolo Song for suggesting this.</p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate" title="">

// C++ program to find missing element from one array

// such that it has all elements of other array except

// one.  Elements in two arrays can be in any order.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// This function mainly does XOR of all elements

// of arr1[] and arr2[]

void findMissing(int arr1[], int arr2[], int M,

                 int N)

{

    if (M != N-1 &amp;&amp; N != M-1)

    {

        cout &lt;&lt; "Invalid Input";

        return;

    }



    // Do XOR of all element

    int res = 0;

    for (int i=0; i&lt;M; i++)

       res = res^arr1[i];

    for (int i=0; i&lt;N; i++)

       res = res^arr2[i];



    cout &lt;&lt; "Missing element is " &lt;&lt; res;

}



// Driver Code

int main()

{

    int arr1[] = {4, 1, 5, 9, 7};

    int arr2[] = {7, 5, 9, 4};



    int M = sizeof(arr1) / sizeof(int);

    int N = sizeof(arr2) / sizeof(int);



    findMissing(arr1, arr2, M, N);



    return 0;

}

</pre>
<p>Output :
<pre>Missing Element is 1</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/dx8twFuPgvg?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <a href="http://qa.geeksforgeeks.org/user/utkarsh111">Utkarsh Trivedi</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post97"> <span class="glyphicon glyphicon-collapse-down"></span>

Find minimum difference between any two elements

</button> <div id="post97" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Find minimum difference between any two elements</h1>
</header>
<div class="entry-content">
<p>Given an unsorted array, find the minimum difference between any pair in given array.</p>
<p>Examples :
<pre>

Input  : {1, 5, 3, 19, 18, 25};

Output : 1

Minimum difference is between 18 and 19



Input  : {30, 5, 20, 9};

Output : 4

Minimum difference is between 5 and 9



Input  : {1, 19, -4, 31, 38, 25, 100};

Output : 5

Minimum difference is between 1 and -4

</pre>
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=606">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<p><strong>Method 1 (Simple: O(n<sup>2</sup>)</strong><br/>
A simple solution is to use two loops.  </p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]; title: ; notranslate" title="">

// C++ implementation of simple method to find

// minimum difference between any pair

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Returns minimum difference between any pair

int findMinDiff(int arr[], int n)

{

   // Initialize difference as infinite

   int diff = INT_MAX;



   // Find the min diff by comparing difference

   // of all possible pairs in given array

   for (int i=0; i&lt;n-1; i++)

      for (int j=i+1; j&lt;n; j++)

          if (abs(arr[i] - arr[j]) &lt; diff)

                diff = abs(arr[i] - arr[j]);



   // Return min diff

   return diff;

}



// Driver code

int main()

{

   int arr[] = {1, 5, 3, 19, 18, 25};

   int n = sizeof(arr)/sizeof(arr[0]);

   cout &lt;&lt; "Minimum difference is " &lt;&lt; findMinDiff(arr, n);

   return 0;

}

</pre>
<p>Output :
<pre>Minimum difference is 1</pre>
<p> <br/>
<strong>Method 2 (Efficient: O(n Log n)</strong><br/>
The idea is to use sorting. Below are steps.<br/>
1) Sort array in ascending order.  This step takes  O(n Log n) time.<br/>
2) Initialize difference as infinite.   This step takes  O(1) time.<br/>
3) Compare all adjacent pairs in sorted array and keep track of minimum difference. This step takes  O(n) time.</p>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate" title="">

// C++ program to find minimum difference between

// any pair in an unsorted array

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Returns minimum difference between any pair

int findMinDiff(int arr[], int n)

{

   // Sort array in non-decreasing order

   sort(arr, arr+n);



   // Initialize difference as infinite

   int diff = INT_MAX;



   // Find the min diff by comparing adjacent

   // pairs in sorted array

   for (int i=0; i&lt;n-1; i++)

      if (arr[i+1] - arr[i] &lt; diff)

          diff = arr[i+1] - arr[i];



   // Return min diff

   return diff;

}



// Driver code

int main()

{

   int arr[] = {1, 5, 3, 19, 18, 25};

   int n = sizeof(arr)/sizeof(arr[0]);

   cout &lt;&lt; "Minimum difference is " &lt;&lt; findMinDiff(arr, n);

   return 0;

}

</pre>
<p>Output :
<pre>Minimum difference is 1</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/Cr20pvlhqBU?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Harshit Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post98"> <span class="glyphicon glyphicon-collapse-down"></span>

Rearrange an array in maximum minimum form

</button> <div id="post98" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Rearrange an array in maximum minimum form</h1>
</header>
<div class="entry-content">
<p>Given a sorted array of positive integers, rearrange the array alternately i.e first element should be maximum value, second minimum value, third second max, fourth second min and so on. </p>
<p>Examples:</p>
<pre>

Input  : arr[] = {1, 2, 3, 4, 5, 6, 7} 

Output : arr[] = {7, 1, 6, 2, 5, 3, 4}



Input  : arr[] = {1, 2, 3, 4, 5, 6} 

Output : arr[] = {6, 1, 5, 2, 4, 3}</pre>
<p>Expected time complexity is O(n).</p>
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=408">We strongly recommend that you click here and practice it, before moving on to the solution.</a> </h2>
<p>This problems becomes very easy if extra space is allowed.  We can copy the array to another array and then place elements at alternate positions.<br/>
<strong><br/>
How to do in-place?</strong> The idea is to use the fact that numbers are positive. One by one place numbers at their correct positions and mark them negative.<br/>
How to find correct or output position for an element arr[i]? we can observe that the output follows below pattern for an input array.</p>
<pre>

// Output index<strong> j</strong> for an element arr[<strong>i</strong>]

If (i &lt; n/2) 

   j = 2*i + 1 

Else

   j = 2*(n-1-i); </pre>
<p>Below is C++ program based on above facts.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate" title="">

// C++ program to rearrange an array in minimum maximum form

// using O(1) space.

#include &lt;bits/stdc++.h&gt;

using namespace std;



// Puts max at first position, min at second position

// second max at third position, second min at fourth

// position and so on.

void rearrange(int arr[], int n)

{

    // Traverse through all numbers

    for (int i=0; i&lt;n; i++)

    {

        int temp = arr[i];



        // If number is negative then we have already

        // processed it. Else process all numbers which

        // are to be replaced by each other in cyclic way

        while (temp &gt; 0)

        {

            // Find the index where arr[i] should go

            int j = (i &lt; n/2)? 2*i + 1 : 2*(n-1-i);



            // If arr[i] is already at its correct

            // position, mark it as negative

            if (i == j)

            {

                arr[i] = -temp;

                break;

            }



            // Swap the number 'temp' with the current number

            // at its target position

            swap(temp, arr[j]);



            // Mark the number as processed

            arr[j] = -arr[j];



            // Next process the previous number at target position

            i = j;

        }

    }



    // Change the number to original value

    for (int i=0; i&lt;n; i++)

        arr[i] = -arr[i];

}



// Driver program to test above function

int main()

{

    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    int n = sizeof(arr)/sizeof(arr[0]);



    cout &lt;&lt; "Original Array\n";

    for (int i=0; i&lt;n; i++)

       cout &lt;&lt; arr[i] &lt;&lt; " ";



    rearrange(arr, n);



    cout &lt;&lt; "\nModified Array\n";

    for (int i=0; i&lt;n; i++)

       cout &lt;&lt; arr[i] &lt;&lt; " ";

    return 0;

}

</pre>
<p>Output:
<pre>

Original Array

1 2 3 4 5 6 7 8 9 

Modified Array

9 1 8 2 7 3 6 4 5 </pre>
<p>Time complexity of above solution is O(n) as every element is traversed at most twice.</p>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mysterious+Mind">Mysterious Mind</a> for suggesting above solution <a href="http://qa.geeksforgeeks.org/6604/rearrange-an-array-in-maximum-minimum-form?show=6604#q6604">here</a>.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/6sz42JCApIw?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></div>
</div> </div>
<br> <br> <div class="container"> <button type="button" class="btn btn-success" data-toggle="collapse" data-target="#post99"> <span class="glyphicon glyphicon-collapse-down"></span>

Count Strictly Increasing Subarrays

</button> <div id="post99" class="collapse">
<header class="entry-header">
<h1 class="entry-title">Count Strictly Increasing Subarrays</h1>
</header>
<div class="entry-content">
<p>Given an array of integers, count number of <a href="http://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/">subarrays</a> (of size more than one) that are strictly increasing.<br/>
Expected Time Complexity : O(n)<br/>
Expected Extra Space: O(1)</p>
<p>Examples:
<pre>

Input: arr[] = {1, 4, 3}

Output: 1

There is only one subarray {1, 4}



Input: arr[] = {1, 2, 3, 4}

Output: 6

There are 6 subarrays {1, 2}, {1, 2, 3}, {1, 2, 3, 4}

                      {2, 3}, {2, 3, 4} and {3, 4}



Input: arr[] = {1, 2, 2, 4}

Output: 2

There are 2 subarrays {1, 2} and {2, 4}

</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=405" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
 </p>
<p>A <strong>Simple Solution </strong>is to <a href="http://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/">generate all possible subarrays</a>, and for every subarray check if subarray is strictly increasing or not.  Worst case time complexity of this solution would be O(n<sup>3</sup>).</p>
<p>A <strong>Better Solution</strong> is to use the fact that if subarray arr[i:j] is not strictly increasing, then subarrays arr[i:j+1], arr[i:j+2], .. arr[i:n-1] cannot be strictly increasing.  Below is C++ program based on above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]; title: ; notranslate" title="">

// C++ program to count number of strictly

// increasing subarrays

#include&lt;bits/stdc++.h&gt;

using namespace std;



int countIncreasing(int arr[], int n)

{

    // Initialize count of subarrays as 0

    int cnt = 0;



    // Pick starting point

    for (int i=0; i&lt;n; i++)

    {

        // Pick ending point

        for (int j=i+1; j&lt;n; j++)

        {

            if (arr[j] &gt; arr[j-1])

                cnt++;



            // If subarray arr[i..j] is not strictly 

            // increasing, then subarrays after it , i.e., 

            // arr[i..j+1], arr[i..j+2], .... cannot

            // be strictly increasing

            else

                break;

        }

    }

    return cnt;

}



// Driver program

int main()

{

  int arr[] = {1, 2, 2, 4};

  int n = sizeof(arr)/sizeof(arr[0]);

  cout &lt;&lt; "Count of strictly increasing subarrays is "

       &lt;&lt; countIncreasing(arr, n);

  return 0;

}

</pre>
<p>Output:
<pre>

Count of strictly increasing subarrays is 2

</pre>
<p>Time complexity of the above solution is O(m) where m is number of subarrays in output</p>
<p>This problem and solution are contributed by Rahul Agrawal.</p>
<p>An <strong> Efficient Solution</strong> can count subarrays in O(n) time.   The idea is based on fact that a sorted subarray of length ‘len’ adds len*(len-1)/2 to result.  For example, {10, 20, 30, 40} adds 6 to the result.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35]; title: ; notranslate" title="">

// C++ program to count number of strictly

// increasing subarrays in O(n) time.

#include&lt;bits/stdc++.h&gt;

using namespace std;



int countIncreasing(int arr[], int n)

{

    int cnt = 0;  // Initialize result



    // Initialize length of current increasing

    // subarray

    int len = 1;



    // Traverse through the array

    for (int i=0; i &lt; n-1; ++i)

    {

        // If arr[i+1] is greater than arr[i],

        // then increment length

        if (arr[i + 1] &gt; arr[i])

            len++;

            

        // Else Update count and reset length

        else

        {

            cnt += (((len - 1) * len) / 2);

            len = 1;

        }

    }

    

    // If last length is more than 1

    if (len &gt; 1)

        cnt += (((len - 1) * len) / 2);



    return cnt;

}



// Driver program

int main()

{

  int arr[] = {1, 2, 2, 4};

  int n = sizeof(arr)/sizeof(arr[0]);

  cout &lt;&lt; "Count of strictly increasing subarrays is "

       &lt;&lt; countIncreasing(arr, n);

  return 0;

}

</pre>
<p>Output:
<pre>

Count of strictly increasing subarrays is 2

</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/eMuC2LCoMvU?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Big Rectangle Blog Bottom -->
<ins class="adsbygoogle" data-ad-client="ca-pub-9465609616171866" data-ad-slot="4061219431" style="display:inline-block;width:336px;height:280px"></ins>
<script>

(adsbygoogle = window.adsbygoogle || []).push({});

</script>
<br/>
</p></p></p></div>
</div> </div>
















<script type="text/javascript">
// <![CDATA[
var disqus_shortname = 'geeksforgeeks';
(function () {
     var nodes = document.getElementsByTagName('span');
     for (var i = 0, url; i < nodes.length; i++) {
     if (nodes[i].className.indexOf('dsq-postid') != -1) {
     nodes[i].parentNode.setAttribute('data-disqus-identifier', nodes[i].getAttribute('data-dsqidentifier'));
     url = nodes[i].parentNode.href.split('#', 1);
     if (url.length == 1) { url = url[0]; }
     else { url = url[1]; }
     nodes[i].parentNode.href = url + '#disqus_thread';
     }
     }
     var s = document.createElement('script');
     s.async = true;
     s.type = 'text/javascript';
     s.src = '//' + disqus_shortname + '.disqus.com/count.js';
     (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
     }());
// ]]>
</script>

<script type="text/javascript">
(function(){
     var corecss = document.createElement('link');
     var themecss = document.createElement('link');
     var corecssurl = "http://d1gjlxt8vb0knt.cloudfront.net//wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shCore.css?ver=3.0.9b";
     if ( corecss.setAttribute ) {
        corecss.setAttribute( "rel", "stylesheet" );
        corecss.setAttribute( "type", "text/css" );
        corecss.setAttribute( "href", corecssurl );
     } else {
         corecss.rel = "stylesheet";
         corecss.href = corecssurl;
     }
     document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
     var themecssurl = "http://d1gjlxt8vb0knt.cloudfront.net//wp-content/plugins/syntaxhighlighter/syntaxhighlighter3/styles/shThemeDefault.css?ver=3.0.9b";
     if ( themecss.setAttribute ) {
         themecss.setAttribute( "rel", "stylesheet" );
         themecss.setAttribute( "type", "text/css" );
         themecss.setAttribute( "href", themecssurl );
     } else {
         themecss.rel = "stylesheet";
         themecss.href = themecssurl;
     }
     //document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
     document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
})();
SyntaxHighlighter.config.strings.expandSource = '+ expand source';
SyntaxHighlighter.config.strings.help = '?';
SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
SyntaxHighlighter.defaults['gutter'] = false;
SyntaxHighlighter.defaults['pad-line-numbers'] = true;
SyntaxHighlighter.defaults['toolbar'] = false;
SyntaxHighlighter.all();
</script>

<script>
$(document).ready(function(){
  $("#demo").on("hide.bs.collapse", function(){
  });
  $("#demo").on("show.bs.collapse", function(){
  });
});
</script>


<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shCore.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shBrushCpp.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shBrushJava.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/shBrushPython.js"></script>


<link rel="stylesheet" id="tabby-print-css" href="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/tabby-print.css" type="text/css" media="all">
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/comment-reply.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/selectnav.js"></script>
<script type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/tabby.js"></script>
<script>jQuery(document).ready(function($) { RESPONSIVEUI.responsiveTabs(); })</script>
<script async="" type="text/javascript" src="Reversal%20algorithm%20for%20array%20rotation%20-%20GeeksforGeeks_files/fancybar.js" id="_fancybar_js"></script>
</body>
</html>

